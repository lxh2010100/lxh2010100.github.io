<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/blog/0.html"/>
      <url>/blog/0.html</url>
      
        <content type="html"><![CDATA[<p>ltp测试</p><p>环境： ubuntu 22.4</p><ol><li>下载ltp</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/linux-test-project/ltp.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>安装依赖</li></ol><p>对于可选的库依赖项，请查看 <code>ci/</code> 目录中主要发行版的脚本。您还可以使用 <code>./build.sh</code> 脚本构建整个 LTP</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ci/<span class="token function">sudo</span> ./ubuntu.sh <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>配置</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~/Desktop/github/ltp <span class="token comment"># make autotools</span>autoheader<span class="token function">make</span> <span class="token parameter variable">-C</span> testcases/realtime autotoolsmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/jack/Desktop/github/ltp/testcases/realtime'</span>autoheadermake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/jack/Desktop/github/ltp/testcases/realtime'</span><span class="token function">make</span> <span class="token parameter variable">-C</span> testcases/open_posix_testsuite autotoolsmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/jack/Desktop/github/ltp/testcases/open_posix_testsuite'</span>make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Nothing to be <span class="token keyword">done</span> <span class="token keyword">for</span> <span class="token string">'autotools'</span><span class="token builtin class-name">.</span>make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/jack/Desktop/github/ltp/testcases/open_posix_testsuite'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span><span class="token environment constant">$PWD</span>/_install_ltp_x86_x64 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>运行</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> _install_ltp_x86_x64/<span class="token function">sudo</span> ./runltp <span class="token parameter variable">-f</span> syscalls <span class="token comment">#运行所有syscalls</span><span class="token function">sudo</span> ./runltp <span class="token parameter variable">-f</span> syscalls <span class="token parameter variable">-g</span> syscalls.html <span class="token comment">#生成html报告</span><span class="token function">sudo</span> ./runltp <span class="token parameter variable">-s</span> <span class="token builtin class-name">exit</span> <span class="token parameter variable">-g</span> exit_report.html  <span class="token comment"># 运行所有以exit开头的用例</span><span class="token function">sudo</span> ./runltp <span class="token parameter variable">-s</span> exit01 <span class="token parameter variable">-g</span> exit_report.html  <span class="token comment"># 运行以exit01开头的用例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog/0.html"/>
      <url>/blog/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><h3 id="1、Makefile-是什么"><a href="#1、Makefile-是什么" class="headerlink" title="1、Makefile 是什么"></a>1、Makefile 是什么</h3><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，那些文件需要后编译，那些文件需要重新编译，甚至于进行更复杂的功能操作。</p><p>【百度百科 <a href="https://baike.baidu.com/item/Makefile/4619787">https://baike.baidu.com/item/Makefile/4619787</a> 】</p><h3 id="2、make-与-Makefile-的关系"><a href="#2、make-与-Makefile-的关系" class="headerlink" title="2、make 与 Makefile 的关系"></a>2、make 与 Makefile 的关系</h3><p>make是一个命令工具，他解释Makefile中的指令。在Makefile文件中描述了整个工程所有文件的编译顺序、编译规则。</p><h3 id="3、Makefile-命名规则"><a href="#3、Makefile-命名规则" class="headerlink" title="3、Makefile 命名规则"></a>3、Makefile 命名规则</h3><p>Makefile或makefile，一般使用Makefile。</p><h3 id="4、Cmake-又是什么"><a href="#4、Cmake-又是什么" class="headerlink" title="4、Cmake 又是什么"></a>4、Cmake 又是什么</h3><p>Cmake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装（<a href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B&amp;spm=1001.2101.3001.7020">编译过程</a>）。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性，类似UNIX下的automake。只是Cmake的组态档取名为CMakeList.txt。Cmake并不直接构建出最终的软件，而是产生标准的建构档（如UNIX的Makefile或Windows Visual C++ 的projects/workspaces），然后再依一般的建构方式使用。</p><p>【百度百科 <a href="https://baike.baidu.com/item/cmake/7138032">https://baike.baidu.com/item/cmake/7138032</a> 】</p><h3 id="5、Cmake-与-CMakeLists-的关系"><a href="#5、Cmake-与-CMakeLists-的关系" class="headerlink" title="5、Cmake 与 CMakeLists 的关系"></a>5、Cmake 与 CMakeLists 的关系</h3><p>Cmake是一个命令工具，可用来生成Makefile。但也要根据CMakeLists.txt中的内容来生成，CMakeLists.txt就是写给Cmake的规则。</p><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h3><ul><li><p>make是一个命令工具，Makefile是一个文件，make执行的时候，去读取Makefile文件中的规则，<strong>重点是Makefile需要自己写</strong>。</p></li><li><p>Cmake是一个命令工具，CMakeLists.txt是一个文件，Cmake执行的时候，去读取CMakeLists.txt文件中的规则，<strong>重点是CMakeLists.txt需要自己写</strong>。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/c53af1699c6f47b3886cbffe31d90877.png#pic_center"></p><hr><h2 id="二、从-hello-world-开始"><a href="#二、从-hello-world-开始" class="headerlink" title="二、从 hello world 开始"></a>二、从 hello world 开始</h2><h3 id="1、Makefile-基本语法"><a href="#1、Makefile-基本语法" class="headerlink" title="1、Makefile 基本语法"></a>1、Makefile 基本语法</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">目标</span><span class="token punctuation">:</span>依赖Tab 命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>目标：一般是指要编译的目标，也可以是一个动作</li><li>依赖：指执行当前目标所要依赖的先项，包括其他目标，某个具体文件或库等。<strong>一个目标可以有多个依赖</strong></li><li>命令：该目标下要执行的具体命令，可以没有，也可以多条。<strong>多条时，每条命令一行</strong></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#命令前加@，抑制命令本身输出</span><span class="token target symbol">a</span><span class="token punctuation">:</span>b<span class="token operator">@</span>echo <span class="token string">"hello world"</span><span class="token comment">#输出hello world</span><span class="token operator">@</span>ls ./<span class="token comment">#查看当前目录下文件</span>gcc -lstdc++ main.cpp<span class="token comment">#编译源文件</span><span class="token target symbol">b</span><span class="token punctuation">:</span><span class="token operator">@</span>echo <span class="token string">"hello world!"</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token operator">@</span>rm -rf a.out<span class="token comment">#清除编译后产生的.out文件</span><span class="token operator">@</span>echo <span class="token string">"make clean success"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、make-常用选项"><a href="#2、make-常用选项" class="headerlink" title="2、make 常用选项"></a>2、make 常用选项</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make<span class="token punctuation">[</span>-f file<span class="token punctuation">]</span><span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>make默认在当前目录中寻找GNUmakefile，makefile，Makefile的文件作为make的输入文件</p><ul><li><pre><code class="shell">-f 可以指定除上述文件名之外的文件作为输入文件<pre class="line-numbers language-none"><code class="language-none">    *   ```shell    -v 显示版本号    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><pre><code class="shell">-n 只输出命令，但不执行，一般用来测试<pre class="line-numbers language-none"><code class="language-none">    *   ```shell    -s 只执行命令，但不显示具体命令，此处可在命令中用@抑制命令输出    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><p>```shell<br>-w 显示执行前执行后的路径</p><pre class="line-numbers language-none"><code class="language-none">    *   ```shell    -C dir 指定makeflie所在的目录    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="3、gcc-x2F-g-编译流程"><a href="#3、gcc-x2F-g-编译流程" class="headerlink" title="3、gcc/g++ 编译流程"></a>3、gcc/g++ 编译流程</h3><ul><li>源文件</li></ul><p><img src="https://img-blog.csdnimg.cn/25f247493d264f3b9d56cf77eb838b04.png#pic_center"></p><pre class="line-numbers language-none"><code class="language-none">`#这样执行不太好，全部编译耗时长#calc:#gcc add.cpp sub.cpp multi.cpp calc.cpp -o calc#这样分开来写，保证只编译有改动的代码，耗时短calc:add.o sub.o multi.ogcc add.o sub.o multi.o calc.cpp -o calcadd.o:add.cppgcc -c add.cpp -o add.osub.o:sub.cppgcc -c sub.cpp -o sub.omulti.o:multi.cppgcc -c multi.cpp -o multi.o` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>直接从源代码到目标可执行文件</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -lstdc++ main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="三、Makefile-中的变量"><a href="#三、Makefile-中的变量" class="headerlink" title="三、Makefile 中的变量"></a>三、Makefile 中的变量</h2><h3 id="1、系统变量"><a href="#1、系统变量" class="headerlink" title="1、系统变量"></a>1、系统变量</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$*</span> <span class="token comment">#不包括扩展名的目标文件名称</span><span class="token variable">$+</span> <span class="token comment">#所有的依赖文件，以空格分隔</span><span class="token variable">$&lt;</span> <span class="token comment">#表示规则中的第一个条件</span><span class="token variable">$?</span> <span class="token comment">#所有时间戳比目标文件晚的依赖文件，以空格分隔</span><span class="token variable">$@</span> <span class="token comment">#目标文件的完整名称</span><span class="token variable">$^</span> <span class="token comment">#所有不重复的依赖文件，以空格分隔</span><span class="token variable">$%</span> <span class="token comment">#如果目标是归档成员，则该变量表示目标的归档成员名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">`calc:add.o sub.o multi.o calc.ogcc $^ -o $@add.o:add.cppgcc -c $^ -o $@sub.o:sub.cppgcc -c $^ -o $@multi.o:multi.cppgcc -c $^ -o $@calc.o:calc.cppgcc -c $^ -o $@clean:rm -f *.o calc` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、系统常量（可用-make-p-查看）"><a href="#2、系统常量（可用-make-p-查看）" class="headerlink" title="2、系统常量（可用 make -p 查看）"></a>2、系统常量（可用 make -p 查看）</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">AS<span class="token comment">#汇编程序的名称，默认为as</span>CC<span class="token comment">#C编译器名称，默认为cc</span>CPP<span class="token comment">#C预编译器名称，默认为cc -E</span>CXX<span class="token comment">#C++编译器名称，默认为g++</span>RM<span class="token comment">#文件删除程序别名，默认rm -f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">`#$(CC)可替换为$(CXX)，因为$(CXX)可实现跨平台calc:add.o sub.o multi.o calc.o$(CC) add.o sub.o multi.o calc.o -o calcadd.o:add.cpp$(CC) -c add.cpp -o add.osub.o:sub.cpp$(CC) -c sub.cpp -o sub.omulti.o:multi.cpp$(CC) -c multi.cpp -o multi.ocalc.o:calc.cpp$(CC) -c calc.cpp -o calc.oclean:$(RM) *.o calc` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、自定义变量"><a href="#3、自定义变量" class="headerlink" title="3、自定义变量"></a>3、自定义变量</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">定义：变量名<span class="token operator">=</span>变量值使用：<span class="token variable">$</span><span class="token punctuation">(</span>变量名<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">{</span>变量名<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">`OBJ = add.o sub.o multi.o calc.oTARGET = calc$(TARGET):$(OBJ)gcc $(OBJ) -o $(TARGET)add.o:add.cppgcc -c add.cpp -o add.osub.o:sub.cppgcc -c sub.cpp -o sub.omulti.o:multi.cppgcc -c multi.cpp -o multi.ocalc.o:calc.cppgcc -c calc.cpp -o calc.oclean:rm -f *.o $(TARGET)` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="四、Makefile-中的伪目标和模式匹配"><a href="#四、Makefile-中的伪目标和模式匹配" class="headerlink" title="四、Makefile 中的伪目标和模式匹配"></a>四、Makefile 中的伪目标和模式匹配</h2><h3 id="1、伪目标"><a href="#1、伪目标" class="headerlink" title="1、伪目标"></a>1、伪目标</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>目标<span class="token comment">#声明目标为伪目标之后，makefile将不会判断目标是否存在或该目标是否需要更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>如果项目路径中有与<strong>clean</strong>同名的文件，**<code>make clean</code><strong>命令无法执行，需要在</strong>makefile<strong>文件中添加</strong><code>.PHONY:clean</code>**，才能使命令正常执行</li></ul><pre class="line-numbers language-none"><code class="language-none">`.PHONY:cleanOBJ = add.o sub.o multi.o calc.oTARGET = calc$(TARGET):$(OBJ)gcc $(OBJ) -o $(TARGET)add.o:add.cppgcc -c add.cpp -o add.osub.o:sub.cppgcc -c sub.cpp -o sub.omulti.o:multi.cppgcc -c multi.cpp -o multi.ocalc.o:calc.cppgcc -c calc.cpp -o calc.oclean:rm -f *.o $(TARGET)` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、模式匹配"><a href="#2、模式匹配" class="headerlink" title="2、模式匹配"></a>2、模式匹配</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%目标</span><span class="token punctuation">:</span>%依赖<span class="token comment">#目标和依赖相同部分，可以用%来通配</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>依赖中的**<code>add.o sub.o multi.o calc.o</code><strong>都可以通过使用</strong><code>%.o:%.cpp</code>**产生</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">OBJ <span class="token operator">=</span> add.o sub.o multi.o calc.oTARGET <span class="token operator">=</span> calc<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.cppgcc -c <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -f *.o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="makefile-内置函数"><a href="#makefile-内置函数" class="headerlink" title="- makefile 内置函数"></a>- makefile 内置函数</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> 文件列表<span class="token punctuation">)</span><span class="token comment">#获取对应文件路径下的对应模式的文件名</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> 源模式, 目标模式, 文件列表<span class="token punctuation">)</span><span class="token comment">#将文件列表中想要改变的源模式替换成想要的目标模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong><code>$(wildcard ./*.cpp)</code><strong>获取当前目录下所有的</strong>.cpp</strong>文件名</li><li><strong><code>$(patsubst %.cpp, %.o, $(wildcard ./*.cpp))</code><strong>将对应的</strong>.cpp</strong>文件替换为**.o**文件</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#OBJ = add.o sub.o multi.o calc.o</span>OBJ <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.cpp, %.o, <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ./*.cpp<span class="token punctuation">)</span><span class="token punctuation">)</span>TARGET <span class="token operator">=</span> calc<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.cppgcc -c <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -f *.o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="五、Makefile-运行流程"><a href="#五、Makefile-运行流程" class="headerlink" title="五、Makefile 运行流程"></a>五、Makefile 运行流程</h2><p><img src="https://img-blog.csdnimg.cn/5f2ceadab86b4b17b911e81fc95a5d0e.png#pic_center"></p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">calc</span><span class="token punctuation">:</span>add.o sub.o multi.ogcc add.o sub.o multi.o calc.cpp -o calc<span class="token target symbol">add.o</span><span class="token punctuation">:</span>add.cppgcc -c add.cpp -o add.o<span class="token target symbol">sub.o</span><span class="token punctuation">:</span>sub.cppgcc -c sub.cpp -o sub.o<span class="token target symbol">multi.o</span><span class="token punctuation">:</span>multi.cppgcc -c multi.cpp -o multi.o<span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -f *.o calc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>代码执行流程如上图所示</li><li>保证目标是用<strong>最新</strong>的依赖生成的</li><li>第一次<strong>完全编译</strong>，后面只编译最新的代码（<strong>部分编译</strong>）</li></ul><hr><h2 id="六、Makefile-中编译动态链接库"><a href="#六、Makefile-中编译动态链接库" class="headerlink" title="六、Makefile 中编译动态链接库"></a>六、Makefile 中编译<a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93&amp;spm=1001.2101.3001.7020">动态链接库</a></h2><p>动态链接库：不会把代码编译到二进制文件中，而是在运行时才去加载，所以需要维护一个地址</p><ul><li><strong>动态</strong>：动态加载，运行时才加载</li><li><strong>链接</strong>：指库文件和二进制程序分离，用某种手段维护两者之间的关系</li><li><strong>库</strong>：库文件<ul><li><strong>Windows</strong> 中后缀为 <strong>.dll</strong></li><li><strong>Linux</strong> 中后缀为 <strong>.so</strong></li></ul></li><li><strong>常用选项</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-fPIC</span> 产生位置无关的代码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-shared</span> 共享<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-l</span> 指定动态库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-I</span> 指定头文件目录，默认当前目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-L</span> 手动指定库文件搜索目录，默认只链接共享目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>程序可以和库文件分离，可以分别发版，然后库文件可以被多处共享</p><hr><h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><h4 id="发布前："><a href="#发布前：" class="headerlink" title="发布前："></a>发布前：</h4><h5 id="soTest-h"><a href="#soTest-h" class="headerlink" title="soTest.h"></a>soTest.h</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class soTest{public:    void func1();    virtual void func2();    virtual void func3() = 0;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="soTest-cpp"><a href="#soTest-cpp" class="headerlink" title="soTest.cpp"></a>soTest.cpp</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include "soTest.h"void sotest::func1(){    printf("func1\n");}void sotest::func2(){    printf("func2\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-shared</span> <span class="token parameter variable">-fPIC</span> soTest.cpp <span class="token parameter variable">-o</span> libSoTest.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>soTest.cpp</strong>编译后会产生<strong>libsoTest.so</strong>，不用担心文件名不同会出现问题，在后续引用中，<strong>lib</strong>自动会被丢弃</li></ul><h5 id="Test-cpp"><a href="#Test-cpp" class="headerlink" title="Test.cpp"></a>Test.cpp</h5><pre class="line-numbers language-none"><code class="language-none">`#include &lt;iostream&gt;#include "soTest.h"class Test:public soTest{public:    void func2(){        printf("Test-func2\n");    }    void func3(){        printf("Test-func3\n");    }};int main(){    Test t1;    t1.func1();    t1.func2();    t1.func3();        return 0;}` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-lsoTest</span> -L./ Test.cpp <span class="token parameter variable">-o</span> Test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>指定动态库文件<strong>soTest</strong>，编译后由<strong>Test.cpp</strong>文件产生<strong>Test.o</strong>文件</li></ul><h4 id="项目发布："><a href="#项目发布：" class="headerlink" title="项目发布："></a>项目发布：</h4><h5 id="soTest-h-1"><a href="#soTest-h-1" class="headerlink" title="soTest.h"></a>soTest.h</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class soTest{public:    void func1();    virtual void func2();    virtual void func3() = 0;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h5><pre class="line-numbers language-none"><code class="language-none">`#include &lt;iostream&gt;#include "soTest.h"class MainTest:public soTest{public:    void func2(){        printf("MainTest-func2\n");    }    void func3(){        printf("MainTest-func3\n");    }};int main(){    MainTest t1;    t1.func1();    t1.func2();    t1.func3();        return 0;}` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-lsoTest</span> -L./001 main.cpp <span class="token parameter variable">-o</span> main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>编译时指定了要依赖的动态库，但运行时，会无法找到**.so**文件</li></ul><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul><li><p>将<a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E5%BA%93&amp;spm=1001.2101.3001.7020">动态库</a>文件移动到<strong>main.cpp</strong>文件同级目录下</p></li><li><p>运行时手动指定动态库文件所在目录</p><p><strong>Linux</strong>环境下的命令</p><ul><li><p>```shell<br>LD_LIBRARY_PATH = ./001</p><pre class="line-numbers language-none"><code class="language-none">    *   ```shell    export LD_LIBRARY_PATH    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h5 id="001-x2F-Makefile"><a href="#001-x2F-Makefile" class="headerlink" title="001/Makefile"></a>001/Makefile</h5><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">Test</span><span class="token punctuation">:</span>libsoTest.so<span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> -lsoTest -L./ Test.cpp -o Testcp libsoTest.so /usr/lib  <span class="token comment">#路径最好为main.cpp同级目录</span><span class="token target symbol">libsoTest.so</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> -shared -fPIC soTest.cpp -o libsoTest.so<span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> *.so Test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>cp libsoTest.so /usr/lib</code>将动态库文件复制到动态链接库默认路径下 <strong>不推荐复制，污染原库环境</strong></p></li><li><p><strong>Linux</strong> 默认动态库路径配置文件</p><ul><li>/etc/ld.so.conf</li><li>/etc/ld.so.conf.d/*.conf</li></ul></li></ul><hr><h2 id="七、Makefile-中编译静态链接库"><a href="#七、Makefile-中编译静态链接库" class="headerlink" title="七、Makefile 中编译静态链接库"></a>七、Makefile 中编译静态链接库</h2><p>静态链接库：会把库中的代码编译到二进制文件中，当程序编译完成后，该库文件可以删除</p><ul><li><strong>Windows</strong> 中后缀为 <strong>.lib</strong></li><li><strong>Linux</strong> 中后缀为 <strong>.a</strong></li></ul><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>运行时速度快（不用去加载库文件）</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>程序体积更大，并且库中的内容如果有更新，则需要重新编译生成程序</p><h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><ul><li>动态链接库必须与程序同时部署，还要保证程序能加载得到库文件</li><li>静态链接库可以不用部署（已经被加载到程序里面了）</li></ul><hr><h3 id="例：-1"><a href="#例：-1" class="headerlink" title="例："></a>例：</h3><h4 id="发布前：-1"><a href="#发布前：-1" class="headerlink" title="发布前："></a>发布前：</h4><h5 id="aTest-h"><a href="#aTest-h" class="headerlink" title="aTest.h"></a>aTest.h</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class aTest{public:    void func1();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="aTest-cpp"><a href="#aTest-cpp" class="headerlink" title="aTest.cpp"></a>aTest.cpp</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include "aTest.h"void aTest::func1(){    printf("aTest-func1\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-c</span> aTest.cpp <span class="token parameter variable">-o</span> aTest.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>aTest.cpp</strong>编译后会产生<strong>libaTest.a</strong>，不用担心文件名不同会出现问题，在后续引用中，<strong>lib</strong>自动会被丢弃</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ar <span class="token parameter variable">-r</span> libaTest.a aTest.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将<strong>aTest.o</strong>加入到<strong>libaTest.a</strong>中。默认的加入方式为append，即<strong>加在库的末尾</strong>。</li></ul><h4 id="项目发布：-1"><a href="#项目发布：-1" class="headerlink" title="项目发布："></a>项目发布：</h4><h5 id="aTest-h-1"><a href="#aTest-h-1" class="headerlink" title="aTest.h"></a>aTest.h</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class aTest{public:    void func1();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="main-cpp-1"><a href="#main-cpp-1" class="headerlink" title="main.cpp"></a>main.cpp</h5><pre class="line-numbers language-none"><code class="language-none">`#include &lt;iostream&gt;#include "soTest.h"#include "aTest.h"class MainTest:public soTest{public:    void func2(){        printf("MainTest-func2\n");    }    void func3(){        printf("MainTest-func3\n");    }};int main(){    MainTest t1;    t1.func1();    t1.func2();    t1.func3();        printf("\n\n");        aTest t2;    t2.func1();        return 0;}` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21*   22*   23*   24*   25*   26*   27<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-lsoTest</span> -L./001 <span class="token parameter variable">-laTest</span> -L./002 main.cpp <span class="token parameter variable">-o</span> main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>指定动态库文件<strong>soTest</strong>和静态库文件<strong>aTest</strong>，编译后由<strong>main.cpp</strong>文件产生<strong>main.o</strong>文件</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">objdump <span class="token parameter variable">-DC</span> main<span class="token operator">&gt;</span>main.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>会生成一个类似于反汇编的文本文档，进入搜索可以找到<strong>aTest::func1()</strong> 的定义，但只能找到<strong>soTest::func1()<strong>、</strong>soTest::func2()<strong>、</strong>soTest::func3()</strong> 的引用</li></ul><h5 id="002-x2F-Makefile"><a href="#002-x2F-Makefile" class="headerlink" title="002/Makefile"></a>002/Makefile</h5><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">libaTest</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> -c aTest.cpp -o aTest.o<span class="token variable">$</span><span class="token punctuation">(</span>AR<span class="token punctuation">)</span> -r libaTest.a aTest.o<span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> *.o *.a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h5><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> mainLDFLAGS <span class="token operator">=</span> -L./001 -L./002LIBS <span class="token operator">=</span> -lsoTest -laTest<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LIBS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> main.cpp -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="八、Makefile-中通用部分做公共文件头"><a href="#八、Makefile-中通用部分做公共文件头" class="headerlink" title="八、Makefile 中通用部分做公共文件头"></a>八、Makefile 中通用部分做公共文件头</h2><h3 id="例：-2"><a href="#例：-2" class="headerlink" title="例："></a>例：</h3><h4 id="003-x2F-a-cpp"><a href="#003-x2F-a-cpp" class="headerlink" title="003/a.cpp"></a>003/a.cpp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;void func_a(){printf("func-a.cpp");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="003-x2F-b-cpp"><a href="#003-x2F-b-cpp" class="headerlink" title="003/b.cpp"></a>003/b.cpp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;void func_b(){printf("func-b.cpp");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="003-x2F-c-cpp"><a href="#003-x2F-c-cpp" class="headerlink" title="003/c.cpp"></a>003/c.cpp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">extern void func_a();extern void func_b();int main(){func_a();    func_b();        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="003-x2F-Makefile"><a href="#003-x2F-Makefile" class="headerlink" title="003/Makefile"></a>003/Makefile</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> c<span class="token keyword">include</span> ../makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h4 id="004-x2F-x-c"><a href="#004-x2F-x-c" class="headerlink" title="004/x.c"></a>004/x.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">func_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func-x.c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="004-x2F-y-c"><a href="#004-x2F-y-c" class="headerlink" title="004/y.c"></a>004/y.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">func_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func-y.c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="004-x2F-z-c"><a href="#004-x2F-z-c" class="headerlink" title="004/z.c"></a>004/z.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">func_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">func_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">func_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="004-x2F-Makefile"><a href="#004-x2F-Makefile" class="headerlink" title="004/Makefile"></a>004/Makefile</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> z<span class="token keyword">include</span> ../makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">SOURCE <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ./*.cpp ./*.C<span class="token punctuation">)</span>OBJ <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.cpp, %.o, <span class="token variable">$</span><span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span><span class="token punctuation">)</span>OBJ <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c, %.o, <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>clean<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Makefile</strong> 中，都是先展开所有变量，再调用指令</p><ul><li><strong>=</strong> 赋值，但是用终值，就是不管变量调用写在赋值前还是赋值后，调用时都是取终值</li><li>**:= ** 也是赋值，但是只受当前行及之前的代码影响，而不会受后面的赋值影响</li></ul><hr><h2 id="九、Makefile-中调用-shell-命令"><a href="#九、Makefile-中调用-shell-命令" class="headerlink" title="九、Makefile 中调用 shell 命令"></a>九、Makefile 中调用 shell 命令</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">FILE <span class="token operator">=</span> abcA <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> ls ../<span class="token punctuation">)</span>B <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>C <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> if [ ! -f <span class="token variable">$</span><span class="token punctuation">(</span>FILE<span class="token punctuation">)</span> ]<span class="token punctuation">;</span> then touch <span class="token variable">$</span><span class="token punctuation">(</span>FILE<span class="token punctuation">)</span><span class="token punctuation">;</span> fi<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token target symbol">a</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>FILE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>$(shell ls ../)</code> 列出上级目录中的所有目录</li><li><code>$(shell pwd)</code> 显示当前所在工作目录的绝对路径</li><li><code>$(shell if [ ! -f $(FILE) ]; then touch $(FILE); fi;)</code> 判断文件是否存在</li></ul><hr><h2 id="十、Makefile-中的嵌套调用和多项目同时编译"><a href="#十、Makefile-中的嵌套调用和多项目同时编译" class="headerlink" title="十、Makefile 中的嵌套调用和多项目同时编译"></a>十、Makefile 中的嵌套调用和多项目同时编译</h2><h3 id="例：-3"><a href="#例：-3" class="headerlink" title="例："></a>例：</h3><p>源文件为 <strong><code>八、Makefile 中通用部分做公共文件头</code></strong> 中的例子用到的</p><ul><li><strong>makefile</strong> 更名为 <strong>makefile-head</strong></li><li><strong>003/Makefile</strong>、<strong>004/Makefile</strong> 中的 <code>include ../makefile</code> 改为<code>include ../makefile-head</code></li><li>新建的<strong>Makefile</strong> 与 <strong>makefile-head</strong> 在同一级目录下</li></ul><h4 id="Makefile-1"><a href="#Makefile-1" class="headerlink" title="Makefile"></a>Makefile</h4><ul><li><strong>v1</strong></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>make -C ./003make -c ./004<span class="token target symbol">clean</span><span class="token punctuation">:</span>make -C ./003 cleanmake -C ./004 clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>v2</strong></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>003 004 DIR <span class="token operator">=</span> 003 004<span class="token target symbol">all</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>DIR<span class="token punctuation">)</span><span class="token target symbol"><span class="token variable">$</span>(DIR)</span><span class="token punctuation">:</span>make -C <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> for dir in <span class="token variable">$</span><span class="token punctuation">(</span>DIR<span class="token punctuation">)</span><span class="token punctuation">;</span> do make -C <span class="token variable">$$dir</span> clean<span class="token punctuation">;</span> done<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="十一、Makefile-中的条件判断"><a href="#十一、Makefile-中的条件判断" class="headerlink" title="十一、Makefile 中的条件判断"></a>十一、Makefile 中的条件判断</h2><ul><li><strong>ifeq</strong> 判断是否相等，相等返回 <strong>true</strong>，不相等返回 <strong>false</strong></li><li><strong>ifneq</strong> 判断是否不相等，不相等返回 <strong>true</strong>，相等返回 <strong>false</strong></li><li><strong>ifdef</strong> 判断变量是否存在，存在返回 <strong>true</strong>，不存在返回 <strong>false</strong></li><li><strong>ifndef</strong> 判断变量是否不存在，不存在返回 <strong>true</strong>，存在返回 <strong>false</strong></li></ul><h3 id="例"><a href="#例" class="headerlink" title="例:"></a>例:</h3><h4 id="Makefile-2"><a href="#Makefile-2" class="headerlink" title="Makefile"></a>Makefile</h4><pre class="line-numbers language-none"><code class="language-none">`A := 123RS1 :=RS2 :=RS3 :=RS4 :=ifeq ($(A), 123)RS1 := RS1-yeselseRS1 := RS1-noendififneq ($(A), 123)RS2 := RS2-yeselseRS2 := RS2-noendififdef ARS3 := RS3-yeselseRS3 := RS3-noendififndef ARS4 := RS4-yeselseRS4 := RS4-noendififdef FLAGFLAG := defaultendifall:echo $(RS1)echo $(RS2)echo $(RS3)echo $(RS4)echo flag = $(FLAG)` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21*   22*   23*   24*   25*   26*   27*   28*   29*   30*   31*   32*   33*   34*   35*   36*   37*   38*   39*   40*   41<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>ifeq</strong>、<strong>ifneq</strong>、<strong>ifdef</strong>、<strong>ifndef</strong> 与条件之间要有空格，不然会报错</p></li><li><p>可以只有 <strong>if</strong>，没有 <strong>else</strong></p><ul><li><p>```makefile<br>ifdef FLAG<br>FLAG := default<br>endif</p><pre class="line-numbers language-none"><code class="language-none">        *   没有 **elseif** 的用法，如果要实现 **elseif**，就要写嵌套        *   ```makefile        ifeq ($(A), 321)        RS1 := 321        else        ifeq ($(A), 123)                RS1 := 123            else                RS1 := 0            endif        endif        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>命令行传参</p><ul><li><p>```shell<br>make -f Makefile FLAG=456</p><pre class="line-numbers language-none"><code class="language-none">    *   ```shell        make FLAG=456    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h2 id="十二、Makefile-中的循环"><a href="#十二、Makefile-中的循环" class="headerlink" title="十二、Makefile 中的循环"></a>十二、Makefile 中的循环</h2><h3 id="例：-4"><a href="#例：-4" class="headerlink" title="例："></a>例：</h3><h4 id="Makefile-3"><a href="#Makefile-3" class="headerlink" title="Makefile"></a>Makefile</h4><ul><li><strong>makefile</strong> 中只有一个循环 <strong>foreach</strong>，只支持 <strong>GNU Make</strong>，其他平台的 <strong>make</strong> 需要使用 <strong>shell</strong> 中的循环来实现</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> a b c d<span class="token target symbol">all</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> v, <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>, <span class="token variable">$v</span><span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> v, <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>, <span class="token variable">$v.txt</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>foreach</strong> 可以在循环中逐个的修改值</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> a b c d<span class="token target symbol">all</span><span class="token punctuation">:</span>touch <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>touch <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> v, <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>, <span class="token variable">$v</span><span class="token punctuation">)</span>touch <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> v, <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>, <span class="token variable">$v.txt</span><span class="token punctuation">)</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> *.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="十三、Makefile-中自定义函数的实现和调用"><a href="#十三、Makefile-中自定义函数的实现和调用" class="headerlink" title="十三、Makefile 中自定义函数的实现和调用"></a>十三、Makefile 中自定义函数的实现和调用</h2><h3 id="例：-5"><a href="#例：-5" class="headerlink" title="例："></a>例：</h3><h4 id="Makefile-4"><a href="#Makefile-4" class="headerlink" title="Makefile"></a>Makefile</h4><ul><li>自定义函数不是真正的函数，本质上是多行命令放在了目标外</li><li>可以传递参数<ul><li><strong>$(0)</strong> 为本身文件名</li><li><strong>( 1 ) ∗ ∗ 为要接受的参数 ∗ ∗ (1)</strong> 为要接受的参数 ** (1)∗∗为要接受的参数∗∗(A)**</li><li><strong>$(2)</strong> 为要接受的参数 <strong>asd</strong></li></ul></li><li>没有返回值<ul><li><strong>( c a l l F U N C 2 ) ∗ ∗ 会报错，可以在 ∗ ∗ (call FUNC2)</strong> 会报错，可以在 ** (callFUNC2)∗∗会报错，可以在∗∗(call FUNC2)** 前加 <strong><code>echo</code></strong> 命令，将 <strong>return</strong> 当作一个字符串，和 <strong>123</strong> 一起输出</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">`A := 123define FUNC1echo funcecho $(0) $(1) $(2)endefdefine FUNC2return 123endefdefine FUNC3echo $(shell ls)endefall:$(call FUNC1, $(A), asd)$(call FUNC2)$(call FUNC3)` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="十四、make-install-的实现"><a href="#十四、make-install-的实现" class="headerlink" title="十四、make install 的实现"></a>十四、make install 的实现</h2><ul><li><p><strong>make</strong></p><ul><li>将源文件编译成二进制可执行文件（包括各种库文件）</li></ul></li><li><p><strong>make install</strong></p><ul><li><p>创建目录，将可执行文件拷贝到指定目录（安装目录）</p></li><li><p>加全局可执行的路径</p></li><li><p>加全局的启停脚本</p></li></ul></li><li><p><strong>make clean</strong></p><ul><li>重置编辑环境，删除无关文件</li></ul></li></ul><h3 id="例：-6"><a href="#例：-6" class="headerlink" title="例："></a>例：</h3><h4 id="main-cpp-2"><a href="#main-cpp-2" class="headerlink" title="main.cpp"></a>main.cpp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unistd.h&gt;using namespace std;int main(){    int i = 0;    while (true){i++;        cout&lt;&lt;"main-running-"&lt;&lt;i&lt;&lt;endl;        sleep(1);    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Makefile-5"><a href="#Makefile-5" class="headerlink" title="Makefile"></a>Makefile</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">MYPATH <span class="token operator">:=</span> /test/main/BIN <span class="token operator">:=</span> /usr/local/bin/START_S <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>_startSTOP_S <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>_stopLOG <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.logTARGET <span class="token operator">:=</span> mainOBJ <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.oCC <span class="token operator">=</span> g++<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span class="token target symbol">install</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>if [ -d <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span> ]<span class="token punctuation">;</span>\then echo <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span> exist<span class="token punctuation">;</span>\<span class="token keyword">else</span>\    mkdir <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>\cp <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>\ln -sv <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token punctuation">;</span>\touch <span class="token variable">$</span><span class="token punctuation">(</span>LOG<span class="token punctuation">)</span><span class="token punctuation">;</span>\chmod a+rwx <span class="token variable">$</span><span class="token punctuation">(</span>LOG<span class="token punctuation">)</span><span class="token punctuation">;</span>\echo <span class="token string">"$(TARGET)&gt;$(LOG) &amp; echo $(TARGET) running..."</span>&gt;<span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>START_S<span class="token punctuation">)</span><span class="token punctuation">;</span>\echo <span class="token string">"killall $(TARGET)"</span>&gt;<span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>STOP_S<span class="token punctuation">)</span><span class="token punctuation">;</span>\chmod a+x <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>START_S<span class="token punctuation">)</span><span class="token punctuation">;</span>\chmod a+x <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>STOP_S<span class="token punctuation">)</span><span class="token punctuation">;</span>\ln -sv <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>START_S<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token punctuation">;</span>\ln -sv <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>STOP_S<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token punctuation">;</span>\fi<span class="token punctuation">;</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>START_S<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>STOP_S<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> -rf <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>clean install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>判断对应路径下是否存在<ul><li>存在<ul><li>输出路径存在</li></ul></li><li>不存在<ul><li>创建一个与路径相同的目录</li><li>把可执行文件复制到对应目录下</li><li>为该文件在某一位置创建一个同步的软链接，即全局可执行路径</li><li>在目录下创建一个日志文件并增加权限</li><li>在目录下创建启停脚本，增加权限，并创建一个同步的软链接</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本学习02--运算符</title>
      <link href="/blog/c67b5973.html"/>
      <url>/blog/c67b5973.html</url>
      
        <content type="html"><![CDATA[<h2 id="Shell运算符"><a href="#Shell运算符" class="headerlink" title="Shell运算符"></a>Shell运算符</h2><p>Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><p><code>expr</code> 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 命令行直接计算</span><span class="token function">expr</span> <span class="token number">2</span> + <span class="token number">2</span>   <span class="token comment">#4</span><span class="token function">expr</span> <span class="token number">3</span> - <span class="token number">2</span>   <span class="token comment">#1</span><span class="token function">expr</span> <span class="token number">3</span> / <span class="token number">2</span>   <span class="token comment">#1</span><span class="token function">expr</span> <span class="token number">3</span> <span class="token punctuation">\</span>* <span class="token number">2</span>   <span class="token comment">#6</span><span class="token comment"># 使用表达式</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a + $b<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token string">"a + b : <span class="token variable">$val</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li><strong>表达式和运算符之间要有空格</strong>，例如 <code>2+2</code> 是不对的，必须写成 <code>2 + 2</code>，这与我们熟悉的大多数编程语言不一样。</li><li>乘号(*)前边必须加反斜杠()才能实现乘法运算</li><li>完整的表达式要被 <code> </code> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li></ul><p><strong>算术运算符列表</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">运算符说明    举例+    加法<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a + $b<span class="token variable">`</span></span> 结果为 <span class="token number">30</span>。-   减法<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a - $b<span class="token variable">`</span></span> 结果为 <span class="token number">10</span>。*    乘法<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a <span class="token punctuation">\</span>* $b<span class="token variable">`</span></span> 结果为  <span class="token number">200</span>。/    除法<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $b / $a<span class="token variable">`</span></span> 结果为 <span class="token number">2</span>。%    取余<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $b % $a<span class="token variable">`</span></span> 结果为 <span class="token number">0</span>。<span class="token operator">=</span>    赋值<span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token variable">$b</span> 将把变量 b 的值赋给 a。<span class="token operator">==</span>    相等。用于比较两个数字，相同则返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$b</span> <span class="token punctuation">]</span> 返回 false。<span class="token operator">!=</span>    不相等。用于比较两个数字，不相同则返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token variable">$b</span> <span class="token punctuation">]</span> 返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-eq</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span> -eq <span class="token variable">$b</span> : a is equal to b"</span><span class="token keyword">else</span>   <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span> -eq <span class="token variable">$b</span>: a is not equal to b"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缩成一行可以这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-eq</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span> -eq <span class="token variable">$b</span> : a is equal to b"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span> -eq <span class="token variable">$b</span>: a is not equal to b"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里缩写，主要是为了让大家注意：</p><ul><li>if后面直到then前面的分号结束，都是有空格的: <code>if [ $a -eq $b ]</code></li></ul><p><strong>关系运算符列表</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">运算符说明<span class="token parameter variable">-eq</span>检测两个数是否相等，相等返回 true。同算数运算符<span class="token variable"><span class="token variable">`</span><span class="token operator">==</span><span class="token variable">`</span></span><span class="token parameter variable">-ne</span>检测两个数是否相等，不相等返回 <span class="token boolean">true</span><span class="token parameter variable">-gt</span>检测左边的数是否大于右边的，如果是，则返回 true。<span class="token parameter variable">-lt</span>检测左边的数是否小于右边的，如果是，则返回 true。<span class="token parameter variable">-ge</span>检测左边的数是否大等于右边的，如果是，则返回 true。<span class="token parameter variable">-le</span>检测左边的数是否小于等于右边的，如果是，则返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p><strong>布尔运算符列表</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">运算符说明<span class="token operator">!</span>非运算，表达式为 <span class="token boolean">true</span> 则返回 false，否则返回 true。<span class="token parameter variable">-o</span>或运算<span class="token punctuation">(</span>or<span class="token punctuation">)</span>，有一个表达式为 <span class="token boolean">true</span> 则返回 true。<span class="token parameter variable">-a</span>与运算<span class="token punctuation">(</span>and<span class="token punctuation">)</span>，两个表达式都为 <span class="token boolean">true</span> 才返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token number">3</span> <span class="token parameter variable">-eq</span> <span class="token number">3</span> <span class="token parameter variable">-a</span> <span class="token number">3</span> <span class="token parameter variable">-lt</span> <span class="token number">5</span> <span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">'ok'</span><span class="token keyword">fi</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p><strong>字符串运算符列表</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">运算符说明举例<span class="token operator">=</span>检测两个字符串是否相等，相等返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token variable">$b</span> <span class="token punctuation">]</span> 返回 false。<span class="token operator">!=</span>检测两个字符串是否相等，不相等返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token variable">$b</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-z</span>检测字符串长度是否为0，为0返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token variable">$a</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-n</span>检测字符串长度是否为0，不为0返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token variable">$a</span> <span class="token punctuation">]</span> 返回 true。str检测字符串是否为空，不为空返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token punctuation">]</span> 返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token assign-left variable">file</span><span class="token operator">=</span><span class="token string">"/tmp/test.sh"</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-e</span> <span class="token variable">$file</span> <span class="token punctuation">]</span><span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"File exists"</span><span class="token keyword">else</span>   <span class="token builtin class-name">echo</span> <span class="token string">"File does not exist"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件测试运算符列表</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">操作符说明举例<span class="token parameter variable">-b</span> <span class="token function">file</span>检测文件是否是块设备文件，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-b</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-c</span> <span class="token function">file</span>检测文件是否是字符设备文件，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-c</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-d</span> <span class="token function">file</span>检测文件是否是目录，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-d</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-f</span> <span class="token function">file</span>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-g</span> <span class="token function">file</span>检测文件是否设置了 SGID 位，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-g</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-k</span> <span class="token function">file</span>检测文件是否设置了粘着位<span class="token punctuation">(</span>Sticky Bit<span class="token punctuation">)</span>，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-k</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-p</span> <span class="token function">file</span>检测文件是否是具名管道，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-p</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-u</span> <span class="token function">file</span>检测文件是否设置了 SUID 位，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-u</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-r</span> <span class="token function">file</span>检测文件是否可读，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-r</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-w</span> <span class="token function">file</span>检测文件是否可写，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-w</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-x</span> <span class="token function">file</span>检测文件是否可执行，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-x</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-s</span> <span class="token function">file</span>检测文件是否为空（文件大小是否大于0），不为空返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-s</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-e</span> <span class="token function">file</span>检测文件（包括目录）是否存在，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-e</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell脚本基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本学习03--字符串和数组</title>
      <link href="/blog/b5726c19.html"/>
      <url>/blog/b5726c19.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似：</p><p>单双引号的区别：</p><ul><li>双引号里可以有变量，单引号则原样输出；</li><li>双引号里可以出现转义字符，单引号则原样输出；</li><li>单引号字串中不能出现单引号。</li></ul><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">str1</span><span class="token operator">=</span><span class="token string">'i'</span><span class="token assign-left variable">str2</span><span class="token operator">=</span><span class="token string">'love'</span><span class="token assign-left variable">str3</span><span class="token operator">=</span><span class="token string">'you'</span><span class="token builtin class-name">echo</span> <span class="token variable">$str1</span> <span class="token variable">$str2</span> <span class="token variable">$str3</span><span class="token builtin class-name">echo</span> <span class="token variable">$str1</span><span class="token variable">$str2</span><span class="token variable">$str3</span><span class="token builtin class-name">echo</span> <span class="token variable">$str1</span>,<span class="token variable">$str2</span>,<span class="token variable">$str3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">i love youiloveyoui,love,you<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">'i love you'</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>str}</span><span class="token comment"># 输出：10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">'i love you'</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:</span>1}</span> <span class="token comment"># 从第1个截取到末尾。注意从0开始。</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:</span>2<span class="token operator">:</span>2}</span> <span class="token comment"># 从第2个截取2个。</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:</span>0}</span> <span class="token comment"># 全部截取。</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:-</span>3}</span> <span class="token comment"># 负数无效，视为0。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">love youloi love youi love you<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">"i love you"</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> index <span class="token string">"<span class="token variable">$str</span>"</span> l<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> index <span class="token string">"<span class="token variable">$str</span>"</span> you<span class="token variable">`</span></span> <span class="token comment">#最后一个参数是字符，会对后面字符串每一个单独查找，返回最靠前的index</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> index <span class="token string">"<span class="token variable">$str</span>"</span> o<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> length <span class="token string">"<span class="token variable">$str</span>"</span><span class="token variable">`</span></span> <span class="token comment">#字符串长度</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> substr <span class="token string">"<span class="token variable">$str</span>"</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">`</span></span> <span class="token comment">#从字符串中位置1开始截取6个字符。索引是从0开始的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出:</p><pre class="line-numbers language-none"><code class="language-none">34410i love<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意字符串变量需要加双引号。第2个例子里<code>you</code>虽然<code>y</code>的index是8,但是<code>o</code>在前面已经出现过,index是4，最终取所有字符里最靠前的index。</p><p>拓展：<code>expr</code>更多关于字符串用法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">STRING <span class="token builtin class-name">:</span> REGEXP   anchored pattern match of REGEXP <span class="token keyword">in</span> STRINGmatch STRING REGEXP        same as STRING <span class="token builtin class-name">:</span> REGEXPsubstr STRING POS LENGTH   <span class="token comment">#从STRING中POS位置开始截取LENGTH个字符。POS索引是从1开始的。</span>index STRING CHARS         <span class="token comment">#在STRING中查找字符CHARS首次出现的位置，没有找到返回0</span>length STRING              <span class="token comment">#字符串长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。</p><p>在Shell中，用括号来表示数组，数组元素用<code>空格</code>符号分割开。定义数组的一般形式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">array_name</span><span class="token operator">=</span><span class="token punctuation">(</span>value1 value2 <span class="token punctuation">..</span>. valuen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">array_name</span><span class="token operator">=</span><span class="token punctuation">(</span>value0 value1 value2 value3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">array_name</span><span class="token operator">=</span><span class="token punctuation">(</span>    value0    value1    value2    value3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以单独定义数组的各个分量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">array_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>value0array_name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>value1array_name<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>value2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以不使用连续的下标，而且下标的范围没有限制。</p><p>下面来读取数组：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">${array_name<span class="token punctuation">[</span>2<span class="token punctuation">]</span>}</span> <span class="token comment">#读取下标为2的元素</span><span class="token builtin class-name">echo</span> <span class="token variable">${array_name<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span> <span class="token comment">#读取所有元素</span><span class="token builtin class-name">echo</span> <span class="token variable">${array_name<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> <span class="token comment">#读取所有元素</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>array_name<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span> <span class="token comment">#获取数组长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>array_name<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> <span class="token comment">#获取数组长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>array_name<span class="token punctuation">[</span>1<span class="token punctuation">]</span>}</span> <span class="token comment">#获取数组中单个元素的长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">value2value0 value1 value2 value3value0 value1 value2 value3<span class="token number">4</span><span class="token number">4</span><span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比shell里字符串和数组，我们发现：</p><p>字符串</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">"hello"</span><span class="token variable">${<span class="token operator">#</span>str}</span> <span class="token comment"># 读取字符串长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${str}</span> <span class="token comment"># 读取字符串全部</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:</span>1}</span> <span class="token comment"># 截取字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>数组：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">arr</span><span class="token operator">=</span><span class="token punctuation">(</span>a1 a2 a3<span class="token punctuation">)</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>arr<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span> <span class="token comment"># 读取数组长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>arr<span class="token punctuation">[</span>1<span class="token punctuation">]</span>}</span> <span class="token comment"># 读取数组某个元素长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${arr<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span> <span class="token comment"># 读取数组全部</span><span class="token builtin class-name">echo</span> <span class="token variable">${arr<span class="token punctuation">[</span>1<span class="token punctuation">]</span>}</span> <span class="token comment"># 读取数组某个元素</span><span class="token comment"># 总结</span><span class="token comment"># ${#ele*} 用来读取ele元素长度属性</span><span class="token comment"># ${ele*}  用来读取或操作ele元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell脚本基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本学习04--条件控制</title>
      <link href="/blog/45de763f.html"/>
      <url>/blog/45de763f.html</url>
      
        <content type="html"><![CDATA[<h2 id="条件判断：if语句"><a href="#条件判断：if语句" class="headerlink" title="条件判断：if语句"></a>条件判断：if语句</h2><p>语法格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> expression <span class="token punctuation">]</span><span class="token keyword">then</span>   Statement<span class="token punctuation">(</span>s<span class="token punctuation">)</span> to be executed <span class="token keyword">if</span> expression is <span class="token boolean">true</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<code>expression</code> 和方括号([ ])之间必须有空格，否则会有语法错误。</p><p>if 语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种 if … else 语句：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">..</span>. <span class="token keyword">fi</span> 语句<span class="token keyword">if</span> <span class="token punctuation">..</span>. <span class="token keyword">else</span> <span class="token punctuation">..</span>. <span class="token keyword">fi</span> 语句<span class="token keyword">if</span> <span class="token punctuation">..</span>. <span class="token keyword">elif</span> <span class="token punctuation">..</span>. <span class="token keyword">else</span> <span class="token punctuation">..</span>. <span class="token keyword">fi</span> 语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"a is equal to b"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-gt</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token keyword">then</span><span class="token builtin class-name">echo</span> <span class="token string">"a is greater to b"</span><span class="token keyword">else</span><span class="token builtin class-name">echo</span> <span class="token string">"a is less to b"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>if ... else</code> 语句也可以写成一行，以命令的方式来运行:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"a is equal to b"</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token builtin class-name">echo</span> <span class="token string">"a is not equal to b"</span><span class="token punctuation">;</span><span class="token keyword">fi</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>if ... else</code> 语句也经常与 <code>test</code> 命令结合使用，作用与上面一样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$b</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"a is equal to b"</span><span class="token keyword">else</span><span class="token builtin class-name">echo</span> <span class="token string">"a is not equal to b"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分支控制：case语句"><a href="#分支控制：case语句" class="headerlink" title="分支控制：case语句"></a>分支控制：case语句</h2><p><code>case ... esac</code> 与其他语言中的 <code>switch ... case</code> 语句类似，是一种多分枝选择结构。</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">grade</span><span class="token operator">=</span><span class="token string">"B"</span><span class="token keyword">case</span> <span class="token variable">$grade</span> <span class="token keyword">in</span> <span class="token string">"A"</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Very Good!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token string">"B"</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Good!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token string">"C"</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Come On!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>*<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"You Must Try!"</span><span class="token builtin class-name">echo</span> <span class="token string">"Sorry!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换成C语言是：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> grade <span class="token operator">=</span> <span class="token char">'B'</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>grade<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token char">'A'</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Very Good!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'B'</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Very Good!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'C'</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Very Good!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>             <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"You Must Try!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sorry!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对比看就很容易理解了。很相似，只是格式不一样。</p><p>需要注意的是：</p><p><strong>取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 <code>;;</code>。</strong><code>;;</code> 与其他语言中的 <code>break</code> 类似，意思是跳到整个 <code>case</code> 语句的最后。</p><p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 <code>*</code> 捕获该值，再执行后面的命令。</p><p>再举一个例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">option</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${1}</span>"</span><span class="token keyword">case</span> <span class="token variable">${option}</span> <span class="token keyword">in</span>   <span class="token string">"-f"</span><span class="token punctuation">)</span> <span class="token assign-left variable">FILE</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${2}</span>"</span>      <span class="token builtin class-name">echo</span> <span class="token string">"File name is <span class="token variable">$FILE</span>"</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span>   <span class="token string">"-d"</span><span class="token punctuation">)</span> <span class="token assign-left variable">DIR</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${2}</span>"</span>      <span class="token builtin class-name">echo</span> <span class="token string">"Dir name is <span class="token variable">$DIR</span>"</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span>   *<span class="token punctuation">)</span>       <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token variable">`</span></span>:usage: [-f file] | [-d directory]"</span>      <span class="token builtin class-name">exit</span> <span class="token number">1</span> <span class="token comment"># Command to come out of the program with status 1</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$./test.shtest.sh: usage: <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> filename <span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span> <span class="token parameter variable">-d</span> directory <span class="token punctuation">]</span>./test.sh <span class="token parameter variable">-f</span> index.htmlFile name is index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里用到了特殊变量<code>${1}</code>,指的是获取命令行的第一个参数。</p><p>下面结合<code>getopts</code>命令介绍下一个经典的例子：从命令行读取参数。</p><p>run.sh</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token function-name function">usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Usage: <span class="token variable">$0</span> -s [start|stop|reload|restart] -e [online|test]"</span>    <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    usage<span class="token keyword">fi</span><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> <span class="token string">'s:e:h'</span> OPT<span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token keyword">case</span> <span class="token variable">$OPT</span> <span class="token keyword">in</span>        s<span class="token punctuation">)</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OPTARG</span>"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        e<span class="token punctuation">)</span> <span class="token assign-left variable">env</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OPTARG</span>"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        h<span class="token punctuation">)</span> usage<span class="token punctuation">;</span><span class="token punctuation">;</span>        ?<span class="token punctuation">)</span> usage<span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">esac</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token variable">$cmd</span><span class="token builtin class-name">echo</span> <span class="token variable">$env</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们直接运行<code>run.sh</code>的时候，会调用<code>usage</code>显示帮助；如果输入正确的参数，则会进入正确的流程。运行示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> run.sh <span class="token parameter variable">-s</span> start <span class="token parameter variable">-e</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>shell的for循环与c、php等语言不同，同Python很类似。下面是语法格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> 变量 <span class="token keyword">in</span> 列表<span class="token keyword">do</span>    command1    command2    <span class="token punctuation">..</span>.    commandN<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token keyword">for</span> <span class="token for-or-select variable">value</span> <span class="token keyword">in</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token string">"The value is <span class="token variable">$value</span>"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The value is <span class="token number">1</span>The value is <span class="token number">2</span>The value is <span class="token number">3</span>The value is <span class="token number">4</span>The value is <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺序输出字符串中的字符：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">str</span> <span class="token keyword">in</span> <span class="token string">'This is a string'</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$str</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">This is a string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>遍历目录下的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">FILE</span> <span class="token keyword">in</span> *<span class="token keyword">do</span>   <span class="token builtin class-name">echo</span> <span class="token variable">$FILE</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码将遍历当前目录下所有的文件。在Linux下，可以改为其他目录试试。</p><p>遍历文件内容：</p><p>city.txt</p><pre class="line-numbers language-none"><code class="language-none">beijingtianjinshanghai<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">citys</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> city.txt<span class="token variable">`</span></span><span class="token keyword">for</span> <span class="token for-or-select variable">city</span> <span class="token keyword">in</span> <span class="token variable">$citys</span><span class="token keyword">do</span>   <span class="token builtin class-name">echo</span> <span class="token variable">$city</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">beijingtianjinshanghai<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>只要while后面的条件满足，就一直执行do里面的代码块。</p><p>其格式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token builtin class-name">command</span><span class="token keyword">do</span>   Statement<span class="token punctuation">(</span>s<span class="token punctuation">)</span> to be executed <span class="token keyword">if</span> <span class="token builtin class-name">command</span> is <span class="token boolean">true</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$c</span> <span class="token parameter variable">-lt</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token keyword">do</span><span class="token builtin class-name">echo</span> <span class="token string">"Value c is <span class="token variable">$c</span>"</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $c + <span class="token number">1</span><span class="token variable">`</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">Value c is 0Value c is 1Value c is 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里由于shell本身不支持算数运算，所以使用<code>expr</code>命令进行自增。</p><h2 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。</p><p>将上面while循环的例子改改，就能达到一样的效果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">until</span> <span class="token punctuation">[</span> <span class="token variable">$c</span> <span class="token parameter variable">-eq</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token keyword">do</span><span class="token builtin class-name">echo</span> <span class="token string">"Value c is <span class="token variable">$c</span>"</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $c + <span class="token number">1</span><span class="token variable">`</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先do里面的语句块一直在运行，直到满足了until的条件就停止。</p><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">Value c is 0Value c is 1Value c is 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-lt</span> <span class="token number">5</span> <span class="token punctuation">]</span><span class="token keyword">do</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $i + <span class="token number">1</span><span class="token variable">`</span></span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token keyword">then</span><span class="token builtin class-name">break</span><span class="token keyword">fi</span><span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token variable">$i</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">break</span> n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示跳出第 n 层循环。</p><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-lt</span> <span class="token number">5</span> <span class="token punctuation">]</span><span class="token keyword">do</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $i + <span class="token number">1</span><span class="token variable">`</span></span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token keyword">then</span><span class="token builtin class-name">continue</span><span class="token keyword">fi</span><span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token variable">$i</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">1245<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell脚本基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本学习05--函数</title>
      <link href="/blog/26f46cdf.html"/>
      <url>/blog/26f46cdf.html</url>
      
        <content type="html"><![CDATA[<p>函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Shell 函数的定义格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">function_name</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list of commands    <span class="token punctuation">[</span> <span class="token builtin class-name">return</span> value <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>function</code>关键字是可选的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function-name function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token builtin class-name">echo</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用函数只需要给出函数名，不需要加括号。</p><p>函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。</p><p>Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：<code>numeric argument required</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token builtin class-name">return</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">line <span class="token number">4</span>: return: hello: numeric argument required<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token builtin class-name">return</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token assign-left variable">str</span><span class="token operator">=</span>hello<span class="token builtin class-name">echo</span> <span class="token variable">$str</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>像删除变量一样，删除函数也可以使用 <code>unset</code> 命令，不过要加上 <code>.f</code> 选项，如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$unset</span> .f function_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。</p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数…这就是前面讲的特殊变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token variable">$#</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"no param"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token variable">$1</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $1 + $2<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $1 + $2 + $3<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token punctuation">;</span>*<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$#</span> params! It's too much!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token punctuation">}</span><span class="token function">sum</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">4 params! It's too much!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，<code>$10</code> 不能获取第十个参数，获取第十个参数需要<code>${10}</code>。当<code>n&gt;=10</code>时，需要使用<code>${n}</code>来获取参数。</p><p>另外，还有几个特殊变量用来处理参数，前面已经提到：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">特殊变量说明<span class="token variable">$#</span>传递给函数的参数个数。<span class="token variable">$*</span>显示所有传递给函数的参数。<span class="token variable">$@</span>与<span class="token variable">$*</span>相同，但是略有区别，请查看Shell特殊变量。<span class="token variable">$?</span>函数的返回值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何获取函数返回值"><a href="#如何获取函数返回值" class="headerlink" title="如何获取函数返回值"></a>如何获取函数返回值</h2><p>后面的变量需要使用函数的返回值，怎么实现？</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> <span class="token number">1</span>+2+3<span class="token variable">`</span></span><span class="token punctuation">}</span><span class="token assign-left variable">num</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">sum</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以取到返回值了。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell脚本基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本学习06--其它</title>
      <link href="/blog/339cb40c.html"/>
      <url>/blog/339cb40c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Shell输入输出重定向"><a href="#Shell输入输出重定向" class="headerlink" title="Shell输入输出重定向"></a>Shell输入输出重定向</h2><p>Unix 命令默认从标准输入设备(stdin)获取输入，将结果输出到标准输出设备(stdout)显示。一般情况下，标准输入设备就是键盘，标准输出设备就是终端，即显示器。</p><p>输出重定向</p><p>命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。</p><p>命令输出重定向的语法为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，输出到显示器的内容就可以被重定向到文件。</p><p>例如，下面的命令在显示器上不会看到任何输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">who</span> <span class="token operator">&gt;</span> <span class="token function">users</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 users 文件，可以看到下面的内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token function">users</span>oko         tty01   Sep <span class="token number">12</span> 07:30ai          tty15   Sep <span class="token number">12</span> <span class="token number">13</span>:32ruth        tty21   Sep <span class="token number">12</span> <span class="token number">10</span>:10pat         tty24   Sep <span class="token number">12</span> <span class="token number">13</span>:07steve       tty25   Sep <span class="token number">12</span> <span class="token number">13</span>:03<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出重定向会覆盖文件内容，请看下面的例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> line <span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token function">users</span><span class="token function">cat</span> <span class="token function">users</span>line <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果不希望文件内容被覆盖，可以使用 <code>&gt;&gt;</code> 追加到文件末尾，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> line <span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token function">users</span><span class="token function">cat</span> <span class="token function">users</span>line <span class="token number">1</span>line <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入重定向</p><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&lt;</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p><p>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</p><p>例如，计算 users 文件中的行数，可以使用下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token function">users</span><span class="token number">2</span> <span class="token function">users</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以将输入重定向到 users 文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token operator">&lt;</span> <span class="token function">users</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p><h2 id="重定向深入讲解"><a href="#重定向深入讲解" class="headerlink" title="重定向深入讲解"></a>重定向深入讲解</h2><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li><strong>标准输入文件(stdin)</strong>: stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li><strong>标准输出文件(stdout)</strong>: stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li><strong>标准错误文件(stderr)</strong>: stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>默认情况下，<code>command &gt; file</code> 将 stdout 重定向到 file，<code>command &lt; file</code> 将stdin 重定向到 file。</p><p>如果希望 stderr 重定向到 file，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2 表示标准错误文件(stderr)。</p><p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> <span class="token function">file</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&lt;</span> file1 <span class="token operator">&gt;</span>file2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p><p><strong>全部可用的重定向命令列表：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">命令说明<span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> <span class="token function">file</span>将输出重定向到 file。<span class="token builtin class-name">command</span> <span class="token operator">&lt;</span> <span class="token function">file</span>将输入重定向到 file。<span class="token builtin class-name">command</span> <span class="token operator">&gt;&gt;</span> <span class="token function">file</span>将输出以追加的方式重定向到 file。n <span class="token operator">&gt;</span> <span class="token function">file</span>将文件描述符为 n 的文件重定向到 file。n <span class="token operator">&gt;&gt;</span> <span class="token function">file</span>将文件描述符为 n 的文件以追加的方式重定向到 file。n <span class="token operator">&gt;&amp;</span> m将输出文件 m 和 n 合并。n <span class="token operator">&lt;&amp;</span> m将输入文件 m 和 n 合并。<span class="token operator">&lt;&lt;</span> tag将开始标记 tag 和结束标记 tag 之间的内容作为输入。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h2><p>Here Document 目前没有统一的翻译，这里暂译为<code>嵌入文档</code>。Here Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&lt;&lt;</span> <span class="token string">delimiter    documentdelimiter</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p><p>注意：</p><p><strong>结尾的delimiter 一定要顶格写</strong>，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</p><p>开始的delimiter前后的空格会被忽略掉。</p><p>下面的例子，通过 <code>wc -l</code> 命令计算 document 的行数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF    This is a simple lookup program    for good (and bad) restaurants    in Cape Town.EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出： 3</p><p>也可以 将 Here Document 用在脚本中，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOFThis is a simple lookup programfor good (and bad) restaurantsin Cape Town.EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">This is a simple lookup programfor good (and bad) restaurantsin Cape Town.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="x2F-dev-x2F-null-文件"><a href="#x2F-dev-x2F-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h2><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 <code>/dev/null</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>/dev/null</code> 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 <code>/dev/null</code> 文件非常有用，将命令的输出重定向到它，会起到<code>禁止输出</code>的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样不会在屏幕打印任何信息。</p><h2 id="Shell文件包含"><a href="#Shell文件包含" class="headerlink" title="Shell文件包含"></a>Shell文件包含</h2><p>像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。</p><p>Shell 中包含脚本可以使用 <code>. filename</code> 或 <code>source filename</code> 。</p><p>两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。</p><p>示例：</p><p>被包含文件：sub.sh</p><pre class="line-numbers language-none"><code class="language-none">name="yjc"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主文件：test.sh</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">.</span> ./sub.sh<span class="token builtin class-name">echo</span> <span class="token variable">$name</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">yjc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="获取当前正在执行脚本的绝对路径"><a href="#获取当前正在执行脚本的绝对路径" class="headerlink" title="获取当前正在执行脚本的绝对路径"></a>获取当前正在执行脚本的绝对路径</h2><p>正确的命令是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">basepath</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">cd</span> `dirname $0`<span class="token punctuation">;</span> <span class="token builtin class-name">pwd</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接使用<code>pwd</code>或者<code>dirname $0</code>是不对的。</p><h2 id="按特定字符串截取字符串"><a href="#按特定字符串截取字符串" class="headerlink" title="按特定字符串截取字符串"></a>按特定字符串截取字符串</h2><p>示例：截取<code>/www/html/php/myapp/</code>里的myapp。</p><p>方案：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span>/www/html/php/myapp/<span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $str<span class="token operator">|</span><span class="token function">sed</span> <span class="token string">'s#/# #g'</span><span class="token variable">)</span></span><span class="token punctuation">)</span><span class="token assign-left variable">b_len</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $<span class="token punctuation">{</span>#b<span class="token punctuation">[</span>*<span class="token punctuation">]</span><span class="token punctuation">}</span> - <span class="token number">1</span><span class="token variable">`</span></span><span class="token assign-left variable">app_name</span><span class="token operator">=</span><span class="token variable">${b<span class="token punctuation">[</span>$b_len<span class="token punctuation">]</span>}</span><span class="token builtin class-name">echo</span> <span class="token variable">$app_name</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里利用<code>sed</code>将字符串按指定字符截成数组，然后取最后一个。</p><p>计算数组长度: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">${<span class="token operator">#</span>arr<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>计算则需要使用<code>expr</code>命令</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h3 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h3><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件(或其他方式的输入流, 如重定向输入)逐行的读入（看作一个记录集）, 把每一行看作一条记录，以空格(或\t,或用户自己指定的分隔符)为默认分隔符将每行切片（类似字段），切开的部分再进行各种分析处理。</p><p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p><p>Awk基本语法:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token string">'pattern1 {command1;command 2…; command 3}  pattern2 { command …}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pattern表示用来过滤记录的模式,可是是正则表达式，关系运算表达式，也可以什么也没有(表示选中所有记录)。</p><p>每个pattern选中的行记录会被花括号括起来的命令command操作一遍, command之间用<code>;</code>分割。 花括号里面可以什么也没有, 则默认为print输出整行记录。 Comamnd可以是输出， 可以是算术运算，逻辑运算，循环控制等等。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>s.txt</p><pre class="line-numbers language-none"><code class="language-none">zhangsan 1977 male computer 83lisi 1989 male math 99wanglijiang 1990 female chinese 78xuliang 1977 male economic 89xuxin 1986 female english 99wangxuebing 1978 male math 89lichang 1989 male math 99wanglijiang 1990 female chinese 78zhangsansan 1977 male computer 83 langxuebing 1978 male math 89lisibao 1989 male math 99xiaobao 1990 female chinese 78<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一行中的5个字段分别表示<code>姓名, 出生年, 性别,科目,分数</code>, 是一个很传统很典型的报表文件。</p><p>现在演示awk是如何查找的：</p><p>1)直接输出1990年出生的同学:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'/1990/'</span> s.txtwanglijiang <span class="token number">1990</span> female chinese <span class="token number">78</span>wanglijiang <span class="token number">1990</span> female chinese <span class="token number">78</span>xiaobao <span class="token number">1990</span> female chinese <span class="token number">78</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-none"><code class="language-none">$ awk '/1990/{print $0}' s.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>awk默认把输入的内容以空格拆分出每列。<code>$0</code>表示匹配所有列，<code>print $0</code>将输出所有列，每列分隔符是空格。</p><p>2）对chinese的课程的行输出”语文”：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'/chinese/{print "语文"}'</span> s.txt语文语文语文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）记录的头部和结尾加上一段说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'BEGIN{print "Result of the quiz:\n"}{print $0}END{print "------"}'</span> s.txtResult of the quiz:zhangsan <span class="token number">1977</span> male computer <span class="token number">83</span>lisi <span class="token number">1989</span> male math <span class="token number">99</span>wanglijiang <span class="token number">1990</span> female chinese <span class="token number">78</span>xuliang <span class="token number">1977</span> male economic <span class="token number">89</span>xuxin <span class="token number">1986</span> female english <span class="token number">99</span>wangxuebing <span class="token number">1978</span> male math <span class="token number">89</span>lichang <span class="token number">1989</span> male math <span class="token number">99</span>wanglijiang <span class="token number">1990</span> female chinese <span class="token number">78</span>zhangsansan <span class="token number">1977</span> male computer <span class="token number">83</span>langxuebing <span class="token number">1978</span> male math <span class="token number">89</span>lisibao <span class="token number">1989</span> male math <span class="token number">99</span>xiaobao <span class="token number">1990</span> female chinese <span class="token number">78</span>------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AWK工作流程：<strong>逐行扫描文件，从第一行到最后一行，寻找匹配特定模式的行，并在这些行上进行用户想要到的操作</strong>。</p><p>BEGIN只会在最开始执行；END只会在扫描所有行数之后执行。BEGIN和END之间的花括号的内容每扫描一行都会执行。</p><p>4)查找女生的成绩且只输出姓名、学科、成绩：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'$3=="female"{print $1,$4,$5}'</span> s.txtwanglijiang chinese <span class="token number">78</span>xuxin english <span class="token number">99</span>wanglijiang chinese <span class="token number">78</span>xiaobao chinese <span class="token number">78</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>$1</code>表示第1列，<code>$n</code>类推。这里条件是表达式，而不是正则。print里<code>,</code>表示空格分隔符。</p><p>5)找出1990年出生的学生姓名，并要求匹配正则:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'$2~/1990/{print $1}'</span> s.txtwanglijiangwanglijiangxiaobao<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里<code>~</code>表示匹配正则表达式。<code>!~</code>表示不匹配正则表达式。</p><p>如果需要多选，则改成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'$2~/(1990|1991)/{print $1}'</span> s.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>awk更多内容详见：<a href="https://www.cnblogs.com/52fhy/p/5836429.html#autoid-3-4-0">https://www.cnblogs.com/52fhy/p/5836429.html#autoid-3-4-0</a></p><p>（完结）</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell脚本基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog/0.html"/>
      <url>/blog/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="LTP-构建系统简介"><a href="#LTP-构建系统简介" class="headerlink" title="LTP 构建系统简介"></a>LTP 构建系统简介</h1><p>以下文档简要描述了用于新的和改进的 Makefile 系统的步骤和方法。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>旧的 Makefile 系统的问题是它很难维护并且缺乏正式的结构感，因此为 LTP 开发和包含新目标比它应该的（维护）更困难。此外，正确的基于选项的交叉编译是不可能的，因为 Makefile 不支持前缀系统，并且没有配置适当的隐式/静态规则来编译到树外的多个对象目录中建立支持（易用性/功能）。最后，没有办法设置组件之间的依赖关系，这样如果一个组件需要 libltp.a 才能编译，它会关闭并首先编译 libltp.a（易用性）。</p><p>这些项目需要修复，以减少为 LTP 做出贡献的开发社区和项目维护人员的维护噩梦。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>该系统的设计使得在每个新目录组件中包含一个 GNU Makefile 兼容集是构建系统所必需的。</p><p>假设您有一个如下所示的目录（其中包含直接绑定到应用程序的 .c 文件，例如 baz.c -&gt; baz）：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token operator">...</span><span class="token operator">/</span>foo<span class="token operator">/</span>     <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">&gt;</span> Makefile     <span class="token operator">|</span>      <span class="token operator">--</span><span class="token operator">&gt;</span> bar<span class="token operator">/</span>       <span class="token operator">|</span>        <span class="token operator">--</span><span class="token operator">&gt;</span> Makefile           <span class="token operator">|</span>            <span class="token operator">--</span><span class="token operator">&gt;</span> baz<span class="token punctuation">.</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个如何实现这一目标的示例：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">.../foo/Makefile</span><span class="token punctuation">:</span><span class="token comment">#</span><span class="token comment"># Copyright disclaimer goes here -- please use GPLv2.</span><span class="token comment">#</span>top_srcdir          <span class="token operator">?=</span> ..<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>top_srcdir<span class="token punctuation">)</span>/<span class="token keyword">include</span>/mk/env_pre.mk<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>top_srcdir<span class="token punctuation">)</span>/<span class="token keyword">include</span>/mk/generic_trunk_target.mk<span class="token target symbol">.../foo/bar/Makefile</span><span class="token punctuation">:</span><span class="token comment">#</span><span class="token comment"># Copyright disclaimer goes here -- please use GPLv2.</span><span class="token comment">#</span>top_srcdir          <span class="token operator">?=</span> ../..<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>top_srcdir<span class="token punctuation">)</span>/<span class="token keyword">include</span>/mk/env_pre.mk<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>top_srcdir<span class="token punctuation">)</span>/<span class="token keyword">include</span>/mk/generic_leaf_target.mk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="制定规则并制定变量"><a href="#制定规则并制定变量" class="headerlink" title="制定规则并制定变量"></a>制定规则并制定变量</h2><p>使用 make 规则时，避免编写如下临时规则：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">[prog]</span><span class="token punctuation">:</span> [dependencies]    cc -I../../<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDLIBS<span class="token punctuation">)</span> \        -o [prog] [dependencies]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等等。这使得交叉编译和确定性变得困难，如果不是不可能的话。此外，隐式规则是你的朋友，只要你使用<code>MAKEOPTS=;</code>。在顶级调用者中(or do (substr,(MAKEOPTS)) to remove -r)，编译将成功完成，假设已满足所有其他先决条件（库、标头等）。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol"><span class="token variable">$</span>(AR)</span>                       <span class="token punctuation">:</span> The library archiver.<span class="token target symbol"><span class="token variable">$</span>(CC)</span>                       <span class="token punctuation">:</span> The system C compiler.<span class="token target symbol"><span class="token variable">$</span>(CXX)</span>                      <span class="token punctuation">:</span> The system C++ compiler.<span class="token target symbol"><span class="token variable">$</span>(CPP)</span>                      <span class="token punctuation">:</span> The system C preprocessor.<span class="token target symbol"><span class="token variable">$</span>(CFLAGS)</span>           <span class="token punctuation">:</span> C compiler flags.<span class="token target symbol"><span class="token variable">$</span>(CPPFLAGS)</span>         <span class="token punctuation">:</span> Preprocessor flags, e.g. -I arguments.<span class="token target symbol"><span class="token variable">$</span>(CXXFLAGS)</span>         <span class="token punctuation">:</span> C++ compiler flags, e.g. -I arguments.<span class="token target symbol"><span class="token variable">$</span>(DEBUG_CFLAGS)</span>             <span class="token punctuation">:</span> Debug flags to pass to <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, -g, etc.<span class="token target symbol"><span class="token variable">$</span>(DEBUG_CXXFLAGS)</span>   <span class="token punctuation">:</span> Debug flags to pass to <span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span>.<span class="token target symbol"><span class="token variable">$</span>(LD)</span>                       <span class="token punctuation">:</span> The system linker <span class="token punctuation">(</span>typically <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, but not                          necessarily<span class="token punctuation">)</span>.<span class="token target symbol"><span class="token variable">$</span>(LDFLAGS)</span>          <span class="token punctuation">:</span> What to pass in to the linker, including -L arguments                          and other ld arguments, apart from -l library                          includes <span class="token punctuation">(</span>see <span class="token variable">$</span><span class="token punctuation">(</span>LDLIBS<span class="token punctuation">)</span><span class="token punctuation">)</span>.                          This should be done in the <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> args passing style                          when LD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, e.g. `-Wl,-foo', as opposed to                          `-foo'.<span class="token target symbol"><span class="token variable">$</span>(LDLIBS)</span>           <span class="token punctuation">:</span> Libraries to pass to the linker <span class="token punctuation">(</span>e.g. -lltp, etc<span class="token punctuation">)</span>.<span class="token target symbol"><span class="token variable">$</span>(OPT_CFLAGS)</span>               <span class="token punctuation">:</span> Optimization flags to pass into the C compiler, -O2,                          etc. If you specify -O2 or higher, you should also                          specify -fno-strict-aliasing, because of gcc                          fstrict-aliasing optimization bugs in the tree                          optimizer. Search for `fstrict-aliasing optimization                          bug' with your favorite search engine.<span class="token target symbol">                          Examples of more recent bugs</span><span class="token punctuation">:</span>                          1. tree-optimization/17510                          2. tree-optimization/39100                          Various bugs have occurred in the past due to buggy                          logic in the tree-optimization portion of the gcc                          compiler, from 3.3.x to 4.4.<span class="token target symbol"><span class="token variable">$</span>(OPT_CXXFLAGS)</span>             <span class="token punctuation">:</span> Optimization flags to pass to the C++ compiler.<span class="token target symbol"><span class="token variable">$</span>(RANLIB)</span>           <span class="token punctuation">:</span> What to run after archiving a library.<span class="token target symbol"><span class="token variable">$</span>(WCFLAGS)</span>          <span class="token punctuation">:</span> Warning flags to pass to <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, e.g. -Werror,                          -Wall, etc.<span class="token target symbol"><span class="token variable">$</span>(WCXXFLAGS)</span>                <span class="token punctuation">:</span> Same as <span class="token variable">$</span><span class="token punctuation">(</span>WCFLAGS<span class="token punctuation">)</span>, but for <span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span>AR<span class="token punctuation">)</span> ：库归档器。<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> ：系统 C 编译器。<span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> ：系统 C++ 编译器。<span class="token variable">$</span><span class="token punctuation">(</span>CPP<span class="token punctuation">)</span> ：系统 C 预处理器。<span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> ：C 编译器标志。<span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> ：预处理器标志，例如 -I 参数。<span class="token variable">$</span><span class="token punctuation">(</span>CXXFLAGS<span class="token punctuation">)</span> ：C++ 编译器标志，例如 -I 参数。<span class="token variable">$</span><span class="token punctuation">(</span>DEBUG_CFLAGS<span class="token punctuation">)</span> ：要传递给 <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>、-g 等的调试标志。<span class="token variable">$</span><span class="token punctuation">(</span>DEBUG_CXXFLAGS<span class="token punctuation">)</span> ：要传递给 <span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> 的调试标志。<span class="token variable">$</span><span class="token punctuation">(</span>LD<span class="token punctuation">)</span> ：系统链接器（通常是 <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>，但不是                          一定）。<span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> ：传递给链接器的内容，包括 -L 参数                          和其他 ld 参数，除了 -l 库                          包括（参见 <span class="token variable">$</span><span class="token punctuation">(</span>LDLIBS<span class="token punctuation">)</span>）。                          这应该在 <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> args 传递样式中完成                          当 LD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> 时，例如 `-Wl,-foo'，相对于                          `-foo'。<span class="token variable">$</span><span class="token punctuation">(</span>LDLIBS<span class="token punctuation">)</span> ：要传递给链接器的库（例如 -lltp 等）。<span class="token variable">$</span><span class="token punctuation">(</span>OPT_CFLAGS<span class="token punctuation">)</span> ：传递给 C 编译器的优化标志，-O2，                          等等 如果你指定 -O2 或更高，你也应该                          指定 -fno-strict-aliasing，因为 gcc                          树中的 fstrict 别名优化错误                          优化器。搜索`fstrict-别名优化                          错误'与您最喜欢的搜索引擎。                          最近的错误示例：                          1.树优化/17510                          2.树优化/39100                          由于buggy，过去出现过各种bug                          gcc 树优化部分的逻辑                          编译器，从 3.3.x 到 4.4。<span class="token variable">$</span><span class="token punctuation">(</span>OPT_CXXFLAGS<span class="token punctuation">)</span> ：传递给 C++ 编译器的优化标志。<span class="token variable">$</span><span class="token punctuation">(</span>RANLIB<span class="token punctuation">)</span> ：归档库后要运行的内容。<span class="token variable">$</span><span class="token punctuation">(</span>WCFLAGS<span class="token punctuation">)</span> ：传递给 <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> 的警告标志，例如 -Werror，                          - 墙等<span class="token variable">$</span><span class="token punctuation">(</span>WCXXFLAGS<span class="token punctuation">)</span> ：与 <span class="token variable">$</span><span class="token punctuation">(</span>WCFLAGS<span class="token punctuation">)</span> 相同，但用于 <span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span>。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="制作系统变量"><a href="#制作系统变量" class="headerlink" title="制作系统变量"></a>制作系统变量</h2><p>make 系统中使用了一系列变量来指示需要采取的操作。而不是我在这里列出变量，请使用它们的预期用途，请参阅 <code>../include/mk/env_pre.mk</code> 中包含的注释。</p><h2 id="指南和建议"><a href="#指南和建议" class="headerlink" title="指南和建议"></a>指南和建议</h2><p>当然，GNU Make 手册是理解 Make 系统的关键，但我建议查看以下部分和章节：</p><ul><li><a href="http://www.gnu.org/software/make/manual/make.html#Implicit-Rules">隐式规则</a></li><li><a href="http://www.gnu.org/software/make/manual/make.html#Using-Variables">变量和扩展</a></li><li><a href="http://www.gnu.org/software/make/manual/make.html#Origin-Function">原点函数使用</a></li><li><a href="http://www.gnu.org/software/make/manual/make.html#Directory-Search">VPath 用法</a></li></ul><h2 id="提交之前"><a href="#提交之前" class="headerlink" title="提交之前"></a>提交之前</h2><p>在提交之前应该从头开始重建。有关更多详细信息，请参阅<a href="https://github.com/linux-test-project/ltp/blob/master/INSTALL">安装。</a></p><h2 id="其他勘误表"><a href="#其他勘误表" class="headerlink" title="其他勘误表"></a>其他勘误表</h2><p>请参阅 TODO 以了解与 Makefile 基础结构相关的任何问题，以及一般的构建结构/源代码树。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog/0.html"/>
      <url>/blog/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="LTP-C-测试-API"><a href="#LTP-C-测试-API" class="headerlink" title="LTP C 测试 API"></a>LTP C 测试 API</h1><p>笔记  另请参阅 <a href="https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines">测试编写指南</a>、 <a href="https://github.com/linux-test-project/ltp/wiki/C-Test-Case-Tutorial">C测试用例教程</a>、 <a href="https://github.com/linux-test-project/ltp/wiki/Shell-Test-API">Shell测试API</a>。</p><table><thead><tr><th>笔记</th><th>另请参阅 <a href="https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines">测试编写指南</a>、 <a href="https://github.com/linux-test-project/ltp/wiki/C-Test-Case-Tutorial">C测试用例教程</a>、 <a href="https://github.com/linux-test-project/ltp/wiki/Shell-Test-API">Shell测试API</a>。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="1-用-C-编写测试"><a href="#1-用-C-编写测试" class="headerlink" title="1 用 C 编写测试"></a>1 用 C 编写测试</h2><h3 id="1-1-基本测试结构"><a href="#1-1-基本测试结构" class="headerlink" title="1.1 基本测试结构"></a>1.1 基本测试结构</h3><p>_让我们从一个例子开始，下面的代码是对getenv()_的简单测试。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*\ * [Description] * Tests basic functionality of getenv(). * *  - create an env variable and verify that getenv() can get get it *  - call getenv() with nonexisting variable name, check that it returns NULL */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENV1</span> <span class="token string">"LTP_TEST_ENV"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENV2</span> <span class="token string">"LTP_TEST_THIS_DOES_NOT_EXIST"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENV_VAL</span> <span class="token string">"val"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setenv</span><span class="token punctuation">(</span>ENV1<span class="token punctuation">,</span> ENV_VAL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TBROK <span class="token operator">|</span> TERRNO<span class="token punctuation">,</span> <span class="token string">"setenv() failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span>ret <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span>ENV1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV1 <span class="token string">") = NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">goto</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> ENV_VAL<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV1 <span class="token string">") = '"</span>ENV_VAL <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV1 <span class="token string">") = '%s', expected '"</span>               ENV_VAL <span class="token string">"'"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>next<span class="token operator">:</span>ret <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span>ENV2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV2 <span class="token string">") = '%s'"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV2 <span class="token string">") = NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> test<span class="token punctuation">,</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个测试都包含_tst_test.h_标头并且必须定义_struct tst_test test_结构。</p><p>整体测试初始化是在_setup()_函数中完成的。</p><p>整体清理是在_cleanup()_函数中完成的。这里省略了_cleanup()_，因为测试没有任何要清理的东西。如果在测试结构中设置了清理，则会在测试库清理之前的测试退出时调用它。这尤其意味着可以在测试执行中的任何时候调用清理。例如，即使测试设置步骤失败，_cleanup()_函数也必须能够处理未完成的初始化，等等。</p><p>测试本身是在_test()_函数中完成的。如果在循环中调用，测试函数必须正常工作。</p><p>测试结构中有两种类型的测试函数指针。第一个是_.test_all_指针，当测试作为单个函数实现时使用。然后是一个_.test_函数以及允许更详细的结果报告的测试数量_.tcnt 。<em>如果设置了</em>.test_ 指针，则函数将调用_.tcnt次，并使用 [0,_ <em>.tcnt</em> - 1]范围内的整数参数。</p><blockquote><p>重要的 :  一次只能设置 <em>.test_和</em>.test_all_ 之一。</p></blockquote><p>每个测试都有一个运行时长的限制，这个限制由 max_runtime 和 timeout 两部分组成。max_runtime 是 <em>.test_all_或一组</em>.test_函数可以花费多长时间的限制，超时是静态部分，应该涵盖测试设置和清理的持续时间以及一些安全性。</p><p>任何运行超过一两秒的测试都必须确保：</p><ul><li><p>通过在 tst_test 中设置 .max_runtime_或_在测试设置中调用_tst_set_max_runtime()来设置运行时间_</p></li><li><p>通过定期调用_tst_remaining_runtime()_监控剩余运行时间，并在运行时间用完时退出</p></li></ul><p>测试可以在 max_runtime 用完之前自由退出，例如当完成最少的迭代次数时。</p><p>该限制适用于_.test_all_函数的单次调用，这意味着例如当设置_.test_variants_或_.all_filesystems时，整个测试将受到__variants * (max_runtime + timeout)<em>秒的限制，并且测试运行时间可能接近于</em><em>variants * max_runtime</em>_秒。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * Returns number of seconds or zero in case that runtime has been used up. */</span><span class="token keyword">int</span> <span class="token function">tst_remaining_runtime</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="关于-cleanup-回调的一句话"><a href="#关于-cleanup-回调的一句话" class="headerlink" title="关于 cleanup() 回调的一句话"></a>关于 cleanup() 回调的一句话</h5><p>为了编写正确的 cleanup() 回调，需要遵循一些规则。</p><ol><li><p>仅释放已初始化的资源。请记住，回调可以在测试运行的任何时候执行。</p></li><li><p>确保以与初始化相反的顺序释放资源。（有些步骤可能不依赖于其他步骤，如果交换了一切都会正常工作，但让我们保持秩序。）</p></li></ol><p>第一条规则乍一看似乎很复杂，但相反，它非常简单。您所要做的就是跟踪已经初始化的内容。例如，文件描述符只有在分配了有效的文件描述符时才需要关闭。对于大多数事情，您需要创建额外的标志，该标志在成功初始化后立即设置。例如，考虑下面的测试设置。</p><p>我们还更喜欢清理本应在程序退出时释放的资源。做出这个决定有两个主要原因。在测试库为测试临时目录安装文件系统的情况下，文件描述符和映射内存等资源可能会阻止卸载块设备。不释放分配的内存会扰乱静态分析和 valgrind 等工具，并在检查 libc 和其他低级库中的泄漏时产生误报。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> fd0<span class="token punctuation">,</span> fd1<span class="token punctuation">,</span> mount_flag<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MNTPOINT</span> <span class="token string">"mntpoint"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FILE1</span> <span class="token string">"mntpoint/file1"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FILE2</span> <span class="token string">"mntpoint/file2"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">SAFE_MKDIR</span><span class="token punctuation">(</span>MNTPOINT<span class="token punctuation">,</span> <span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_MKFS</span><span class="token punctuation">(</span>tst_device<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> tst_device<span class="token operator">-&gt;</span>fs_type<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_MOUNT</span><span class="token punctuation">(</span>tst_device<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> MNTPOINT<span class="token punctuation">,</span> tst_device<span class="token operator">-&gt;</span>fs_type<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mount_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>fd0 <span class="token operator">=</span> <span class="token function">SAFE_OPEN</span><span class="token punctuation">(</span>cleanup<span class="token punctuation">,</span> FILE1<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fd1 <span class="token operator">=</span> <span class="token function">SAFE_OPEN</span><span class="token punctuation">(</span>cleanup<span class="token punctuation">,</span> FILE2<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，可以在任何_SAFE_*_ 宏失败时调用_cleanup()函数，因此也必须能够处理未完成的初始化。_由于全局变量被初始化为零，我们可以在尝试关闭它之前检查 fd &gt; 0。挂载函数需要在设备成功挂载后设置额外的标志。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd1 <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>fd1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd0 <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>fd0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mount_flag <span class="token operator">&amp;&amp;</span> <span class="token function">tst_umouont</span><span class="token punctuation">(</span>MNTPOINT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TWARN <span class="token operator">|</span> TERRNO<span class="token punctuation">,</span> <span class="token string">"umount(%s)"</span><span class="token punctuation">,</span> MNTPOINT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>重要的 : 清理中使用的_SAFE_MACROS()_<strong>不会</strong>退出测试。失败只会产生警告，而_cleanup()_会继续。这是有意为之的，因为我们希望尽可能 多地执行_cleanup() 。</p></blockquote><blockquote><p>警告 : 在测试cleanup(_ ) 中调用 tst_brk( )也不会退出测试，并且_TBROK_会转换为_TWARN_。 </p></blockquote><blockquote><p>笔记 : 测试临时目录的创建和删除在测试库中处理，目录以递归方式删除。因此我们不必在测试清理中删除文件和目录。</p></blockquote><h3 id="1-2-基本测试interface"><a href="#1-2-基本测试interface" class="headerlink" title="1.2 基本测试interface"></a>1.2 基本测试interface</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tst_res</span><span class="token punctuation">(</span><span class="token keyword">int</span> ttype<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg_fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似 printf 的函数来报告测试结果，它主要与 ttype 一起使用：</p><table><thead><tr><th><em>TPASS</em></th><th>测试已经通过。</th></tr></thead><tbody><tr><td><em>TFAIL</em></td><td>测试失败。</td></tr><tr><td><em>信息</em></td><td>一般消息。</td></tr><tr><td><em>警告</em></td><td>出了点问题，但我们决定继续。主要用于清理功能。</td></tr></tbody></table><p>ttype可以与_TERRNO_或_TTERRNO按位组合以分别打印 errno和TST_ERR 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tst_brk</span><span class="token punctuation">(</span><span class="token keyword">int</span> ttype<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg_fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类printf函数报错退出测试，可与ttype一起使用：</p><table><thead><tr><th><em>TBROK</em></th><th>测试准备阶段出现故障。</th></tr></thead><tbody><tr><td><em>TCONF</em></td><td>测试不适合当之前配置（系统调整未实现，架构不接受支持，……）</td></tr></tbody></table><p>ttype可以与_TERRNO_或_TTERRNO按__位_组合以分别打印 _errno__和_TST_ERR 。</p><p>还有_TST_EXP_*()_宏可以将系统调用单元测试简化为一行，尽可能使用它们。这些宏将函数调用作为第一个参数以及类似 printf 的格式字符串和参数。这些测试宏然后扩展为运行调用、检查返回值和错误号并报告测试结果的代码。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TST_EXP_PASS</span><span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>statbuf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"stat(%s, ...)"</span><span class="token punctuation">,</span> fname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>TST_PASS<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_EXP_PASS _()_可用于失败时返回 -1 和成功时返回 0 的调用。它将检查返回值并在返回值不等于 0 时报告失败。如果调用成功，该调用还将 TST_PASS 变量设置_为_1。</p><p>如上所示，这个和类似的宏采用可选的可变参数。这些以格式字符串开头，然后是要格式化的适当值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TST_EXP_FD</span><span class="token punctuation">(</span><span class="token function">open</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"open(%s, O_RDONLY)"</span><span class="token punctuation">,</span> fname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>TST_RET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_EXP_FD _()与__TST_EXP_PASS()_相同，唯一的区别是返回值应为文件描述符，因此如果返回正整数则调用通过。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TST_EXP_FAIL</span><span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>statbuf<span class="token punctuation">)</span><span class="token punctuation">,</span> ENOENT<span class="token punctuation">,</span> <span class="token string">"stat(%s, ...)"</span><span class="token punctuation">,</span> fname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_EXP_FAIL _()与TST_EXP_PASS()_类似，但如果调用未因 -1 失败且_errno_未设置为作为第二个参数传递的预期值，则测试失败。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TST_EXP_FAIL2</span><span class="token punctuation">(</span><span class="token function">msgget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">,</span> EINVAL<span class="token punctuation">,</span> <span class="token string">"msgget(%i, %i)"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_EXP_FAIL2 _()与__TST_EXP_FAIL()_相同，只是如果调用通过，返回值预计为非负整数。这些宏建立在 <code>TEST()</code>宏和相关变量之上。</p><p>_TST_EXP_FAIL_SILENT()_和_TST_EXP_FAIL2_SILENT()_变体不那么冗长，并且当 SCALL 按预期失败时不打印 TPASS 消息。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TEST</span><span class="token punctuation">(</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>TST_RET <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"Created raw socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>TST_RET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>TST_ERR <span class="token operator">!=</span> EPERM<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span><span class="token string">"Failed to create socket for wrong reason"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span> <span class="token string">"Didn't create raw socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>宏<code>TEST</code>设置<code>TST_RET</code>为其参数的返回值<code>TST_ERR</code>和 <code>errno</code>. 该<code>TTERNO</code>标志可用于打印错误号的符号值。</p><p>_除了tst_test_macros.h_中的那些，没有 LTP 库函数或宏会写入这些变量（规则_LTP-002_）。所以它们的值不会意外改变。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TST_EXP_POSITIVE</span><span class="token punctuation">(</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>TST_PASS<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>_如果wait_的返回值为正数或零，则此宏将打印通过结果并进行<code>TST_PASS</code>适当设置。如果返回值为负数，则打印失败。有许多与此处显示的宏类似的宏，请参阅_tst_test_macros.h_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TST_EXP_EQ_LI</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TST_EXP_EQ_UI</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TST_EXP_EQ_SZ</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TST_EXP_EQ_SSZ</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Use as */</span><span class="token function">TST_EXP_EQ_LI</span><span class="token punctuation">(</span>sig_caught<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用于不同整数类型比较的一组宏。这些宏在通过和失败场景中打印变量名称和值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">tst_strsig</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回给定信号编号的对应字符串。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">tst_strerrno</span><span class="token punctuation">(</span><span class="token keyword">int</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回给定错误号对应的字符串。首选使用此函数将_errno_值转换为字符串。您不应 在测试用例中使用_strerror()函数。_</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">tst_strstatus</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>_返回描述wait()_返回状态的字符串。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tst_set_max_runtime</span><span class="token punctuation">(</span><span class="token keyword">int</span> max_runtime<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>允许在测试设置（）中动态设置每个测试迭代的 max_runtime，超时以秒为单位指定。有一些测试用例的运行时间可以任意变化，这些可以通过将其设置为 TST_UNLIMITED_RUNTIME 来禁用超时。</p><p>刷新输出流，适当地处理错误。</p><p>_当您必须在调用fork()_或_clone()_之前刷新输出流时，很少需要此函数。请注意，_SAFE_FORK()<em>和_SAFE_CLONE()</em> 会自动调用此函数。请参阅 2.4 FILE 缓冲区和 fork() 以了解为什么需要这样做。</p><h3 id="1-3-测试临时目录"><a href="#1-3-测试临时目录" class="headerlink" title="1.3 测试临时目录"></a>1.3 测试临时目录</h3><p>如果_.needs_tmpdir_在_struct tst_test_中设置为_1_，则会创建唯一的测试临时文件并将其设置为测试工作目录。测试<strong>不得</strong>在该目录之外创建临时文件。使用这些标志时不需要设置标志：_.all_filesystems_、_.format_device_、_.mntpoint_、 <em>.mount_device</em> <em>.needs_checkpoints_、</em>.needs_device_、_.resource_file_ （这些标志意味着创建临时目录）。</p><blockquote><p>重要的 : _在test()<em>函数或测试_cleanup()</em> 中关闭所有文件描述符（指向测试临时目录中的文件，甚至是未链接的文件），否则测试可能会破坏 NFS 上的临时目录删除（寻找“NFS silly rename ”）。 |</p></blockquote><h3 id="1-4-安全宏"><a href="#1-4-安全宏" class="headerlink" title="1.4 安全宏"></a>1.4 安全宏</h3><p>安全宏旨在简化测试准备中的错误检查。无需调用系统 API 函数，检查它们的返回值并在操作失败时中止测试，您只需使用相应的安全宏。</p><p>尽可能使用它们。</p><p>而不是写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TBROK <span class="token operator">|</span> TERRNO<span class="token punctuation">,</span> <span class="token string">"opening /dev/null failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你只写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">fd <span class="token operator">=</span> <span class="token function">SAFE_OPEN</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>重要的 : SAFE_CLOSE() 函数还在成功关闭后将传递的文件描述符设置为 -1。 </p></blockquote><p> 它们还可以简化 sysfs 文件的读写，例如，您可以这样做：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SAFE_FILE_SCANF</span><span class="token punctuation">(</span><span class="token string">"/proc/sys/kernel/pid_max"</span><span class="token punctuation">,</span> <span class="token string">"%lu"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pid_max<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有关完整列表，请参阅_include/tst_safe_macros.h_、_include/tst_safe_stdio.h_和 <em>include/tst_safe_file_ops.h_以及_include/tst_safe_net.h 。</em></p><h3 id="1-5-测试特定的命令行选项"><a href="#1-5-测试特定的命令行选项" class="headerlink" title="1.5 测试特定的命令行选项"></a>1.5 测试特定的命令行选项</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tst_option</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>optstr<span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>arg<span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>help<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_可以使用struct tst_option_的_NULL_终止数组传递测试特定的命令行参数。optstr是命令行选项，即“o”或“o:”（如果选项有参数）_。_仅支持短选项。arg 是匹配时存储_optarg__的位置。_如果选项没有参数，则在选项存在时将其设置为非_NULL值。_帮助是_一个_简短的帮助字符串。</p><blockquote><p>笔记 : 测试参数不得与库中定义的常用测试参数冲突，当前使用的是<code>-i</code>、<code>-I</code>、<code>-C</code>和<code>-h</code>。 |</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tst_parse_int</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">,</span> <span class="token keyword">int</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_parse_long</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token keyword">long</span> min<span class="token punctuation">,</span> <span class="token keyword">long</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_parse_float</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token keyword">float</span> min<span class="token punctuation">,</span> <span class="token keyword">float</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_parse_filesize</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> min<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>_用于解析struct tst_option_中返回的字符串的帮助程序。</p><p>帮助程序在成功时返回零，在失败时返回_errno ，主要是__EINVAL_或_ERANGE_。</p><p>_如果str_是_NULL_，辅助函数是无操作的。</p><p>结果的有效范围包括_min_和_max_。</p><p>特别是，_tst_parse_filesize_函数接受前缀乘法，例如“k/K”代表千字节，“m/M”代表兆字节，“g/G”代表千兆字节。例如，10K 转换为 10240 字节。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;limits.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>str_threads<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> threads <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_parse_int</span><span class="token punctuation">(</span>str_threads<span class="token punctuation">,</span> <span class="token operator">&amp;</span>threads<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TBROK<span class="token punctuation">,</span> <span class="token string">"Invalid number of threads '%s'"</span><span class="token punctuation">,</span> str_threads<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test_threads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tst_option</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"t:"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>str_threads<span class="token punctuation">,</span> <span class="token string">"Number of threads (default 10)"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-运行时内核版本检测"><a href="#1-6-运行时内核版本检测" class="headerlink" title="1.6 运行时内核版本检测"></a>1.6 运行时内核版本检测</h3><p>新添加的内核功能的测试用例需要比特定版本更新的内核才能运行。跳过旧内核测试所需要做的就是将_struct tst_test_中的_.min_kver_字符串设置为所需的最低内核版本，例如_.min_kver = “4.10.0”_。</p><p>对于更复杂的操作，例如跳过特定范围内核版本的测试，可以使用以下函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tst_kvercmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> r1<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">,</span> <span class="token keyword">int</span> r3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">tst_kern_exv</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>dist_name<span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>extra_ver<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_kvercmp2</span><span class="token punctuation">(</span><span class="token keyword">int</span> r1<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">,</span> <span class="token keyword">int</span> r3<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">tst_kern_exv</span> <span class="token operator">*</span>vers<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个函数用于运行时内核版本检测。_他们解析uname()_的输出并将其与传递的值进行比较。</p><p>返回值类似于_strcmp()_函数，即零表示相等，负值表示内核比预期值旧，正表示它较新。</p><p>第二个函数_tst_kvercmp2()_允许指定每个供应商的内核版本表，因为供应商通常向后移植修复到他们的内核，即使内核版本不建议，测试也可能相关。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_kvercmp</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TCONF<span class="token punctuation">,</span> <span class="token string">"Test valid only for kernel &lt; 5.19"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_kern_exv</span> kvers<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token string">"UBUNTU"</span><span class="token punctuation">,</span> <span class="token string">"4.4.0-48.69"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_kvercmp2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> kvers<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">/* code for kernel &lt; v4.4.27 or ubuntu kernel &lt; 4.4.0-48.69 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>| </p><p>警告</p><p> | shell _tst_kvercmp_将结果映射为无符号整数——进程退出值。 |</p><h3 id="1-7-Fork-ing"><a href="#1-7-Fork-ing" class="headerlink" title="1.7 Fork()-ing"></a>1.7 Fork()-ing</h3><p><em>请注意，如果测试fork并且tst</em>*()_接口打印了消息 ，则数据可能仍在 libc/内核缓冲区中，并且这些 <strong>不会</strong>自动刷新。</p><p>_当stdout_被重定向到一个文件时会发生这种情况。在这种情况下， _stdout_不是行缓冲的，而是块缓冲的。因此，在分叉之后，缓冲区的内容将由父项和每个子项打印。</p><p>为避免这种情况，您应该使用_SAFE_FORK()_、_SAFE_CLONE()_或_tst_clone()_。</p><blockquote><p>重要的 : <em>如果您的测试用例分叉或调用SAFE_CLONE() ，</em> 则必须在测试结构中设置_.forks_child_标志。 |</p></blockquote><h3 id="1-8-在子进程中做测试"><a href="#1-8-在子进程中做测试" class="headerlink" title="1.8 在子进程中做测试"></a>1.8 在子进程中做测试</h3><p>_tst_res()_报告的结果通过共享内存块传播到父测试进程。</p><p>调用_tst_brk()<em>会导致子进程以非零退出值退出。这意味着在子进程中使用_SAFE</em>*()宏也是安全的。_</p><p>在测试库中等待_test()_函数执行后存活的孩子。不干净的子进程退出（被信号、非零退出值等杀死）将导致主测试进程以_tst_brk()_退出，这尤其意味着从子进程传播的_TBROK_将导致整个测试以_TBROK_退出。</p><p>_如果一个测试需要一个发生段错误或做任何其他导致它不干净地退出的孩子，您需要做的就是从test()<em>函数中等待这样的孩子，以便在主测试退出 test() 函数之前 收割_它</em> 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">void</span> <span class="token function">tst_reap_children</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>tst_reap_children _()<em>函数使进程等待其所有子进程，并在其中任何一个返回非零退出代码时以_tst_brk(TBROK, … )退出。</em></p><p>使用_SAFE_CLONE_或_tst_clone_时，这可能不起作用，具体取决于传递给克隆的参数。以下对_SAFE_CLONE 的调用与__fork()_相同，因此将按预期工作。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tst_clone_args</span> args <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>exit_signal <span class="token operator">=</span> SIGCHLD<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">SAFE_CLONE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果_exit_signal_设置为其他值，那么这将中断 _tst_reap_children_。除非测试代码采取特定操作，否则预计所有要克隆的参数都不会与 LTP 库一起使用。</p><p>从_exec()<em>启动的二进制文件中使用_tst_res()</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* test.c */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_GNU_SOURCE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">do_test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"test_exec_child"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">char</span> path<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_get_path</span><span class="token punctuation">(</span><span class="token string">"test_exec_child"</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TCONF<span class="token punctuation">,</span> <span class="token string">"Couldn't find test_exec_child in $PATH"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">execve</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL <span class="token operator">|</span> TERRNO<span class="token punctuation">,</span> <span class="token string">"EXEC!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> do_test<span class="token punctuation">,</span><span class="token punctuation">.</span>child_needs_reinit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/* test_exec_child.c */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TST_NO_DEFAULT_MAIN</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">tst_reinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"Child passed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tst_res _()_函数也可以从_exec()_启动的二进制文件中使用，父测试进程必须设置 .child_needs_reinit_标志_，以便库为此做好准备，并且必须确保_LTP_IPC_PATH_环境变量被传递下来，然后程序必须在_main()<em>中调用的第一件事 是设置 IPC 的_tst_reinit() 。</em></p><h3 id="1-9-Fork-与父子同步"><a href="#1-9-Fork-与父子同步" class="headerlink" title="1.9 Fork()与父子同步"></a>1.9 Fork()与父子同步</h3><p>由于 LTP 测试是为 Linux 编写的，因此大多数测试都涉及 fork()-ing 和父子进程同步。LTP 包括一个检查点库，它提供基于等待/唤醒 futex 的功能。</p><p>为了使用检查点，<em>结构 tst_test_中的</em>.needs_checkpoints_标志必须设置为_1_ ，这会导致测试库在调用_test()_函数之前初始化检查点。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token function">TST_CHECKPOINT_WAIT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">TST_CHECKPOINT_WAIT2</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> msec_timeout<span class="token punctuation">)</span><span class="token function">TST_CHECKPOINT_WAKE</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">TST_CHECKPOINT_WAKE2</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> nr_wake<span class="token punctuation">)</span><span class="token function">TST_CHECKPOINT_WAKE_AND_WAIT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查点接口提供一对唤醒和等待功能。id是无符号整数，它指定要唤醒_/_等待的检查点。事实上，它是存储在共享内存中的数组的索引，因此它从 _0_开始，并且应该有足够的空间容纳至少数百个数组。</p><p>TST_CHECKPOINT_WAIT _()_和_TST_CHECKPOINT_WAIT2()_暂停进程执行，直到它被唤醒或达到超时。</p><p>TST_CHECKPOINT_WAKE _()_唤醒一个等待检查点的进程。如果没有进程在等待，该函数将重试直到成功或达到超时。</p><p>如果达到超时，进程退出并显示适当的错误消息（使用 _tst_brk()_）。</p><p>TST_CHECKPOINT_WAKE2 _()与__TST_CHECKPOINT_WAKE()_的作用相同，但可用于精确唤醒_nr_wake_进程。</p><p>TST_CHECKPOINT_WAKE_AND_WAIT _()_是执行唤醒然后立即等待同一检查点的简写。</p><p>通过_SAFE_FORK()_创建的子进程已准备好使用检查点同步功能，因为它们自动继承了映射页面。</p><p>通过_exec()_启动的子进程或任何其他未从测试进程派生的进程必须通过调用_tst_reinit()_来初始化检查点。</p><p>有关接口的详细信息，请查看_include/tst_checkpoint.h_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token comment">/* * Waits for process state change. * * The state is one of the following: * * R - process is running * S - process is sleeping * D - process sleeping uninterruptibly * Z - zombie process * T - process is traced */</span><span class="token function">TST_PROCESS_STATE_WAIT</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> state<span class="token punctuation">,</span> msec_timeout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_PROCESS_STATE_WAIT _()_等待直到进程_pid_处于请求 _状态_或达到超时。调用轮询<code>/proc/pid/stat</code>以获取此信息。超时为 0 将无限等待。</p><p>超时时返回 -1 并将 errno 设置为 ETIMEDOUT。</p><p>它主要与状态_S_一起使用，这意味着进程正在内核中休眠，例如在_pause()_或任何其他阻塞系统调用中。</p><h3 id="1-10-信号和信号处理器"><a href="#1-10-信号和信号处理器" class="headerlink" title="1.10 信号和信号处理器"></a>1.10 信号和信号处理器</h3><p>如果您需要使用信号处理程序，请保持代码简短。不要忘记信号处理程序是异步调用的，可以在任何地方中断代码执行。</p><p>这意味着当全局状态从测试代码和信号处理程序发生变化时会出现问题，这偶尔会导致：</p><ul><li><p>数据损坏（数据进入不一致状态），例如，对_FILE_对象的任何操作都可能发生这种情况。</p></li><li><p>死锁，例如，如果您同时从测试代码和信号处理程序 调用_malloc(2)_、_free(2)等，因为__malloc_对其内部数据结构具有全局锁定，就会发生这种情况。（注意 _malloc(2)_也在内部被 libc 函数使用。）</p></li><li><p>任何其他不可重现和意外的行为。</p></li></ul><p>很常见的错误是从信号处理程序调用_exit(3) 。_请注意，此函数不是信号异步安全的，因为它会刷新缓冲区等。如果您需要立即从信号处理程序退出测试，请改用__exit(2)_。</p><blockquote><p>提示 : 有关信号异步安全功能的列表， 请参见_man 7 signal </p></blockquote><p>如果信号处理程序设置了一个变量，它的声明必须是_volatile_，否则编译器可能会错误地优化代码。这是因为在编译器代码流分析中可能不会更改该变量。C99 中定义了_sig_atomic_t_ 类型，但这个类型<strong>并不</strong>意味着_volatile_（它只是 _int_的_typedef_）。因此，从信号处理程序更改的标志的正确类型是_volatile int_或_volatile sig_atomic_t_。</p><p>如果在测试中预期会发生崩溃（例如，由信号 SIGSEGV 触发），您可以通过调用 tst_no_corefile() 函数来避免创建核心文件。这对调用它的进程（及其子进程）生效，除非它们随后修改了 RLIMIT_CORE。</p><p>请注意，LTP 库将获取任何测试未获取自身的进程，并将任何非零退出代码报告为失败。</p><h3 id="1-11-内核模块"><a href="#1-11-内核模块" class="headerlink" title="1.11 内核模块"></a>1.11 内核模块</h3><p>在某些情况下，测试需要内核部分和用户空间部分，幸运的是，LTP 可以构建内核模块，然后在测试开始时为您将其插入内核。有关详细信息，请参阅_测试用例/内核/设备驱动程序/块_。</p><h3 id="1-12-有用的宏"><a href="#1-12-有用的宏" class="headerlink" title="1.12 有用的宏"></a>1.12 有用的宏</h3><p>_这些宏在include/tst_common.h_中定义。</p><p>返回静态定义数组的大小，即 <em>(sizeof(arr) / sizeof(*arr))</em></p><p>将 x 对齐为 a 的下一个倍数。a 必须是 2 的幂。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TST_TO_STR</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>  <span class="token comment">/* stringification */</span><span class="token function">TST_TO_STR_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">/* macro expansion */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字符串化宏。</p><h3 id="1-13-文件系统类型检测和skiplist"><a href="#1-13-文件系统类型检测和skiplist" class="headerlink" title="1.13 文件系统类型检测和skiplist"></a>1.13 文件系统类型检测和skiplist</h3><p>已知某些测试在某些文件系统上会失败（您不能在 TMPFS 上交换，有未实现的_fcntl()_等）。</p><p>如果您的测试需要在某些文件系统上跳过，请使用 tst_test 结构中的_.skip_filesystems_字段，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">.</span>skip_filesystems <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token string">"tmpfs"</span><span class="token punctuation">,</span>                <span class="token string">"ramfs"</span><span class="token punctuation">,</span>                <span class="token string">"nfs"</span><span class="token punctuation">,</span>                <span class="token constant">NULL</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当设置_.all_filesystems标志时，_ _.skip_filesystems_列表将传递给检测支持文件系统的函数，任何列出的文件系统都不包含在支持文件系统的结果列表中。</p><p>如果测试需要根据文件系统类型调整预期，也可以在运行时检测文件系统类型。当只有测试的子集不适用于给定的文件系统时，最好使用此方法。</p><p>| </p><p>笔记</p><p> | <strong>在不</strong>使用 <em>.all_filesystems 的_测试中，</em>.skip_filesystems_ 中的 ext2、ext3 或 ext4需要定义为_ext2/ext3/ext4_。原因是由于功能重叠，很难检测到使用过的文件系统。使用_.skip_filesystems_<strong>和</strong><em>.all_filesystems_的 OTOH 测试只能跳过</em>.all_filesystems_中实际使用的文件系统：ext2、ext3、ext4、xfs、btrfs、vfat、exfat、ntfs、tmpfs（在_fs_type_whitelist[]_中定义）。列出其他文件系统没有意义。 |</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token function">tst_fs_type</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> TST_NFS_MAGIC<span class="token operator">:</span><span class="token keyword">case</span> TST_TMPFS_MAGIC<span class="token operator">:</span><span class="token keyword">case</span> TST_RAMFS_MAGIC<span class="token operator">:</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TCONF<span class="token punctuation">,</span> <span class="token string">"Subtest not supported on %s"</span><span class="token punctuation">,</span>        <span class="token function">tst_fs_type_name</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-14-LTP-库中的线程安全"><a href="#1-14-LTP-库中的线程安全" class="headerlink" title="1.14 LTP 库中的线程安全"></a>1.14 LTP 库中的线程安全</h3><p>在多线程测试中使用库_tst_res()函数是安全的。_</p><p>只有主线程必须从_test()_函数返回到测试库，并且只有在可能调用任何库函数的所有线程都已终止后才能完成。这尤其意味着可能调用 _tst_brk()的线程必须在__test()_函数的执行返回到库之前终止。_这通常由主线程在test()_函数末尾加入所有工作线程来完成。请注意，在从其中一个线程调用_tst_brk()_的情况下，主线程永远不会访问库代码，因为它至少会在调用_tst_brk()_的线程上的_pthread_join()_中休眠，直到_exit()__由tst_brk()_调用。</p><p>_在从tst_brk()_输入清除的情况下，测试提供的清除函数与其余线程<strong>同时</strong>运行。后续进入_tst_brk()_的线程必须在用户提供的清理函数开始时暂停或终止。在测试清理之前，可能需要停止或退出其余线程。例如，创建新文件的线程应该在删除临时目录之前停止。</p><p>以下代码示例显示了使用原子增量作为保护的线程安全清理函数示例。该库在执行从用户提供的清理返回后调用其清理，并期望只有一个线程从用户提供的清理返回到测试库。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">int</span> flag<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flag<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* if needed stop the rest of the threads here */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* then do cleanup work */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* only one thread returns to the library */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-15-用块设备测试"><a href="#1-15-用块设备测试" class="headerlink" title="1.15 用块设备测试"></a>1.15 用块设备测试</h3><p>某些测试需要块设备（inotify 测试、系统调用_EROFS_失败等）。LTP 库包含准备测试设备的代码。</p><p>如果设置了_struct tst_test中的__.needs_device_标志，则_tst_device_ 结构将使用测试设备的路径和要使用的默认文件系统进行初始化。</p><p>_您还可以通过设置.dev_min_size_来请求以兆字节为单位的最小设备大小， 然后保证设备至少具有请求的大小。</p><p>如果设置了_.format_device_标志，设备也会使用文件系统进行格式化。如果需要，您可以使用_.dev_fs_type_覆盖默认文件系统类型，并通过_.dev_fs_opts_和 <em>.dev_extra_opts_指针将其他选项传递给 mkfs。请注意，</em>.format_device_暗示_.needs_device_ 没有必要同时设置两者。</p><p>如果设置了_.mount_device_，则设备将安装在_.mntpoint_处，该文件用于传递将创建并用作安装目标的目录名称。<em>您可以通过.mnt_flags</em> 和_.mnt_data_指针将附加标志和数据传递给挂载命令。请注意，_.mount_device_意味着_.needs_device_ 和_.format_device_，因此无需设置后两者。</p><p>如果设置了_.needs_rofs_，则只读文件系统将挂载在_.mntpoint_上，该文件系统应该用于_EROFS_测试。</p><p>如果设置了_.all_filesystems，<em>测试函数将针对所有支持的文件系统执行。支持的文件系统是根据 <em>mkfs.$fs_助手的存在和内核支持来检测的。对于每个支持的文件系统， <em>tst_device.fs_type_设置为当前测试的 fs 类型，如果 设置了</em>.format_device_，则设备也被格式化，如果设置了</em>.mount_device_，则它挂载在</em>.mntpoint_。此外，每次执行测试功能都会重置测试超时。此标志预期用于文件系统相关的系统调用，这些系统调用至少部分在文件系统特定代码中实现，例如_fallocate()_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">struct</span> <span class="token class-name">tst_device</span> <span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fs_type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">tst_device</span> <span class="token operator">*</span>tst_device<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_umount</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在环境中将_LTP_DEV_传递给测试，库会检查该文件是否存在以及它是否为块设备，如果 设置了_.device_min_size_，还会检查设备大小。如果未设置_LTP_DEV_ 或未满足大小要求，则会创建一个临时文件并将其附加到自由循环设备。</p><p>如果没有可用的设备并且循环设备无法初始化，则测试以_TCONF_退出。</p><p>tst_umount _()函数的工作原理与__umount(2)_完全相同，但在_EBUSY_上重试几次。这是因为各种桌面守护进程（以 gvfsd-trash 闻名）可能会愚蠢到探测所有新安装的文件系统，这会导致_umount(2)_失败并返回_EBUSY_。</p><p>| </p><p>重要的</p><p> | 所有测试用例都应该使用_tst_umount()_而不是_umount(2)_来卸载文件系统。 |</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_find_free_loopdev</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token class-name">size_t</span> path_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此函数找到空闲的 loopdev 并返回空闲的 loopdev minor（-1 表示没有空闲的 loopdev）。如果 path 为非 NULL，它将填充空闲的 loopdev 路径。如果你想使用自定义的循环设备，我们可以在测试中调用_tst_find_free_loopdev(NULL, 0)_ 来获得一个空闲的次设备号，然后 mknod。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">tst_dev_bytes_written</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此函数读取测试块设备统计文件 ( <em>/sys/block/<device>/stat</device></em> ) 并返回自上次调用此函数以来写入的字节。为避免 FS 延迟 IO 元数据/缓存干扰，我们建议在第一次调用 tst_dev_bytes_written 之前执行“syncfs”。 为此目的创建了一个名为_tst_dev_sync()_的内联函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">void</span> <span class="token function">tst_find_backing_dev</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token class-name">size_t</span> dev_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个函数找到这个路径所属的block dev，使用sysfs中的uevent。对于 Btrfs，它使用_/sys/fs/btrfs/UUID/devices/DEV_NAME/uevent_；对于其他文件系统，它使用_/sys/dev/block/MAJOR:MINOR/uevent_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token class-name">uint64_t</span> <span class="token function">tst_get_device_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev_path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此函数获取给定块设备的大小，它首先检查 dev_path_是否_有效，如果是，则返回以 MB 为单位的大小，否则返回 -1。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_dev_block_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此函数返回特定的物理设备块大小<code>path</code>。它找到所在的设备<code>path</code>，然后使用<code>ioctl</code>(BLKSSZGET) 获取物理设备块大小。</p><h3 id="1-16-用文件系统格式化设备"><a href="#1-16-用文件系统格式化设备" class="headerlink" title="1.16 用文件系统格式化设备"></a>1.16 用文件系统格式化设备</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">SAFE_MKFS</span><span class="token punctuation">(</span>tst_device<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> tst_device<span class="token operator">-&gt;</span>fs_type<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此函数采用设备路径、文件系统类型和传递给 mkfs 的额外选项数组。</p><p>fs 选项_fs_opts_应该是_NULL_（如果没有），或者是 _NULL_终止的字符串数组，例如： <code>const char *const opts[] = {"-b", "1024", NULL}</code>。</p><p>额外的选项_extra_opts_应该是_NULL_（如果没有的话），或者是一个 以_NULL_结尾的字符串数组，例如<code>{"102400", NULL}</code>; <em>extra_opts</em> 将在设备名称之后传递。例如：<code>mkfs -t ext4 -b 1024 /dev/sda1 102400</code> 在这种情况下。</p><p>_请注意，最好存储可以通过fs_opts_数组在设备名称之前或之后传递的选项。</p><h3 id="1-17-验证文件系统的空闲空间"><a href="#1-17-验证文件系统的空闲空间" class="headerlink" title="1.17 验证文件系统的空闲空间"></a>1.17 验证文件系统的空闲空间</h3><p>一些测试对文件系统的可用空间有大小要求。如果不满足这些要求，则应跳过测试。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fs_has_free</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mult<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>_如果有足够的空间， tst_fs_has_free()_函数返回 1，否则返回 0。</p><p>路径是文件系统中_任何_目录/文件的路径名。</p><p>mult是乘数，是_TST_BYTES_、<em>TST_KB_、_TST_MB_或_TST_GB_之一_。</em></p><p>_所需的可用空间由size * mult_计算，例如 _tst_fs_has_free(“/tmp/testfile”, 64, TST_MB)<em>如果文件系统（</em>“/tmp/testfile”_所在）至少有 64MB 可用空间，则返回 1，并且0 如果不是。</p><h3 id="1-18-文件、目录和-fs-限制"><a href="#1-18-文件、目录和-fs-限制" class="headerlink" title="1.18 文件、目录和 fs 限制"></a>1.18 文件、目录和 fs 限制</h3><p>一些测试需要知道指向常规文件或目录的最大链接数，例如_rename(2)_或_linkat(2)_来测试_EMLINK_错误。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fs_fill_hardlinks</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>_尝试获取dir_内常规文件的最大硬链接数。</p><p>此函数使用_link(2)_创建单个文件的硬链接，直到它获得_EMLINK_或创建 65535 个链接。如果达到限制，则返回最大硬链接数，_目录_中将填充格式为“testfile%i”的硬链接，其中 i 属于 [0, limit) 区间。如果没有达到限制，或者如果 _link(2)因__ENOSPC_或_EDQUOT_失败，则返回零并删除以前创建的文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fs_fill_subdirs</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>尝试获取目录中子目录的最大数量。</p><p>| </p><p>笔记</p><p> | 这个数字取决于文件系统_dir_所在的位置。对于当前内核，子目录限制不适用于所有文件系统（适用于 ext2、ext3、minix、sysv 等）。如果测试在其他一些文件系统上运行，如 ramfs、tmpfs，它甚至不会尝试达到限制并返回 0。 |</p><p>此函数使用_mkdir(2)在__dir_中创建目录，直到它获得 _EMLINK_或创建 65535 个目录。如果达到限制，则返回子目录的最大数量，并且_目录_中填充格式为“testdir%i”的子目录，其中 i 属于 [0, limit - 2) 区间（因为每个新创建的目录已经有两个链接- _._和来自父目录的链接）。如果没有达到限制或者如果_mkdir(2)因__ENOSPC_或_EDQUOT_失败，则返回零并删除以前创建的目录。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_dir_is_empty</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">int</span> verbose<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果目录为空则返回非零，否则返回零。</p><p>如果目录仅包含_._ 和_…_ _</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">void</span> <span class="token function">tst_purge_dir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>删除给定目录的内容但保留目录本身。用于清理测试用例或测试迭代之间的临时目录和挂载点。出错时用_TBROK_终止程序。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fill_fd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">char</span> pattern<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bs<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bcount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用文件描述符以指定模式填充文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_prealloc_size_fd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bs<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bcount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>_使用fallocate()_预分配指定的空间量。如果_fallocate()_失败，则回退到 _tst_fill_fd()_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fill_file</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> pattern<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bs<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bcount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用文件路径创建/覆盖具有指定模式的文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_prealloc_file</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bs<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bcount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建/覆盖文件并为其预分配指定的空间量。分配的空间不会被初始化为任何特定的内容。</p><h3 id="1-19-获取未使用的-PID-号"><a href="#1-19-获取未使用的-PID-号" class="headerlink" title="1.19 获取未使用的 PID 号"></a>1.19 获取未使用的 PID 号</h3><p>一些测试需要一个_PID_，操作系统不使用它（不属于其中的任何进程）。例如，如果 kill(2) 传递了这样的_PID ，它应该将 errno 设置为__ESRCH_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token class-name">pid_t</span> <span class="token function">tst_get_unused_pid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>返回操作系统或其中的任何进程未使用的_PID值。_</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_get_free_pids</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>返回系统中未使用的 pid 数。请注意，一旦调用返回，此数字可能会有所不同，并且应该仅用于粗略估计。</p><h3 id="1-20-运行可执行文件"><a href="#1-20-运行可执行文件" class="headerlink" title="1.20 运行可执行文件"></a>1.20 运行可执行文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_cmd</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>stdout_path<span class="token punctuation">,</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>stderr_path<span class="token punctuation">,</span>        <span class="token keyword">enum</span> <span class="token class-name">tst_cmd_flags</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_tst_cmd()是__vfork() + execvp()_的包装器，它提供了一种执行外部程序的方法。</p><p>_argv[]_是一个_以 NULL_结尾的字符串数组，以程序名称开头，后跟可选参数。</p><p>_TST_CMD_PASS_RETVAL_枚举_tst_cmd_flags_使_tst_cmd()_将 程序退出代码返回给调用者，否则_tst_cmd()<em>在失败时退出测试。_TST_CMD_TCONF_ON_MISSING_检查</em>$PATH中的程序，如果没有找到则以__TCONF_退出。</p><p>如果_execvp()_失败并且设置了枚举_TST_CMD_PASS_RETVAL_标志，则如果_execvp()因__ENOENT_而失败则返回值为_255_，否则_返回值为 254_。</p><p>_stdout_path_和_stderr_path_确定重定向程序 stdout 和 stderr I/O 流的位置。</p><p>SAFE_CMD _()_宏可用于自动处理非零退出（以_TBROK_退出）和_ENOENT （以__TCONF_退出）。</p><p>例子</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> cmd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* Store output of 'ls -l' into log.txt */</span><span class="token function">tst_cmd</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> <span class="token string">"log.txt"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-21-测量运行时间和辅助函数"><a href="#1-21-测量运行时间和辅助函数" class="headerlink" title="1.21 测量运行时间和辅助函数"></a>1.21 测量运行时间和辅助函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_timer.h"</span></span><span class="token keyword">void</span> <span class="token function">tst_timer_check</span><span class="token punctuation">(</span><span class="token class-name">clockid_t</span> clk_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tst_timer_start</span><span class="token punctuation">(</span><span class="token class-name">clockid_t</span> clk_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tst_timer_stop</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token function">tst_timer_elapsed</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timer_elapsed_ms</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timer_elapsed_us</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_timer_expired_ms</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tst_timer_check _()<em>函数检查是否支持指定的_clk_id ，否则使用__TCONF_退出测试。它应该 在任何需要清理的资源被初始化之前用在测试_setup()中，因此它不包含清理函数参数。</em></p><p>tst_timer_start _()_标记开始时间并存储_clk_id_以供进一步使用。</p><p>tst_timer_stop _()_使用与上次调用_tst_timer_start()相同的__clk_id_标记停止时间。</p><p>tst_timer_elapsed _*()_以多种格式和单位返回定时器启动和上次定时器停止之间的时间差。</p><p>tst_timer_expired_ms _()函数检查由__tst_timer_start()_启动的定时器是否 运行时间超过 ms 毫秒。如果计时器已过期，则该函数返回非零值，否则返回零值。</p><p>| </p><p>重要的</p><p> | 计时器函数在内部使用_clock_gettime()_ ，它需要与旧 glibc 上的_-lrt_链接。请不要忘记在 Makefile 中添加 _LDLIBS+=-lrt_。 |</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_timer.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">tst_timer_check</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">tst_timer_start</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tst_timer_expired_ms</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到期计时器示例用法。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_to_us</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_to_ms</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token function">tst_us_to_timeval</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> us<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token function">tst_ms_to_timeval</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_timespec_lt</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token function">tst_timespec_add_us</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> us<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token function">tst_timespec_diff</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_diff_us</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_diff_ms</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token function">tst_timespec_abs_diff</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_abs_diff_us</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_abs_diff_ms</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前四个函数是简单的内联转换函数。</p><p>_如果t1_早于 <em>t2</em> ，则tst_timespec_lt _()_函数返回非零值。</p><p>tst_timespec_add_us _()_函数将_us_微秒添加到 timespec <em>t_中。预计美国将是积极的_。</em></p><p>tst_timespec_diff _*()_函数返回两次之间的差异， 预计_t1_晚于_t2_。</p><p>tst_timespec_abs_diff _*()_函数返回两个时间之差的绝对值。</p><p>| </p><p>笔记</p><p> | 所有转换为 ms 和 us 的值都四舍五入。 |</p><h3 id="1-22-数据文件"><a href="#1-22-数据文件" class="headerlink" title="1.22 数据文件"></a>1.22 数据文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> res_files<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token string">"bar"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>resource_files <span class="token operator">=</span> res_files<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果测试需要将其他文件复制到测试临时目录，您需要做的就是在 tst_test 结构的_NULL_终止数组_.resource_files中列出它们的文件名。_</p><p>设置资源文件时自动创建测试临时目录，还需要设置_.needs_tmpdir 。_</p><p><code>datafiles</code>测试库首先查找数据文件，这些文件要么存储在<code>$PWD</code>测试开始时 调用的目录中，要么存储在<code>$LTPROOT/testcases/data/${test_binary_name}</code>. 如果未找到该文件，则库会在测试开始时<code>$LTPROOT/testcases/bin/</code>进行调查。<code>$PWD</code>这确保了测试用例可以毫不费力地复制文件，无论是从编译目录开始测试还是安装 LTP 时。</p><p>文件被复制到新创建的测试临时目录，该目录在执行_test()_函数时设置为测试工作目录。</p><h3 id="1-23-代码路径追踪"><a href="#1-23-代码路径追踪" class="headerlink" title="1.23 代码路径追踪"></a>1.23 代码路径追踪</h3><p>_tst_res_是一个宏，所以当你在一个文件中定义一个函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">do_action</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"check passed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"check failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_并从另一个文件调用它，此函数中tst_res_报告的文件和行将来自前一个文件。</p><p>_TST_TRACE_可以使此类情况的分析更加容易。这是一个宏，它插入对_tst_res(TINFO, … ) 的_调用，以防其参数计算结果为非零。_在对tst_res(TINFO, … )_的调用中，文件和行将使用_TST_TRACE_的实际位置进行扩展。</p><p>例如，如果另一个文件包含：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TST_TRACE</span><span class="token punctuation">(</span><span class="token function">do_action</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的输出可能类似于：</p><p>common.h:9: FAIL: 检查失败 test.c:8: INFO: do_action(arg) 失败</p><h3 id="1-24-受污染的内核"><a href="#1-24-受污染的内核" class="headerlink" title="1.24 受污染的内核"></a>1.24 受污染的内核</h3><p>如果需要检测一个测试用例是否触发了内核警告、bug 或 oops，可以使用以下方法检测 TAINT_W 或 TAINT_D：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>taint_check <span class="token operator">=</span> TST_TAINT_W <span class="token operator">|</span> TST_TAINT_D<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_taint_check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"kernel has issues"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"kernel seems to be fine"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要初始化污点检查，您必须在tst_test 结构的_taint_check_属性中设置要测试的污点标志。然后，LTP 库将在测试设置期间自动调用_tst_taint_init() 。<em>如果正在运行的内核不完全支持请求的标志，该函数将生成_TCONF</em> ，如果内核在执行测试之前已经被污染，则_生成 TBROK 。_</p><p>LTP 库将在测试结束时自动检查内核污点。如果在 struct tst_test 中设置了_.all_filesystems ，污点检查将在每个文件系统之后执行，并且污点将使用__TFAIL_提前中止测试。您也可以选择在_run()<em>期间调用_tst_taint_check()</em> ，它返回 0 或如前所述在_/proc/sys/kernel/tainted_中设置的污染标志。</p><p>根据您的内核版本，并非所有受污染标志都受支持。</p><h3 id="1-25-校验和"><a href="#1-25-校验和" class="headerlink" title="1.25 校验和"></a>1.25 校验和</h3><p>LTP 支持 CRC32c 校验和生成。为了使用它，测试应该包含_tst_checksum.h_头文件，然后可以调用_tst_crc32c()_。</p><h3 id="1-26-检查内核对驱动程序的支持"><a href="#1-26-检查内核对驱动程序的支持" class="headerlink" title="1.26 检查内核对驱动程序的支持"></a>1.26 检查内核对驱动程序的支持</h3><p>某些测试可能需要特定的内核驱动程序，这些驱动程序可以编译或构建为模块。如果_.needs_drivers_指向一个_以 NULL_结尾的内核模块名称数组，则这些名称都会被检查，并且测试会在第一个丢失的驱动程序上以_TCONF退出。_</p><p>由于它依赖于 modprobe 命令，如果命令本身在系统上不可用，则将跳过检查。</p><h3 id="1-27-保存和恢复-x2F-proc-sys-值"><a href="#1-27-保存和恢复-x2F-proc-sys-值" class="headerlink" title="1.27 保存和恢复 /proc|sys 值"></a>1.27 保存和恢复 /proc|sys 值</h3><p>可以指示 LTP 库保存和恢复指定 (/proc|sys) 文件的值。这是通过初始化的 tst_test 结构字段_save_restore_实现的。它是一个以 NULL 结尾的结构 _tst_path_val_数组，其中每个 tst_path_val.path 代表一个文件，其值在测试开始时保存并在测试结束时恢复。如果在 tst_path_val.val 中传递了非 NULL 字符串，它将在测试开始时写入相应的文件。仅保存和恢复指定文件的第一行。</p><p>默认情况下，如果文件是只读的或不存在，测试将以 TCONF 结束。如果可选的新值写入失败，测试将以_TBROK_结束。可以使用 tst_path_val.flags 更改此行为：</p><ul><li><p><em>TST_SR_TBROK_MISSING</em> –如果文件不存在则使用_TBROK_结束测试</p></li><li><p><em>TST_SR_TCONF_MISSING</em> –如果文件不存在则使用_TCONF_结束测试</p></li><li><p><em>TST_SR_SKIP_MISSING</em> – 如果文件不存在则不保存文件继续</p></li><li><p><em>TST_SR_TBROK_RO</em> –如果文件是只读的，则使用_TBROK_结束测试</p></li><li><p><em>TST_SR_TCONF_RO</em> –如果文件是只读的，则使用_TCONF_结束测试</p></li><li><p><em>TST_SR_SKIP_RO</em> – 如果文件是只读的则不保存文件继续</p></li><li><p><em>TST_SR_IGNORE_ERR</em> – 将新值写入文件时忽略错误</p></li></ul><p>常见的标志组合也有快捷方式：</p><ul><li><p><em>TST_SR_TCONF</em> – 等同于_TST_SR_TCONF_MISSING | TST_SR_TCONF_RO_</p></li><li><p><em>TST_SR_TBROK</em> – 等同于_TST_SR_TBROK_MISSING | TST_SR_TBROK_RO_</p></li><li><p><em>TST_SR_SKIP</em> – 等同于_TST_SR_SKIP_MISSING | TST_SR_SKIP_RO_</p></li></ul><p>_restore_总是严格的，如果遇到任何错误都会发出警告。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>save_restore <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tst_path_val</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"/proc/sys/kernel/core_pattern"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> TST_SR_TCONF<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"/proc/sys/user/max_user_namespaces"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> TST_SR_SKIP<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"/sys/kernel/mm/ksm/run"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> TST_SR_TBROK<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-28-解析内核-config"><a href="#1-28-解析内核-config" class="headerlink" title="1.28 解析内核.config"></a>1.28 解析内核.config</h3><p>通常，测试用例应该尝试根据当前运行的内核自动检测尽可能多的内核特性。我们确实有 tst_check_driver() 来检查系统上是否存在可以编译为内核模块的功能，可以通过检查_ENOSYS_ errno 等来检测禁用的系统调用。</p><p>然而，在极少数情况下，无法根据内核用户空间 API 检测到核心内核功能，我们不得不求助于解析内核 .config。</p><p>对于这种情况，测试应该设置_NULL_终止的_.needs_kconfigs_ 布尔表达式数组，并限制 kconfig 变量。布尔表达式由变量、两个二元运算_&amp;<em>和</em>|组成_ ，否定_！<em>和正确的括号顺序</em>()_。变量应采用“CONFIG_FOO[=bar]”的形式。</p><p><em>如果所有表达式的计算结果为True</em> ，测试将继续运行。缺少的变量映射到_False_以及具有不同于指定值的变量，例如_CONFIG_FOO=bar_如果值不是_bar_，则将评估为_False_。如果配置变量被指定为普通的 _CONFIG_FOO，_它被评估为真，它被设置为任何值（通常是 =y 或 =m）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>kconfigs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"CONFIG_X86_INTEL_UMIP | CONFIG_X86_UMIP"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>needs_kconfigs <span class="token operator">=</span> kconfigs<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-29-在测试执行期间更改挂钟时间"><a href="#1-29-在测试执行期间更改挂钟时间" class="headerlink" title="1.29 在测试执行期间更改挂钟时间"></a>1.29 在测试执行期间更改挂钟时间</h3><p>由于不同的原因，有些测试可能需要更改系统范围的时钟时间。每当发生这种情况时，必须在测试执行结束时恢复时钟，同时考虑该测试期间经过的时间量。</p><p>为了实现这一点，struct tst_test 有一个名为“restore_wallclock”的变量，该变量应设置为“1”，因此 LTP 知道它应该：(1) 在测试设置阶段初始化一个单调时钟，以及 (2) 使用该单调时钟来在测试清理阶段修复系统范围的时钟时间。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>restore_wallclock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-30-在一次测试中测试相似的系统调用"><a href="#1-30-在一次测试中测试相似的系统调用" class="headerlink" title="1.30 在一次测试中测试相似的系统调用"></a>1.30 在一次测试中测试相似的系统调用</h3><p>在某些情况下，内核有几个非常相似的系统调用，它们执行相同或非常相似的工作。这在 i386 上最为明显，我们通常有两个或三个系统调用版本。那是因为 i386 是第一个开发 Linux 的平台，而且大多数 API 错误也发生在那里。然而，这根本不限于 i386，版本 2 系统调用添加缺少的标志参数左右是很常见的。</p><p>在这种情况下，一遍又一遍地复制和粘贴测试代码没有多大意义，而不是让测试库提供对测试变体的支持。测试变体背后的想法很简单，我们每次使用不同的系统调用变体运行多次测试。</p><p>该实现由 test_variants 整数组成，如果设置，则表示测试变体的数量。然后每次使用全局 tst_variant 变量中的不同值分叉并执行 test_variants 次测试。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_foo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>tst_variant<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span><span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span><span class="token keyword">return</span> <span class="token function">syscall</span><span class="token punctuation">(</span>__NR_foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TEST</span><span class="token punctuation">(</span>do_foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>tst_variant<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TINFO<span class="token punctuation">,</span> <span class="token string">"Testing foo variant 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TINFO<span class="token punctuation">,</span> <span class="token string">"Testing foo variant 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>test_variants <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-31-保护缓冲区"><a href="#1-31-保护缓冲区" class="headerlink" title="1.31 保护缓冲区"></a>1.31 保护缓冲区</h3><p>测试库支持受保护的缓冲区，这些缓冲区是这样分配的：</p><ul><li><p>缓冲区末尾后跟一个 PROT_NONE 页</p></li><li><p>缓冲区之前页面的剩余部分填充了随机金丝雀数据</p></li></ul><p>这意味着缓冲区之后的任何访问将产生分段错误或 EFAULT，具体取决于访问是分别发生在用户空间还是内核中。缓冲区之前的金丝雀也会捕获缓冲区外的任何写访问。</p><p>该补丁的目的是捕获在将缓冲区和结构传递给系统调用时发生的错误。新测试应该为传递给被测试系统调用的所有数据分配受保护的缓冲区，这些数据是由指针传递的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token operator">*</span>foo_ptr<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token operator">*</span>iov<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf_ptr<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>id<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>foo_ptr<span class="token operator">-&gt;</span>bar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>foo_ptr<span class="token operator">-&gt;</span>buf <span class="token operator">=</span> buf_ptr<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token function">tst_strdup</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>bufs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tst_buffers</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">&amp;</span>foo_ptr<span class="token punctuation">,</span> <span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>foo_ptr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token operator">&amp;</span>buf_ptr<span class="token punctuation">,</span> <span class="token punctuation">.</span>size <span class="token operator">=</span> BUF_SIZE<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token operator">&amp;</span>iov<span class="token punctuation">,</span> <span class="token punctuation">.</span>iov_sizes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_受保护的缓冲区可以在运行时通过tst_alloc()_或_tst_strdup()_以及通过填充 tst_test 结构中的 .bufs 数组在测试 setup()中分配 。</p><p>_到目前为止，tst_test 结构支持通过设置大小或 struct iovec 来分配普通缓冲区，它是递归分配的，包括由-1_终止的缓冲区大小数组描述的各个缓冲区。</p><h3 id="1-32-添加和删除功能"><a href="#1-32-添加和删除功能" class="headerlink" title="1.32 添加和删除功能"></a>1.32 添加和删除功能</h3><p>某些测试可能需要特定功能的存在或不存在。_使用tst_capability.h_提供的 API，测试作者可以尝试确保某些功能在测试期间存在或不存在。</p><p>例如; 下面我们尝试创建一个原始套接字，这需要 CAP_NET_ADMIN。在设置期间我们应该能够做到这一点，然后在运行期间它应该是不可能的。LTP 能力库将在设置之前检查我们是否具有此能力，然后在设置之后将其删除。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_capability.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_safe_net.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lapi/socket.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">TEST</span><span class="token punctuation">(</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>TST_RET <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"Created raw socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>TST_ERR <span class="token operator">!=</span> EPERM<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span><span class="token string">"Failed to create socket for wrong reason"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span> <span class="token string">"Didn't create raw socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">TEST</span><span class="token punctuation">(</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>TST_RET <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TCONF <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span> <span class="token string">"We don't have CAP_NET_RAW to begin with"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>TST_RET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>caps <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tst_cap</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">TST_CAP</span><span class="token punctuation">(</span>TST_CAP_REQ<span class="token punctuation">,</span> CAP_NET_RAW<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">TST_CAP</span><span class="token punctuation">(</span>TST_CAP_DROP<span class="token punctuation">,</span> CAP_NET_RAW<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看底部的测试结构。<em>我们用包含两个tst_cap结构的__NULL_终止数组填充了_caps_字段。_TST_CAP_REQ</em> 动作在设置前执行，_TST_CAP_DROP_在设置后执行。这意味着可以请求和删除功能。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>caps <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tst_cap</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">TST_CAP</span><span class="token punctuation">(</span>TST_CAP_REQ<span class="token punctuation">,</span> CAP_NET_RAW<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">TST_CAP</span><span class="token punctuation">(</span>TST_CAP_DROP<span class="token punctuation">,</span> CAP_SYS_ADMIN<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们请求_CAP_NET_RAW_，但删除_CAP_SYS_ADMIN_。如果该功能在允许集中，但不在有效集中，库将尝试允许它。如果它不在允许的集合中，那么它将失败并显示_TCONF_。</p><p>此 API 不需要安装_libcap 。__但是，它相对于libcap 的_功能有限。它只尝试在有效集中添加或删除功能。这意味着需要生成子进程的测试可能难以确保子进程可以使用正确的功能（请参阅功能 (7) 手册页）。</p><p>但是直接使用随时调用的_tst_cap_action(struct tst_cap *cap)_可以解决很多问题。如果您希望在设置开始时删除功能，这也会有所帮助。</p><h3 id="1-33-重现竞争条件"><a href="#1-33-重现竞争条件" class="headerlink" title="1.33 重现竞争条件"></a>1.33 重现竞争条件</h3><p>如果错误是由内核竞赛中的两个任务引起的，并且您希望创建回归测试（或错误修复验证测试），则应 使用_tst_fuzzy_sync.h库。_</p><p>它允许您在代码中指定两个比赛窗口。每个线程循环中的一个窗口（触发竞争通常需要多次迭代）。这些窗口显示可能发生竞争的模糊同步。它们不需要精确，因此是_模糊的_部分。如果竞争条件没有立即触发，那么库将开始尝试不同的时间。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_fuzzy_sync.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_fzsync_pair</span> fzsync_pair<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">tst_fzsync_pair_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">tst_fzsync_pair_cleanup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">tst_fzsync_run_b</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_fzsync_start_race_b</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/* This is the race window for thread B */</span>                <span class="token function">tst_fzsync_end_race_b</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> arg<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">tst_fzsync_pair_reset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">,</span> thread_b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">tst_fzsync_run_a</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_fzsync_start_race_a</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* This is the race window for thread A */</span>                <span class="token function">tst_fzsync_end_race_a</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> thread_a<span class="token punctuation">,</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>cleanup <span class="token operator">=</span> cleanup<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是使用模糊同步进行测试的最小模板。在一个简单的例子中，你只需要将你想要比赛的位放在_start_race_和 _end_race_之间。同时，每次迭代需要进行的任何设置都在窗口之外。</p><p>模糊同步同步_run_a_和_run_b_，它们充当障碍，因此在另一个线程赶上它之前，任何一个线程都不能前进。还有_pair_wait_函数，可用于在其他位置添加障碍。当然_start/end_race_a/b_也是一个障碍。</p><p>该库根据用户指定的超时以及一些其他启发式方法来决定测试应该运行多长时间。</p><p>_有关完整文档，请参阅include/tst_fuzzy_sync.h_中的注释。</p><h3 id="1-34-保留大页"><a href="#1-34-保留大页" class="headerlink" title="1.34 保留大页"></a>1.34 保留大页</h3><p>许多 LTP 测试需要在他们的测试中使用大页面，这允许测试可以通过_.hugepages = {xx, TST_REQUEST}_从系统中保留大页面。</p><p>我们实现了两个保留大页面的策略：</p><p>TST_REQUEST：会尽量预留可用的hugepages，返回tst_hugepages中可用的hugepages的个数，如果完全不支持hugepages可能为0。</p><p>TST_NEEDS：这是一个强制性要求，LTP应该严格执行hpages applying并保证HugePages_Free_不少于_pages使得测试可以正确使用这些指定的数字。否则，如果尝试保留大页面失败或保留少于请求，则测试以 TCONF 退出。</p><p>成功测试将保留的大页面编号存储在_tst_hugepages_中。对于不支持 hugetlb 的系统，变量_tst_hugepages_将设置为 0。如果在支持的 hugetlb 系统上需要将 hugepage 编号设置为 0，请使用_.hugepages = {TST_NO_HUGEPAGES}_。</p><p>此外，我们还为自动重置的 hpages 做清理和恢复工作。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tst_hugepages <span class="token operator">==</span> test<span class="token punctuation">.</span>hugepages<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token function">TEST</span><span class="token punctuation">(</span>do_hpage_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>hugepages <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> TST_REQUEST<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">/* TST_NEEDS achieved this automatically in the library */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tst_hugepages <span class="token operator">!=</span> test<span class="token punctuation">.</span>hugepages<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TCONF<span class="token punctuation">,</span> <span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>hugepages <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> TST_NEEDS<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-35-检查所需命令"><a href="#1-35-检查所需命令" class="headerlink" title="1.35 检查所需命令"></a>1.35 检查所需命令</h3><p><em>可以使用.needs_cmds_检查所需的命令，它指向以_NULL</em> 结尾的字符串数组，例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>needs_cmds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token string">"useradd"</span><span class="token punctuation">,</span><span class="token string">"userdel"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_也可以使用needs_cmds_检查所需的命令版本是否满足， 例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>needs_cmds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token string">"mkfs.ext4 &gt;= 1.43.0"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>目前，我们仅支持 mkfs.ext4 命令版本检查。如果你想支持更多的命令，请在lib/tst_cmd.c的version_parsers结构中填写你自己的.parser和.table_get方法。</p><h3 id="1-36-断言-sys-或-proc-文件值"><a href="#1-36-断言-sys-或-proc-文件值" class="headerlink" title="1.36 断言 sys 或 proc 文件值"></a>1.36 断言 sys 或 proc 文件值</h3><p>使用 TST_ASSERT_INT/STR(path, val) 断言存储在路径指向的文件的前缀字段中的整数值或字符串等于传递给此函数的值。</p><p>还有一个类似的 api 对 TST_ASSERT_FILE_INT/STR(path, prefix, val) 来断言文件的字段值。</p><h3 id="1-36-使用控制组"><a href="#1-36-使用控制组" class="headerlink" title="1.36 使用控制组"></a>1.36 使用控制组</h3><p>一些 LTP 测试需要特定的控制组配置。 <em>tst_cgroup.h</em> 提供 API 来发现和使用 CGroup。CGroups API V1 和 V2 之间存在许多差异。我们将配置 CGroups 的细节封装在尽可能遵循 V2 内核 API 的高级函数中。允许编写适用于 V1 或 V2 的代码。无论如何，至少在某些时候；通常 V1 和 V2 之间的行为差异太大。在这种情况下，我们恢复到 CGroup 版本上的分支。</p><p>此外，如果需要，LTP 库将自动挂载/卸载和配置 CGroup 层次结构（例如，如果您在没有系统管理器的情况下从 init 运行测试）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// do test under cgroup</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.max"</span><span class="token punctuation">,</span> <span class="token string">"%lu"</span><span class="token punctuation">,</span> MEMSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SAFE_CG_HAS</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.swap.max"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.swap.max"</span><span class="token punctuation">,</span> <span class="token string">"%zu"</span><span class="token punctuation">,</span> memsw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>cleanup <span class="token operator">=</span> cleanup<span class="token punctuation">,</span><span class="token punctuation">.</span>needs_cgroup_ctrls <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token string">"memory"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_在上面，我们首先使用.needs_cgroup_ctrls_确保内存控制器在测试的 CGroup 上可用。这会填充结构 _tst_cg_，它表示测试的 CGroup。</p><p>然后我们将当前进程的 PID 写入_cgroup.procs_，这会将当前进程移动到测试的 CGroup 中。之后我们通过写入_memory.max_来设置最大内存大小。如果内存控制器安装在 CGroups V1 上，那么库实际上将写入_memory.limit_in_bytes_。作为一般规则，如果一个文件存在于两个 CGroup 版本中，那么我们使用 V2 命名。</p><p>可以禁用某些控制器功能，例如_memory.swap 。_因此我们需要在访问它们之前检查它们是否存在。_这可以通过SAFE_CG_HAS_来完成，它可以在任何控制文件或功能上调用。</p><p>大多数测试只需要设置一些与上述类似的限制。在这种情况下，隐藏了 V1 和 V2 之间的差异。安装和清理也大多是隐藏的。然而，事情可能会变得更糟。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_cg_group</span> <span class="token operator">*</span>cg_child<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFSIZ<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> mem <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cg_child <span class="token operator">=</span> <span class="token function">tst_cg_group_mk</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TST_CG_VER_IS_V1</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">SAFE_CG_PRINT</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"cgroup.subtree_control"</span><span class="token punctuation">,</span> <span class="token string">"+memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TST_CG_VER_IS_V1</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"cpuset"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">SAFE_CG_PRINT</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"cgroup.subtree_control"</span><span class="token punctuation">,</span> <span class="token string">"+cpuset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">SAFE_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SAFE_CG_HAS</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span> <span class="token string">"memory.swap"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">SAFE_CG_SCANF</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span>  <span class="token string">"memory.swap.current"</span><span class="token punctuation">,</span> <span class="token string">"%zu"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">SAFE_CG_READ</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span> <span class="token string">"cpuset.mems"</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Do something with cpuset.mems and memory.current values</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">tst_reap_children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg_drain<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cg_child <span class="token operator">=</span> <span class="token function">tst_cg_group_rm</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cg_child<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg_drain<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cg_child <span class="token operator">=</span> <span class="token function">tst_cg_group_rm</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>needs_cgroup_ctrls <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">"cpuset"</span><span class="token punctuation">,</span><span class="token string">"memory"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从设置开始；我们可以在这里看到我们获取了_drain_ CGroup。这是一个共享组（在并行测试之间），可能包含来自其他测试的进程。它应该有默认设置并且这些设置不应该被测试改变。它可用于从其他 CGroups 中删除进程，以防层次结构根无法访问。</p><p>请注意，不应多次调用_tst_cg_get_drain_group ，因为它分配在受保护的缓冲区中（请参阅第 2.2.31 节）。<em>因此最好在_设置_中调用一次而不是_运行_，因为_运行_可能会用</em>-i_选项重复。</p><p>在_运行中，我们首先使用__tst_cg_mk_创建一个子 CGroup 。_当我们在运行_中创建这个 CGroup 时，我们也应该在运行结束时将其删除。我们还需要检查它是否存在并在清理中将其删除。因为有_SAFE__函数可能会跳转到清理。</p><p>然后，我们将主要测试进程移至子 CGroup 中。这很重要，因为这意味着在我们销毁子 CGroup 之前，我们必须将主要测试进程移到别处。为此，我们使用_排水_ 组。</p><p>接下来我们在测试 CGroup 的后代（即_cg_child_）上启用内存和 cpuset 控制器配置。这允许每个孩子都有自己的设置。V1 上不存在文件_cgroup.subtree_control 。_因为有可能同时激活 V1 和 V2。我们不能简单地在写入之前检查_subtree_control是否存在。__在尝试将其添加到subtree_control_之前，我们必须检查特定控制器是否在 V2 上。尝试添加 V1 控制器将导致_ENOENT_。</p><p>然后我们 fork 一个子进程并将其添加到子 CGroup。在子进程中，我们尝试读取_memory.swap.current_。内存控制器可能是在不支持交换的情况下编译的，因此有必要检查是否启用了_memory.swap 。<em>也就是说，除非测试永远不会达到在没有交换支持的情况下使用_memory.swap.* 的程度。</em></p><p>父进程在销毁子 CGroup 之前等待子进程被回收。所以不需要转移孩子去引流。但是必须移动父进程，否则我们在尝试删除子 CGroup 时会遇到_EBUSY 。_</p><p>下面显示了版本之间行为差异的另一个示例。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TST_CG_VER_IS_V1</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.swap.max"</span><span class="token punctuation">,</span> <span class="token string">"%lu"</span><span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0UL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">SAFE_CG_PRINT</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.swap.max"</span><span class="token punctuation">,</span> <span class="token string">"max"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>CGroups V2 引入了一项功能，可以将_memory[.swap].max_设置为“max”。然而，这似乎不适用于 V1 _limit_in_bytes_。对于大多数测试，简单地使用大数就足够了，没有必要使用“max”。但重要的是，应该仔细阅读 V1 和 V2 内核文档。目前 LTP 库不尝试处理语义上的大多数差异。它做了最少的工作，使 V1 和 V2 的测试都可行。</p><h3 id="1-37-测试用例需要最少数量的-CPU"><a href="#1-37-测试用例需要最少数量的-CPU" class="headerlink" title="1.37 测试用例需要最少数量的 CPU"></a>1.37 测试用例需要最少数量的 CPU</h3><p>一些测试需要超过特定数量的 CPU。它可以用 来定义 <code>.min_cpus = N</code>。</p><h3 id="1-38-测试标签"><a href="#1-38-测试标签" class="headerlink" title="1.38 测试标签"></a>1.38 测试标签</h3><p>测试标签是可以保存任何测试元数据的名称-值对。</p><p>我们对 CVE 条目、主线内核中的 git 提交、稳定内核或 glibc git 存储库提供了额外的支持。如果测试是回归测试，它应该包含这些标签。它们在测试失败时打印出来并导出到文档中。</p><p>CVE、主线和稳定内核 git 在内核错误的回归测试中提交：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>tags <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tst_tag</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"linux-git"</span><span class="token punctuation">,</span> <span class="token string">"9392a27d88b9"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"linux-git"</span><span class="token punctuation">,</span> <span class="token string">"ff002b30181d"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"known-fail"</span><span class="token punctuation">,</span> <span class="token string">"ustat() is known to fail with EINVAL on Btrfs"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"linux-stable-git"</span><span class="token punctuation">,</span> <span class="token string">"c4a23c852e80"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"CVE"</span><span class="token punctuation">,</span> <span class="token string">"2020-29373"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>| </p><p>笔记</p><p> | 我们不会跟踪所有向稳定内核的反向移植，而只跟踪那些特定于稳定分支（唯一）的向后移植，即没有在主线中提交。提交示例：c4a23c852e80、cac68d12c531。 |</p><p>Glibc git commit 在 glibc 错误的回归测试中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>tags <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tst_tag</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"glibc-git"</span><span class="token punctuation">,</span> <span class="token string">"574500a108be"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-39-测试具体架构"><a href="#1-39-测试具体架构" class="headerlink" title="1.39 测试具体架构"></a>1.39 测试具体架构</h3><p>特定架构的测试用例应仅限于仅支持的平台运行，我们现在在 LTP 库中引入一个 .supported_archs 来实现此功能。在预期的 arch 上运行测试所需要做的就是在_struct tst_test中设置__.supported_archs_数组以选择所需的 arch 列表。例如</p><p>.supported_archs = (const char *const []){“x86_64”, “ppc64”, NULL}</p><p>这也有助于将 TCONF 信息从代码移动到 tst_test 元数据。</p><p>并且，我们还导出了一个 struct tst_arch 来保存系统架构，以便在整个测试用例中使用。</p><p>外部常量结构 tst_arch { 字符名称[16]； 枚举 tst_arch_type 类型； } tst_arch；</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>       <span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span>       <span class="token punctuation">.</span>supported_archs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token string">"x86_64"</span><span class="token punctuation">,</span>                 <span class="token string">"ppc64"</span><span class="token punctuation">,</span>                 <span class="token string">"s390x"</span><span class="token punctuation">,</span>                 <span class="token constant">NULL</span>       <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-40-要求测试用例的最小-MemAvailable-大小"><a href="#1-40-要求测试用例的最小-MemAvailable-大小" class="headerlink" title="1.40 要求测试用例的最小 MemAvailable 大小"></a>1.40 要求测试用例的最小 MemAvailable 大小</h3><p>一些测试需要超过特定大小 (MB) 的 MemAvailable。它可以用 来定义<code>.min_mem_avail = N</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog/0.html"/>
      <url>/blog/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="LTP——Linux-测试项目"><a href="#LTP——Linux-测试项目" class="headerlink" title="LTP——Linux 测试项目"></a>LTP——Linux 测试项目</h2><p>Linux 测试项目是由 SGI 发起的联合项目，由 IBM、Cisco、Fujitsu、SUSE、Red Hat 等开发和维护，其目标是向开源社区提供测试套件，以验证可靠性、健壮性和Linux 的稳定性。LTP 测试套件包含一组用于测试 Linux 内核和相关功能的工具。</p><ul><li><a href="https://github.com/linux-test-project/ltp/wiki/Contact-Info">联系信息</a></li></ul><h2 id="开发者角"><a href="#开发者角" class="headerlink" title="开发者角"></a>开发者角</h2><ul><li><a href="https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines">测试写作指南</a></li><li><a href="https://github.com/linux-test-project/ltp/wiki/LTP-Library-API-Writing-Guidelines">LTP 库 API 编写指南</a></li><li><a href="https://github.com/linux-test-project/ltp/wiki/C-Test-Case-Tutorial">C 测试用例教程</a></li><li><a href="https://github.com/linux-test-project/ltp/wiki/Build-System">构建系统</a></li></ul><p>如果有什么没有涵盖，请不要犹豫，在<a href="https://lists.linux.it/listinfo/ltp">LTP 邮件列表</a>上询问。</p><p>尽管我们接受 GitHub 拉取请求，但首选方式是将补丁发送到我们的邮件列表。</p><p>在发布到邮件列表之前，最好先在 GitHub Actions 上测试补丁。我们的 GitHub Actions 设置涵盖各种架构和分布，以确保 LTP 在最常见的配置上干净地编译。对于测试，您只需将更改推送到 GitHub 上您自己的 LTP 分支。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第01课：初识Python</title>
      <link href="/blog/jwnfwvbg.html"/>
      <url>/blog/jwnfwvbg.html</url>
      
        <content type="html"><![CDATA[<h2 id="第01课：初识Python"><a href="#第01课：初识Python" class="headerlink" title="第01课：初识Python"></a>第01课：初识Python</h2><h3 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h3><p>Python是由荷兰人吉多·范罗苏姆（Guido von Rossum）发明的一种编程语言，是目前世界上最受欢迎和拥有最多用户群体的编程语言。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210816232538.png" width="85%"><h4 id="Python的历史"><a href="#Python的历史" class="headerlink" title="Python的历史"></a>Python的历史</h4><ol><li>1989年圣诞节：Guido开始写Python语言的编译器。</li><li>1991年2月：第一个Python解释器诞生，它是用C语言实现的，可以调用C语言的库函数。</li><li>1994年1月：Python 1.0正式发布。</li><li>2000年10月：Python 2.0发布，Python的整个开发过程更加透明，生态圈开始慢慢形成。</li><li>2008年12月：Python 3.0发布，引入了诸多现代编程语言的新特性，但并不完全兼容之前的Python代码。</li><li>2020年1月：在Python 2和Python 3共存了11年之后，官方停止了对Python 2的更新和维护，希望用户尽快过渡到Python 3。</li></ol><blockquote><p><strong>说明</strong>：大多数软件的版本号一般分为三段，形如A.B.C，其中A表示大版本号，当软件整体重写升级或出现不向后兼容的改变时，才会增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。</p></blockquote><h4 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h4><p>Python的优点很多，简单为大家列出几点。</p><ol><li>简单明确，跟其他很多语言相比，Python更容易上手。</li><li>能用更少的代码做更多的事情，提升开发效率。</li><li>开放源代码，拥有强大的社区和生态圈。</li><li>能够做的事情非常多，有极强的适应性。</li><li>能够在Windows、macOS、Linux等各种系统上运行。</li></ol><p>Python最主要的缺点是执行效率低，但是当我们更看重产品的开发效率而不是执行效率的时候，Python就是很好的选择。</p><h4 id="Python的应用领域"><a href="#Python的应用领域" class="headerlink" title="Python的应用领域"></a>Python的应用领域</h4><p>目前Python在Web服务器应用开发、云基础设施开发、<strong>网络数据采集</strong>（爬虫）、<strong>数据分析</strong>、量化交易、<strong>机器学习</strong>、<strong>深度学习</strong>、自动化测试、自动化运维等领域都有用武之地。</p><h3 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h3><p>想要开始你的Python编程之旅，首先得在计算机上安装Python环境，简单的说就是得安装运行Python程序的工具，通常也称之为Python解释器。我们强烈建议大家安装Python 3的环境，很明显它是目前更好的选择。</p><h4 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h4><p>可以在<a href="https://www.python.org/downloads/">Python官方网站</a>找到下载链接并下载Python 3的安装程序。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719222940.png"></p><p>对于Windows操作系统，可以下载“executable installer”。需要注意的是，如果在Windows 7环境下安装Python 3，需要先安装Service Pack 1补丁包，大家可以在Windows的“运行”中输入<code>winver</code>命令，从弹出的窗口上可以看到你的系统是否安装了该补丁包。如果没有该补丁包，一定要先通过“Windows Update”或者类似“CCleaner”这样的工具自动安装该补丁包，安装完成后通常需要重启你的Windows系统，然后再开始安装Python环境。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719222956.png"></p><p>双击运行刚才下载的安装程序，会打开Python环境的安装向导。在执行安装向导的时候，记得勾选“Add Python 3.x to PATH”选项，这个选项会帮助我们将Python的解释器添加到PATH环境变量中（不理解没关系，照做就行），具体的步骤如下图所示。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223007.png"></p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223021.png"></p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223317.png"></p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223332.png"></p><p>安装完成后可以打开Windows的“命令行提示符”工具（或“PowerShell”）并输入<code>python --version</code>或<code>python -V</code>来检查安装是否成功，命令行提示符可以在“运行”中输入<code>cmd</code>来打开或者在“开始菜单”的附件中找到它。如果看了Python解释器对应的版本号（如：Python 3.7.8），说明你的安装已经成功了，如下图所示。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223350.png"></p><blockquote><p><strong>说明</strong>：如果安装过程显示安装失败或执行上面的命令报错，很有可能是因为你的Windows系统缺失了一些动态链接库文件或C构建工具导致的问题。可以在<a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=48145">微软官网</a>下载Visual C++ Redistributable for Visual Studio 2015文件进行修复，64位的系统需要下载有x64标记的安装文件。也可以通过下面的百度云盘地址获取修复工具，运行修复工具，按照如下图所示的方式进行修复，链接: <a href="https://pan.baidu.com/s/1iNDnU5UVdDX5sKFqsiDg5Q">https://pan.baidu.com/s/1iNDnU5UVdDX5sKFqsiDg5Q</a> 提取码: cjs3。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210816234614.png" alt="QQ20210711-0"></p></blockquote><p>除此之外，你还应该检查一下Python的包管理工具是否已经可用，对应的命令是<code>pip --version</code>。</p><h4 id="macOS环境"><a href="#macOS环境" class="headerlink" title="macOS环境"></a>macOS环境</h4><p>macOS自带了Python 2，但是我们需要安装和使用的是Python 3。可以通过Python官方网站提供的<a href="https://www.python.org/downloads/release/python-376/">下载链接</a>找到适合macOS的“macOS installer”来安装Python 3，安装过程基本不需要做任何勾选，直接点击“下一步”即可。安装完成后，可以在macOS的“终端”工具中输入<code>python3</code>命令来调用Python 3解释器，因为如果直接输入<code>python</code>，将会调用Python 2的解释器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Python语言可以做很多的事情，也值得我们去学习。要使用Python语言，首先需要在自己的计算机上安装Python环境，也就是运行Python程序的Python解释器。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第02课：第一个Python程序</title>
      <link href="/blog/8somx7oj.html"/>
      <url>/blog/8somx7oj.html</url>
      
        <content type="html"><![CDATA[<h2 id="第02课：第一个Python程序"><a href="#第02课：第一个Python程序" class="headerlink" title="第02课：第一个Python程序"></a>第02课：第一个Python程序</h2><p>在上一课中，我们已经了解了Python语言并安装了运行Python程序所需的环境，相信大家已经迫不及待的想开始自己的Python编程之旅了。首先我们来看看应该在哪里编写我们的Python程序。</p><h3 id="编写代码的工具"><a href="#编写代码的工具" class="headerlink" title="编写代码的工具"></a>编写代码的工具</h3><h4 id="交互式环境"><a href="#交互式环境" class="headerlink" title="交互式环境"></a>交互式环境</h4><p>我们打开Windows的“命令提示符”工具，输入命令<code>python</code>然后回车就可以进入到Python的交互式环境中。所谓交互式环境，就是我们输入一行代码回车，代码马上会被执行，如果代码有产出结果，那么结果会被显示在窗口中。例如：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">Python 3.7.6Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 2 * 36&gt;&gt;&gt; 2 + 35<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：使用macOS系统的用户需要打开“终端”工具，输入<code>python3</code>进入交互式环境。</p></blockquote><p>如果希望退出交互式环境，可以在交互式环境中输入<code>quit()</code>，如下所示。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">&gt;&gt;&gt; quit()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="更好的交互式环境-IPython"><a href="#更好的交互式环境-IPython" class="headerlink" title="更好的交互式环境 - IPython"></a>更好的交互式环境 - IPython</h4><p>Python默认的交互式环境用户体验并不怎么好，我们可以用IPython来替换掉它，因为IPython提供了更为强大的编辑和交互功能。我们可以使用Python的包管理工具<code>pip</code>来安装IPython，如下所示。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> ipython<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>温馨提示</strong>：在使用上面的命令安装IPython之前，可以先通过<code>pip config set global.index-url https://pypi.doubanio.com/simple</code>命令将<code>pip</code>的下载源修改为国内的豆瓣网，否则下载安装的过程可能会非常的缓慢。</p></blockquote><p>可以使用下面的命令启动IPython，进入交互式环境。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipython<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="文本编辑器-Visual-Studio-Code"><a href="#文本编辑器-Visual-Studio-Code" class="headerlink" title="文本编辑器 - Visual Studio Code"></a>文本编辑器 - Visual Studio Code</h4><p>Visual Studio Code（通常简称为VSCode）是一个由微软开发能够在Windows、 Linux和macOS等操作系统上运行的代码编辑神器。它支持语法高亮、自动补全、多点编辑、运行调试等一系列便捷功能，而且能够支持多种编程语言。如果大家要选择一款高级文本编辑工具，强烈建议使用VSCode。关于VSCode的<a href="https://code.visualstudio.com/">下载</a>、安装和使用，推荐大家阅读一篇名为<a href="https://zhuanlan.zhihu.com/p/106357123">《VScode安装使用》</a>的文章。</p><h4 id="集成开发环境-PyCharm"><a href="#集成开发环境-PyCharm" class="headerlink" title="集成开发环境 - PyCharm"></a>集成开发环境 - PyCharm</h4><p>如果用Python开发商业项目，我们推荐大家使用更为专业的工具PyCharm。PyCharm是由捷克一家名为<a href="https://www.jetbrains.com/">JetBrains</a>的公司开发的用于Python项目开发的集成开发环境（IDE)。所谓集成开发环境，通常是指工具中提供了编写代码、运行代码、调试代码、分析代码、版本控制等一系列功能，因此特别适合商业项目的开发。在JetBrains的官方网站上提供了PyCharm的<a href="https://www.jetbrains.com/pycharm/download">下载链接</a>，其中社区版（Community）是免费的但功能相对弱小（其实已经足够强大了），专业版（Professional）功能非常强大，但需要按年或月付费使用，新用户可以试用30天时间。</p><p>运行PyCharm，可以看到如下图所示的欢迎界面，可以选择“New Project”来创建一个新的项目。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210720102203.png" width="80%"><p>创建项目的时候需要指定项目的路径并创建运行项目的”虚拟环境“，如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210720102822.png" width="80%"><p>项目创建好以后会出现如下图所示的画面，我们可以通过在项目文件夹上点击鼠标右键，选择“New”菜单下的“Python File”来创建一个Python文件，创建好的Python文件会自动打开进入可编辑的状态。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210720133621.png" alt="image-20210720133621079"></p><p>写好代码后，可以在编辑代码的窗口点击鼠标右键，选择“Run”菜单项来运行代码，下面的“Run”窗口会显示代码的执行结果，如下图所示。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210720134039.png" alt="image-20210720134039848"></p><p>PyCharm常用的快捷键如下表所示，我们也可以在“File”菜单的“Settings”中定制PyCharm的快捷键（macOS系统是在“PyCharm”菜单的“Preferences”中对快捷键进行设置）。</p><p>表1. PyCharm常用快捷键。</p><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td><code>ctrl + j</code></td><td>显示可用的代码模板</td></tr><tr><td><code>ctrl + b</code></td><td>查看函数、类、方法的定义</td></tr><tr><td><code>ctrl + alt + l</code></td><td>格式化代码</td></tr><tr><td><code>alt + enter</code></td><td>万能代码修复快捷键</td></tr><tr><td><code>ctrl + /</code></td><td>注释/反注释代码</td></tr><tr><td><code>shift + shift</code></td><td>万能搜索快捷键</td></tr><tr><td><code>ctrl + d</code> / <code>ctrl + y</code></td><td>复制/删除一行代码</td></tr><tr><td><code>ctrl + shift + -</code> / <code>ctrl + shift + +</code></td><td>折叠/展开所有代码</td></tr><tr><td><code>F2</code></td><td>快速定位到错误代码</td></tr><tr><td><code>ctrl + alt + F7</code></td><td>查看哪些地方用到了指定的函数、类、方法</td></tr></tbody></table><blockquote><p><strong>说明</strong>：使用macOS系统，可以将上面的<code>ctrl</code>键换成<code>command</code>键，在macOS系统上，可以使用<code>ctrl + space</code>组合键来获得万能提示，在Windows系统上不能使用该快捷键，因为它跟Windows默认的切换输入法的快捷键是冲突的，需要重新设置。</p></blockquote><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello, world"></a>hello, world</h3><p>按照行业惯例，我们学习任何一门编程语言写的第一个程序都是输出<code>hello, world</code>，因为这段代码是伟大的丹尼斯·里奇（C语言之父，和肯·汤普森一起开发了Unix操作系统）和布莱恩·柯尼汉（awk语言的发明者）在他们的不朽著作<em>The C Programming Language</em>中写的第一段代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">print('hello, world')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>如果不使用PyCharm这样的集成开发环境，我们可以将上面的代码命名为<code>hello.py</code>，对于Windows操作系统，可以在你保存代码的目录下先按住键盘上的<code>shift</code>键再点击鼠标右键，这时候鼠标右键菜单中会出现“命令提示符”选项，点击该选项就可以打开“命令提示符”工具，我们输入下面的命令。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">python hello.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>提醒</strong>：我们也可以在任意位置打开“命令提示符”，然后将需要执行的Python代码通过拖拽的方式拖入到“命令提示符”中，这样相当于指定了文件的绝对路径来运行该文件中的Python代码。再次提醒，macOS系统要通过<code>python3</code>命令来运行该程序。</p></blockquote><p>你可以尝试将上面程序单引号中的<code>hello, world</code>换成其他内容；你也可以尝试着多写几个这样的语句，看看会运行出怎样的结果。需要提醒大家，上面代码中的<code>print('hello, world')</code>就是一条完整的语句，我们用Python写程序，最好每一行代码中只有一条语句。虽然使用<code>;</code>分隔符可以将多个语句写在一行代码中，但是最好不要这样做，因为代码会变得非常难看。</p><h3 id="注释你的代码"><a href="#注释你的代码" class="headerlink" title="注释你的代码"></a>注释你的代码</h3><p>注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性。当然，我们也可以将源代码中暂时不需要运行的代码段通过注释来去掉，这样当你需要重新使用这些代码的时候，去掉注释符号就可以了。简单的说，<strong>注释会让代码更容易看懂但不会影响程序的执行结果</strong>。</p><p>Python中有两种形式的注释：</p><ol><li>单行注释：以<code>#</code>和空格开头，可以注释掉从<code>#</code>开始后面一整行的内容。</li><li>多行注释：三个引号开头，三个引号结尾，通常用于添加多行说明性内容。</li></ol><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""第一个Python程序 - hello, worldVersion: 0.1Author: 骆昊"""# print('hello, world')print("你好，世界！")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，我们已经把第一个Python程序运行起来了，是不是很有成就感？只要你坚持学习下去，再过一段时间，我们就可以用Python制作小游戏、编写爬虫程序、完成办公自动化操作等。<strong>写程序本身就是一件很酷的事情</strong>，在未来编程就像英语一样，<strong>对很多人来说或都是必须要掌握的技能</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第03课：Python语言元素之变量</title>
      <link href="/blog/xpb0qasg.html"/>
      <url>/blog/xpb0qasg.html</url>
      
        <content type="html"><![CDATA[<h2 id="第03课：Python语言元素之变量"><a href="#第03课：Python语言元素之变量" class="headerlink" title="第03课：Python语言元素之变量"></a>第03课：Python语言元素之变量</h2><p>作为一个程序员，可能经常会被外行问到两个问题，其一是“什么是（计算机）程序”，其二是“写（计算机）程序能做什么”，这里我先对这两个问题做一个回答。<strong>程序是指令的集合</strong>，<strong>写程序就是用指令控制计算机做我们想让它做的事情</strong>。那么，为什么要用Python语言来写程序呢？因为<strong>Python语言简单优雅</strong>，相比C、C++、Java这样的编程语言，<strong>Python对初学者更加友好</strong>，当然这并不是说Python不像其他语言那样强大，<strong>Python几乎是无所不能的</strong>，在第一节课的时候，我们就说到了Python可以用于服务器程序开发、云平台开发、数据分析、机器学习等各个领域。当然，Python语言还可以用来粘合其他语言开发的系统，所以也经常被戏称为“<strong>胶水语言</strong>”。</p><h3 id="一些计算机常识"><a href="#一些计算机常识" class="headerlink" title="一些计算机常识"></a>一些计算机常识</h3><p>在开始系统的学习编程之前，我们先来科普一些计算机的基础知识。计算机的硬件系统通常由五大部件构成，包括：<strong>运算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入设备</strong>和<strong>输出设备</strong>。其中，运算器和控制器放在一起就是我们常说的<strong>中央处理器</strong>，它的功能是执行各种运算和控制指令。刚才我们提到过程序是指令的集合，写程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。目前，我们使用的计算机基本都是“冯·诺依曼体系结构”的计算机，这种计算机有两个关键点：一是要将<strong>存储设备与中央处理器分开</strong>；二是将<strong>数据以二进制方式编码</strong>。</p><p>二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法本质是一样的。人类因为有十根手指所以使用了十进制，因为在计数时十根手指用完之后就只能用进位的方式来表示更大的数值。当然凡事都有例外，玛雅人可能是因为长年光着脚的原因，把脚趾头也都用上了，于是他们使用了二十进制的计数法。在这种计数法的指导下，玛雅人的历法就与我们平常使用的历法并不相同。按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“的荒诞说法。今天很多人都在猜测，玛雅文明之所以发展缓慢跟使用了二十进制是有关系的。对于计算机来说，二进制在物理器件上最容易实现的，因为可以用高电压表示1，用低电压表示0。不是所有写程序的人都需要知道十进制与二进制如何转换，大多数时候我们即便不了解这些知识也能写出程序，但是我们必须要知道<strong>计算机是使用二进制计数的</strong>，不管什么<strong>数据到了计算机内存中都是以二进制形式存在的</strong>。</p><h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><p>要想在计算机内存中保存数据，首先就得说一说变量这个概念。在编程语言中，<strong>变量是数据的载体</strong>，简单的说就是一块用来保存数据的内存空间，<strong>变量的值可以被读取和修改</strong>，这是所有计算和控制的基础。计算机能处理的数据有很多种类型，最常见的就是数值，除了数值之外还有文本、图形、音频、视频等各种各样的数据。虽然数据在计算机中都是以二进制形态存在的，但是我们可以用不同类型的变量来表示数据类型的差异。<strong>Python中的数据类型很多</strong>，而且也<strong>允许我们自定义新的数据类型</strong>（这一点在后面会讲到），这里我们需要先了解几种常用的数据类型。</p><ul><li>整型（<code>int</code>）：Python中可以处理任意大小的整数，而且支持二进制（如<code>0b100</code>，换算成十进制是4）、八进制（如<code>0o100</code>，换算成十进制是64）、十进制（<code>100</code>）和十六进制（<code>0x100</code>，换算成十进制是256）的表示法。</li><li>浮点型（<code>float</code>）：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如<code>123.456</code>）之外还支持科学计数法（如<code>1.23456e2</code>）。</li><li>字符串型（<code>str</code>）：字符串是以单引号或双引号括起来的任意文本，比如<code>'hello'</code>和<code>"hello"</code>。</li><li>布尔型（<code>bool</code>）：布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>。</li></ul><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>对于每个变量我们需要给它取一个名字，就如同我们每个人都有自己的名字一样。在Python中，变量命名需要遵循以下这些规则，这些规则又分为必须遵守的硬性规则和建议遵守的非硬性规则。</p><ul><li>硬性规则：<ul><li>规则1：变量名由<strong>字母</strong>、数字和<strong>下划线</strong>构成，数字不能开头。需要说明的是，这里说的字母指的是Unicode字符，Unicode称为万国码，囊括了世界上大部分的文字系统，这也就意味着中文、日文、希腊字母等都可以作为变量名中的字符，但是像<code>!</code>、<code>@</code>、<code>#</code>这些特殊字符是不能出现在变量名中的，而且我们强烈建议大家<strong>尽可能使用英文字母</strong>。</li><li>规则2：<strong>大小写敏感</strong>，简单的说就是大写的<code>A</code>和小写的<code>a</code>是两个不同的变量。</li><li>规则3：变量名<strong>不要跟Python语言的关键字</strong>（有特殊含义的单词，后面会讲到）和<strong>保留字</strong>（如已有的函数、模块等的名字）<strong>发生重名的冲突</strong>。</li></ul></li><li>非硬性规则：<ul><li>规则1：变量名通常使用小写英文字母，多个单词用下划线进行连接。</li><li>规则2：受保护的变量用单个下划线开头。</li><li>规则3：私有的变量用两个下划线开头。</li></ul></li></ul><p>规则2和规则3大家暂时不用理解，后面自然会明白的。当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到<strong>见名知意</strong>也非常重要。</p><h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p>下面通过例子来说明变量的类型和变量的使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""使用变量保存数据并进行加减乘除运算Version: 0.1Author: 骆昊"""a = 45          # 变量a保存了45b = 12          # 变量b保存了12print(a + b)    # 57print(a - b)    # 33print(a * b)    # 540print(a / b)    # 3.75<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Python中可以使用<code>type</code>函数对变量的类型进行检查。程序设计中函数的概念跟数学上函数的概念基本一致，数学上的函数相信大家并不陌生，它包括了函数名、自变量和因变量。如果暂时不理解函数这个概念也不要紧，我们会在后续的内容中专门讲解函数的定义和使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""使用type()检查变量的类型Version: 0.1Author: 骆昊"""a = 100b = 12.345c = 'hello, world'd = Trueprint(type(a))    # &lt;class 'int'&gt;print(type(b))    # &lt;class 'float'&gt;print(type(c))    # &lt;class 'str'&gt;print(type(d))    # &lt;class 'bool'&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同类型的变量可以相互转换，这一点可以通过Python的内置函数来实现。</p><ul><li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li><li><code>float()</code>：将一个字符串转换成浮点数。</li><li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li><li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li><li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。</li></ul><p>下面的例子为大家演示了Python中类型转换的操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""Python中的类型转换操作Version: 0.1Author: 骆昊"""a = 100b = 12.345c = 'hello, world'd = True# 整数转成浮点数print(float(a))    # 100.0# 浮点型转成字符串 (输出字符串时不会看到引号哟)print(str(b))      # 12.345# 字符串转成布尔型 (有内容的字符串都会变成True)print(bool(c))     # True# 布尔型转成整数 (True会转成1，False会转成0)print(int(d))      # 1# 将整数变成对应的字符 (97刚好对应字符表中的字母a)print(chr(97))     # a# 将字符转成整数 (Python中字符和字符串表示法相同)print(ord('a'))    # 97<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Python程序中，我们可以<strong>使用变量来保存数据</strong>，<strong>变量有不同的类型</strong>，<strong>变量可以做运算</strong>（下一课会有详细的讲解），<strong>也可以通过内置函数来转换变量类型</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第04课：Python语言元素之运算符</title>
      <link href="/blog/3jfmvjyt.html"/>
      <url>/blog/3jfmvjyt.html</url>
      
        <content type="html"><![CDATA[<h2 id="第04课：Python语言元素之运算符"><a href="#第04课：Python语言元素之运算符" class="headerlink" title="第04课：Python语言元素之运算符"></a>第04课：Python语言元素之运算符</h2><p>Python语言支持很多种运算符，我们先用一个表格为大家列出这些运算符，然后选择一些马上就会用到的运算符为大家进行讲解。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>[]</code> <code>[:]</code></td><td>下标，切片</td></tr><tr><td><code>**</code></td><td>指数</td></tr><tr><td><code>~</code> <code>+</code> <code>-</code></td><td>按位取反, 正负号</td></tr><tr><td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td>乘，除，模，整除</td></tr><tr><td><code>+</code> <code>-</code></td><td>加，减</td></tr><tr><td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td><td>右移，左移</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code> <code>|</code></td><td>按位异或，按位或</td></tr><tr><td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr><tr><td><code>==</code> <code>!=</code></td><td>等于，不等于</td></tr><tr><td><code>is</code>  <code>is not</code></td><td>身份运算符</td></tr><tr><td><code>in</code> <code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr><tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code></td><td>（复合）赋值运算符</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 上面这个表格实际上是按照运算符的优先级从上到下列出了各种运算符。所谓优先级就是在一个运算的表达式中，如果出现了多个运算符，应该先执行哪个运算再执行哪个运算的顺序。在实际开发中，如果搞不清楚运算符的优先级，可以使用圆括号来确保运算的执行顺序。</p></blockquote><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>Python中的算术运算符非常丰富，除了大家最为熟悉的加减乘除之外，还有整除运算符、求模（求余数）运算符和求幂运算符。下面的例子为大家展示了算术运算符的使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""算术运算符Version: 0.1Author: 骆昊"""print(321 + 123)     # 加法运算print(321 - 123)     # 减法运算print(321 * 123)     # 乘法运算print(321 / 123)     # 除法运算print(321 % 123)     # 求模运算print(321 // 123)    # 整除运算print(321 ** 123)    # 求幂运算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。下面的例子演示了赋值运算符和复合赋值运算符的使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""赋值运算符和复合赋值运算符Version: 0.1Author: 骆昊"""a = 10b = 3a += b        # 相当于：a = a + ba *= a + 2    # 相当于：a = a * (a + 2)print(a)      # 算一下这里会输出什么<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>###比较运算符和逻辑运算符</p><p>比较运算符有的地方也称为关系运算符，包括<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>，我相信没有什么好解释的，大家一看就能懂，需要提醒的是比较相等用的是<code>==</code>，请注意这里是两个等号，因为<code>=</code>是赋值运算符，我们在上面刚刚讲到过，<code>==</code>才是比较相等的运算符；比较不相等用的是<code>!=</code>，这不同于数学上的不等号，Python 2中曾经使用过<code>&lt;&gt;</code>来表示不等关系，大家知道就可以了。比较运算符会产生布尔值，要么是<code>True</code>要么是<code>False</code>。</p><p>逻辑运算符有三个，分别是<code>and</code>、<code>or</code>和<code>not</code>。<code>and</code>字面意思是“而且”，所以<code>and</code>运算符会连接两个布尔值，如果两个布尔值都是<code>True</code>，那么运算的结果就是<code>True</code>；左右两边的布尔值有一个是<code>False</code>，最终的运算结果就是<code>False</code>。相信大家已经想到了，如果<code>and</code>左边的布尔值是<code>False</code>，不管右边的布尔值是什么，最终的结果都是<code>False</code>，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在<code>and</code>运算符左边为<code>False</code>的情况下，右边的表达式根本不会执行。<code>or</code>字面意思是“或者”，所以<code>or</code>运算符也会连接两个布尔值，如果两个布尔值有任意一个是<code>True</code>，那么最终的结果就是<code>True</code>。当然，<code>or</code>运算符也是有短路功能的，在它左边的布尔值为<code>True</code>的情况下，右边的表达式根本不会执行。<code>not</code>运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，<code>not</code>后面的布尔值如果是<code>True</code>，运算结果就是<code>False</code>；而<code>not</code>后面的布尔值如果是<code>False</code>，运算结果就是<code>True</code>。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""比较运算符和逻辑运算符的使用Version: 0.1Author: 骆昊"""flag0 = 1 == 1flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not (1 != 2)print('flag0 =', flag0)    # flag0 = Trueprint('flag1 =', flag1)    # flag1 = Trueprint('flag2 =', flag2)    # flag2 = Falseprint('flag3 =', flag3)    # flag3 = Falseprint('flag4 =', flag4)    # flag4 = Trueprint('flag5 =', flag5)    # flag5 = False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：比较运算符的优先级高于赋值运算符，所以<code>flag0 = 1 == 1</code>先做<code>1 == 1</code>产生布尔值<code>True</code>，再将这个值赋值给变量<code>flag0</code>。<code>print</code>函数可以输出多个值，多个值之间可以用<code>,</code>进行分隔，输出的内容之间默认以空格分开。</p></blockquote><h3 id="运算符的例子"><a href="#运算符的例子" class="headerlink" title="运算符的例子"></a>运算符的例子</h3><h4 id="例子1：华氏温度转换为摄氏温度。"><a href="#例子1：华氏温度转换为摄氏温度。" class="headerlink" title="例子1：华氏温度转换为摄氏温度。"></a>例子1：华氏温度转换为摄氏温度。</h4><blockquote><p><strong>提示</strong>：华氏温度到摄氏温度的转换公式为：<code>C = (F - 32) / 1.8</code>。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""将华氏温度转换为摄氏温度Version: 0.1Author: 骆昊"""f = float(input('请输入华氏温度: '))c = (f - 32) / 1.8print('%.1f华氏度 = %.1f摄氏度' % (f, c))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：在使用<code>print</code>函数输出时，也可以对字符串内容进行格式化处理，上面<code>print</code>函数中的字符串<code>%.1f</code>是一个占位符，稍后会由一个<code>float</code>类型的变量值替换掉它。同理，如果字符串中有<code>%d</code>，后面可以用一个<code>int</code>类型的变量值替换掉它，而<code>%s</code>会被字符串的值替换掉。除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中<code>{f:.1f}</code>和<code>{c:.1f}</code>可以先看成是<code>{f}</code>和<code>{c}</code>，表示输出时会用变量<code>f</code>和变量<code>c</code>的值替换掉这两个占位符，后面的<code>:.1f</code>表示这是一个浮点数，小数点后保留1位有效数字。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">print(f'{f:.1f}华氏度 = {c:.1f}摄氏度')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h4 id="例子2：输入圆的半径计算计算周长和面积。"><a href="#例子2：输入圆的半径计算计算周长和面积。" class="headerlink" title="例子2：输入圆的半径计算计算周长和面积。"></a>例子2：输入圆的半径计算计算周长和面积。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入半径计算圆的周长和面积Version: 0.1Author: 骆昊"""radius = float(input('请输入圆的半径: '))perimeter = 2 * 3.1416 * radiusarea = 3.1416 * radius * radiusprint('周长: %.2f' % perimeter)print('面积: %.2f' % area)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子3：输入年份判断是不是闰年。"><a href="#例子3：输入年份判断是不是闰年。" class="headerlink" title="例子3：输入年份判断是不是闰年。"></a>例子3：输入年份判断是不是闰年。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入年份 如果是闰年输出True 否则输出FalseVersion: 0.1Author: 骆昊"""year = int(input('请输入年份: '))is_leap = year % 4 == 0 and year % 100 != 0 or year % 400 == 0print(is_leap)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：比较运算符会产生布尔值，而逻辑运算符<code>and</code>和<code>or</code>会对这些布尔值进行组合，最终也是得到一个布尔值，闰年输出<code>True</code>，平年输出<code>False</code>。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的例子相信大家感受到了，学会使用运算符以及由运算符构成的表达式，就可以帮助我们解决很多实际的问题，<strong>运算符和表达式对于任何一门编程语言都是非常重要的</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第05课：分支结构</title>
      <link href="/blog/yrv4htq8.html"/>
      <url>/blog/yrv4htq8.html</url>
      
        <content type="html"><![CDATA[<h2 id="第05课：分支结构"><a href="#第05课：分支结构" class="headerlink" title="第05课：分支结构"></a>第05课：分支结构</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种代码结构通常称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后，我们要根据玩家得到分数来决定究竟是进入第二关，还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行。类似的场景还有很多，我们将这种结构称之为“分支结构”或“选择结构”。给大家一分钟的时间，你应该可以想到至少5个以上这样的例子，赶紧试一试。</p><h3 id="if语句的使用"><a href="#if语句的使用" class="headerlink" title="if语句的使用"></a>if语句的使用</h3><p>在Python中，要构造分支结构可以使用<code>if</code>、<code>elif</code>和<code>else</code>关键字。所谓<strong>关键字</strong>就是有特殊含义的单词，像<code>if</code>和<code>else</code>就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名。下面的例子中演示了如何构造一个分支结构。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""用户身份验证Version: 0.1Author: 骆昊"""username = input('请输入用户名: ')password = input('请输入口令: ')# 用户名是admin且密码是123456则身份验证成功否则身份验证失败if username == 'admin' and password == '123456':    print('身份验证成功!')else:    print('身份验证失败!')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的是，不同于C++、Java等编程语言，Python中没有用花括号来构造代码块而是<strong>使用了缩进的方式来表示代码的层次结构</strong>，如果<code>if</code>条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了。换句话说<strong>连续的代码如果又保持了相同的缩进那么它们属于同一个代码块</strong>，相当于是一个执行的整体。<strong>缩进</strong>可以使用任意数量的空格，但<strong>通常使用4个空格</strong>，强烈建议大家<strong>不要使用制表键来缩进代码</strong>，如果你已经习惯了这么做，可以<strong>设置代码编辑工具将1个制表键自动变成4个空格</strong>，很多的代码编辑工具都支持这项功能。</p><blockquote><p><strong>提示</strong>：<code>if</code>和<code>else</code> 的最后面有一个<code>:</code>，它是用英文输入法输入的冒号；程序中输入的<code>'</code>、<code>"</code>、<code>=</code>、<code>(</code>、<code>)</code>等特殊字符，都是在英文输入法状态下输入的。有很多初学者经常不注意这一点，结果运行代码的时候就会遇到很多莫名其妙的错误提示。<strong>强烈建议</strong>大家在写代码的时候都<strong>打开英文输入法</strong>（注意是英文输入法而不是中文输入法的英文输入模式），这样可以避免很多不必要的麻烦。</p></blockquote><p>如果要构造出更多的分支，可以使用<code>if...elif...else...</code>结构或者嵌套的<code>if...else...</code>结构，下面的代码演示了如何利用多分支结构实现分段函数求值。</p><p>$$<br>f(x) = \begin{cases} 3x - 5, &amp; (x \gt 1) \ x + 2, &amp; (-1 \le x \le 1) \ 5x + 3, &amp; (x \lt -1) \end{cases}<br>$$</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""分段函数求值Version: 0.1Author: 骆昊"""x = float(input('x = '))if x &gt; 1:    y = 3 * x - 5elif x &gt;= -1:    y = x + 2else:    y = 5 * x + 3print(f'f({x}) = {y}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在<code>if</code>的内部构造出一个新的分支结构，同理<code>elif</code>和<code>else</code>中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""分段函数求值Version: 0.1Author: 骆昊"""x = float(input('x = '))if x &gt; 1:    y = 3 * x - 5else:    if x &gt;= -1:        y = x + 2    else:        y = 5 * x + 3print(f'f({x}) = {y}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明：</strong> 大家可以自己感受和评判一下这两种写法到底是哪一种更好。在<a href="https://zhuanlan.zhihu.com/p/111843067"><strong>Python之禅</strong></a>中有这么一句话：“<strong>Flat is better than nested</strong>”，之所以提倡代码“扁平化”，是因为代码嵌套的层次如果很多，会严重的影响代码的可读性，所以使用更为扁平化的结构在很多场景下都是较好的选择。</p></blockquote><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><h4 id="例子1：英制单位英寸与公制单位厘米互换。"><a href="#例子1：英制单位英寸与公制单位厘米互换。" class="headerlink" title="例子1：英制单位英寸与公制单位厘米互换。"></a>例子1：英制单位英寸与公制单位厘米互换。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""英制单位英寸和公制单位厘米互换Version: 0.1Author: 骆昊"""value = float(input('请输入长度: '))unit = input('请输入单位: ')if unit == 'in' or unit == '英寸':    print('%f英寸 = %f厘米' % (value, value * 2.54))elif unit == 'cm' or unit == '厘米':    print('%f厘米 = %f英寸' % (value, value / 2.54))else:    print('请输入有效的单位')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子2：百分制成绩转换为等级制成绩。"><a href="#例子2：百分制成绩转换为等级制成绩。" class="headerlink" title="例子2：百分制成绩转换为等级制成绩。"></a>例子2：百分制成绩转换为等级制成绩。</h4><blockquote><p><strong>要求</strong>：如果输入的成绩在90分以上（含90分）输出A；80分-90分（不含90分）输出B；70分-80分（不含80分）输出C；60分-70分（不含70分）输出D；60分以下输出E。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""百分制成绩转换为等级制成绩Version: 0.1Author: 骆昊"""score = float(input('请输入成绩: '))if score &gt;= 90:    grade = 'A'elif score &gt;= 80:    grade = 'B'elif score &gt;= 70:    grade = 'C'elif score &gt;= 60:    grade = 'D'else:    grade = 'E'print('对应的等级是:', grade)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子3：输入三条边长，如果能构成三角形就计算周长和面积。"><a href="#例子3：输入三条边长，如果能构成三角形就计算周长和面积。" class="headerlink" title="例子3：输入三条边长，如果能构成三角形就计算周长和面积。"></a>例子3：输入三条边长，如果能构成三角形就计算周长和面积。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""判断输入的边长能否构成三角形，如果能则计算出三角形的周长和面积Version: 0.1Author: 骆昊"""a = float(input('a = '))b = float(input('b = '))c = float(input('c = '))if a + b &gt; c and a + c &gt; b and b + c &gt; a:    peri = a + b + c    print(f'周长: {peri}')    half = peri / 2    area = (half * (half - a) * (half - b) * (half - c)) ** 0.5    print(f'面积: {area}')else:    print('不能构成三角形')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明：</strong> 上面通过边长计算三角形面积的公式叫做<a href="https://zh.wikipedia.org/zh-hans/%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F">海伦公式</a>。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>学会了Python中的分支结构和循环结构，我们就可以用Python程序来解决很多实际的问题了。这一节课相信已经帮助大家记住了<code>if</code>、<code>elif</code>、<code>else</code>这几个关键字以及如何使用它们来构造分支结构，下一节课我们为大家介绍循环结构，学完这两次课你一定会发现，你能写出很多很多非常有意思的代码。继续加油！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第06课：循环结构</title>
      <link href="/blog/smrtkrdm.html"/>
      <url>/blog/smrtkrdm.html</url>
      
        <content type="html"><![CDATA[<h2 id="第06课：循环结构"><a href="#第06课：循环结构" class="headerlink" title="第06课：循环结构"></a>第06课：循环结构</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>我们在写程序的时候，一定会遇到需要重复执行某条指令或某些指令的场景。例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向移动的指令。在这个场景中，让机器人向球门方向移动就是一个需要重复的动作，当然这里还会用到上一课讲的分支结构来判断机器人是否持球以及是否进入射门范围。再举一个简单的例子，如果要实现每隔1秒中在屏幕上打印一次“hello, world”并持续打印一个小时，我们肯定不能够直接把<code>print('hello, world')</code>这句代码写3600遍，这里我们需要构造循环结构。</p><p>所谓循环结构，就是程序中控制某条或某些指令重复执行的结构。在Python中构造循环结构有两种做法，一种是<code>for-in</code>循环，另一种是<code>while</code>循环。</p><h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h3><p>如果明确的知道循环执行的次数，我们推荐使用<code>for-in</code>循环，例如输出100行的”hello, world“。 被<code>for-in</code>循环控制的语句块也是通过缩进的方式来构造的，这一点跟分支结构完全相同，大家看看下面的代码就明白了。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""用for循环实现1~100求和Version: 0.1Author: 骆昊"""total = 0for x in range(1, 101):    total += xprint(total)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的是上面代码中的<code>range(1, 101)</code>可以用来构造一个从<code>1</code>到<code>100</code>的范围，当我们把这样一个范围放到<code>for-in</code>循环中，就可以通过前面的循环变量<code>x</code>依次取出从<code>1</code>到<code>100</code>的整数。当然，<code>range</code>的用法非常灵活，下面给出了一个例子：</p><ul><li><code>range(101)</code>：可以用来产生0到100范围的整数，需要注意的是取不到101。</li><li><code>range(1, 101)</code>：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。</li><li><code>range(1, 101, 2)</code>：可以用来产生1到100的奇数，其中2是步长，即每次递增的值。</li><li><code>range(100, 0, -2)</code>：可以用来产生100到1的偶数，其中-2是步长，即每次递减的值。</li></ul><p>知道了这一点，我们可以用下面的代码来实现1~100之间的偶数求和。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""用for循环实现1~100之间的偶数求和Version: 0.1Author: 骆昊"""total = 0for x in range(2, 101, 2):    total += xprint(total)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>如果要构造不知道具体循环次数的循环结构，我们推荐使用<code>while</code>循环。<code>while</code>循环通过一个能够产生<code>bool</code>值的表达式来控制循环，当表达式的值为<code>True</code>时则继续循环，当表达式的值为<code>False</code>时则结束循环。</p><p>下面我们通过一个“猜数字”的小游戏来看看如何使用<code>while</code>循环。猜数字游戏的规则是：计算机出一个<code>1</code>到<code>100</code>之间的随机数，玩家输入自己猜的数字，计算机给出对应的提示信息（大一点、小一点或猜对了），如果玩家猜中了数字，计算机提示用户一共猜了多少次，游戏结束，否则游戏继续。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""猜数字游戏Version: 0.1Author: 骆昊"""import random# 产生一个1-100范围的随机数answer = random.randint(1, 100)counter = 0while True:    counter += 1    number = int(input('请输入: '))    if number &lt; answer:        print('大一点')    elif number &gt; answer:        print('小一点')    else:        print('恭喜你猜对了!')        break# 当退出while循环的时候显示用户一共猜了多少次print(f'你总共猜了{counter}次')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>上面的代码中使用<code>while True</code>构造了一个条件恒成立的循环，也就意味着如果不做特殊处理，循环是不会结束的，这也就是常说的“死循环”。为了在用户猜中数字时能够退出循环结构，我们使用了<code>break</code>关键字，它的作用是提前结束循环。需要注意的是，<code>break</code>只能终止它所在的那个循环，这一点在使用嵌套循环结构时需要引起注意，下面的例子我们会讲到什么是嵌套的循环结构。除了<code>break</code>之外，还有另一个关键字是<code>continue</code>，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。</p><h3 id="嵌套的循环结构"><a href="#嵌套的循环结构" class="headerlink" title="嵌套的循环结构"></a>嵌套的循环结构</h3><p>和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个乘法口诀表（九九表）。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""打印乘法口诀表Version: 0.1Author: 骆昊"""for i in range(1, 10):    for j in range(1, i + 1):        print(f'{i}*{j}={i * j}', end='\t')    print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很显然，在上面的代码中，外层循环用来控制一共会产生<code>9</code>行的输出，而内层循环用来控制每一行会输出多少列。内层循环中的输出就是九九表一行中的所有列，所以在内层循环完成时，有一个<code>print()</code>来实现换行输出的效果。</p><h3 id="循环的例子"><a href="#循环的例子" class="headerlink" title="循环的例子"></a>循环的例子</h3><h4 id="例子1：输入一个正整数判断它是不是素数。"><a href="#例子1：输入一个正整数判断它是不是素数。" class="headerlink" title="例子1：输入一个正整数判断它是不是素数。"></a>例子1：输入一个正整数判断它是不是素数。</h4><blockquote><p><strong>提示</strong>：素数指的是只能被1和自身整除的大于1的整数。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入一个正整数判断它是不是素数Version: 0.1Author: 骆昊"""num = int(input('请输入一个正整数: '))end = int(num ** 0.5)is_prime = Truefor x in range(2, end + 1):    if num % x == 0:        is_prime = False        breakif is_prime and num != 1:    print(f'{num}是素数')else:    print(f'{num}不是素数')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子2：输入两个正整数，计算它们的最大公约数和最小公倍数。"><a href="#例子2：输入两个正整数，计算它们的最大公约数和最小公倍数。" class="headerlink" title="例子2：输入两个正整数，计算它们的最大公约数和最小公倍数。"></a>例子2：输入两个正整数，计算它们的最大公约数和最小公倍数。</h4><blockquote><p><strong>提示</strong>：两个数的最大公约数是两个数的公共因子中最大的那个数；两个数的最小公倍数则是能够同时被两个数整除的最小的那个数。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入两个正整数计算它们的最大公约数和最小公倍数Version: 0.1Author: 骆昊"""x = int(input('x = '))y = int(input('y = '))for factor in range(x, 0, -1):    if x % factor == 0 and y % factor == 0:        print(f'{x}和{y}的最大公约数是{factor}')        print(f'{x}和{y}的最小公倍数是{x * y // factor}')        break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>学会了Python中的分支结构和循环结构，我们就可以解决很多实际的问题了。通过这节课的学习，大家应该已经知道了可以用<code>for</code>和<code>while</code>关键字来构造循环结构。<strong>如果知道循环的次数，我们通常使用</strong><code>for</code><strong>循环</strong>；如果<strong>循环次数不能确定，可以用</strong><code>while</code><strong>循环</strong>。在循环中还<strong>可以使用</strong><code>break</code><strong>来提前结束循环</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第07课：分支和循环结构的应用</title>
      <link href="/blog/oldlmbpj.html"/>
      <url>/blog/oldlmbpj.html</url>
      
        <content type="html"><![CDATA[<h2 id="第07课：分支和循环结构的应用"><a href="#第07课：分支和循环结构的应用" class="headerlink" title="第07课：分支和循环结构的应用"></a>第07课：分支和循环结构的应用</h2><p>通过上两节课的学习，大家对Python中的分支和循环结构已经有了感性的认识。<strong>分支和循环结构</strong>的重要性不言而喻，它<strong>是构造程序逻辑的基础</strong>，对于初学者来说也是比较困难的部分。大部分初学者在学习了分支和循环结构后都能理解它们的用途和用法，但是遇到实际问题的时候又无法下手；<strong>看懂别人的代码很容易，但是要自己写出同样的代码却又很难</strong>。如果你也有同样的问题和困惑，千万不要沮丧，这只是因为你才刚刚开始编程之旅，<strong>你的练习量还没有达到让你可以随心所欲的写出代码的程度</strong>，只要加强编程练习，这个问题迟早都会解决的。下面我们就为大家讲解一些经典的案例。</p><h3 id="经典小案例"><a href="#经典小案例" class="headerlink" title="经典小案例"></a>经典小案例</h3><h4 id="例子1：寻找水仙花数。"><a href="#例子1：寻找水仙花数。" class="headerlink" title="例子1：寻找水仙花数。"></a>例子1：寻找水仙花数。</h4><blockquote><p><strong>说明</strong>：水仙花数也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个3位数，该数字每个位上数字的立方之和正好等于它本身，例如：$ 153=1^3+5^3+3^3 $。</p></blockquote><p>这个题目的关键是将一个三位数拆分为个位、十位、百位，这一点利用Python中的<code>//</code>（整除）和<code>%</code>（求模）运算符其实很容易做到，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""找出所有水仙花数Version: 0.1Author: 骆昊"""for num in range(100, 1000):    low = num % 10    mid = num // 10 % 10    high = num // 100    if num == low ** 3 + mid ** 3 + high ** 3:        print(num)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面利用<code>//</code>和<code>%</code>拆分一个数的小技巧在写代码的时候还是很常用的。我们要将一个不知道有多少位的正整数进行反转，例如将<code>12345</code>变成<code>54321</code>，也可以利用这两个运算来实现，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""正整数的反转Version: 0.1Author: 骆昊"""num = int(input('num = '))reversed_num = 0while num &gt; 0:    reversed_num = reversed_num * 10 + num % 10    num //= 10print(reversed_num)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子2：百钱百鸡问题。"><a href="#例子2：百钱百鸡问题。" class="headerlink" title="例子2：百钱百鸡问题。"></a>例子2：百钱百鸡问题。</h4><blockquote><p><strong>说明</strong>：百钱百鸡是我国古代数学家<a href="https://baike.baidu.com/item/%E5%BC%A0%E4%B8%98%E5%BB%BA/10246238">张丘建</a>在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现代文是：公鸡5元一只，母鸡3元一只，小鸡1元三只，用100块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""《百钱百鸡》问题Version: 0.1Author: 骆昊"""# 假设公鸡的数量为x，x的取值范围是0到20for x in range(0, 21):    # 假设母鸡的数量为y，y的取值范围是0到33    for y in range(0, 34):        z = 100 - x - y        if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:            print(f'公鸡: {x}只, 母鸡: {y}只, 小鸡: {z}只')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面使用的方法叫做<strong>穷举法</strong>，也称为<strong>暴力搜索法</strong>，这种方法通过一项一项的列举备选解决方案中所有可能的候选项并检查每个候选项是否符合问题的描述，最终得到问题的解。这种方法看起来比较笨拙，但对于运算能力非常强大的计算机来说，通常都是一个可行的甚至是不错的选择，只要问题的解存在就能够找到它。</p><h4 id="例子3：CRAPS赌博游戏。"><a href="#例子3：CRAPS赌博游戏。" class="headerlink" title="例子3：CRAPS赌博游戏。"></a>例子3：CRAPS赌博游戏。</h4><blockquote><p><strong>说明</strong>：CRAPS又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简化后的规则是：玩家第一次摇骰子如果摇出了7点或11点，玩家胜；玩家第一次如果摇出2点、3点或12点，庄家胜；玩家如果摇出其他点数则玩家继续摇骰子，如果玩家摇出了7点，庄家胜；如果玩家摇出了第一次摇的点数，玩家胜；其他点数玩家继续摇骰子，直到分出胜负。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""Craps赌博游戏我们设定游戏开始时玩家有1000元的赌注游戏结束的条件是玩家破产（输光所有的赌注）Version: 0.1Author: 骆昊"""from random import randintmoney = 1000while money &gt; 0:    print(f'你的总资产为: {money}元')    go_on = False    # 下注金额必须大于0小于等于玩家总资产    while True:        debt = int(input('请下注: '))        if 0 &lt; debt &lt;= money:            break    # 第一次摇色子    # 用1到6均匀分布的随机数模拟摇色子得到的点数    first = randint(1, 6) + randint(1, 6)    print(f'\n玩家摇出了{first}点')    if first == 7 or first == 11:        print('玩家胜!\n')        money += debt    elif first == 2 or first == 3 or first == 12:        print('庄家胜!\n')        money -= debt    else:        go_on = True    # 第一次摇色子没有分出胜负游戏继续    while go_on:        go_on = False        current = randint(1, 6) + randint(1, 6)        print(f'玩家摇出了{current}点')        if current == 7:            print('庄家胜!\n')            money -= debt        elif current == first:            print('玩家胜!\n')            money += debt        else:            go_on = Trueprint('你破产了, 游戏结束!')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子4：斐波那契数列。"><a href="#例子4：斐波那契数列。" class="headerlink" title="例子4：斐波那契数列。"></a>例子4：斐波那契数列。</h4><blockquote><p><strong>说明</strong>：斐波那契数列（Fibonacci sequence），通常也被称作黄金分割数列，是意大利数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）在《计算之书》中研究在理想假设条件下兔子成长率问题而引入的数列，因此这个数列也常被戏称为“兔子数列”。斐波那契数列的特点是数列的前两个数都是1，从第三个数开始，每个数都是它前面两个数的和，按照这个规律，斐波那契数列的前10个数是：<code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55</code>。斐波那契数列在现代物理、准晶体结构、化学等领域都有直接的应用。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输出斐波那契数列前20个数Version: 0.1Author: 骆昊"""a, b = 0, 1for _ in range(20):    a, b = b, a + b    print(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子5：打印100以内的素数。"><a href="#例子5：打印100以内的素数。" class="headerlink" title="例子5：打印100以内的素数。"></a>例子5：打印100以内的素数。</h4><blockquote><p><strong>说明</strong>：素数指的是只能被1和自身整除的正整数（不包括1）。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输出100以内的素数Version: 0.1Author: 骆昊"""for num in range(2, 100):    # 假设num是素数    is_prime = True    # 在2到num-1之间找num的因子    for factor in range(2, num):        # 如果找到了num的因子，num就不是素数        if num % factor == 0:            is_prime = False            break    # 如果布尔值为True在num是素数    if is_prime:        print(num)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>还是那句话：<strong>分支结构和循环结构非常重要</strong>，是构造程序逻辑的基础，<strong>一定要通过大量的练习来达到融会贯通</strong>。刚才讲到的CRAPS赌博游戏那个例子可以作为一个标准，如果你能很顺利的完成这段代码，那么分支和循环结构的知识你就已经掌握了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第08课：常用数据结构之列表</title>
      <link href="/blog/qbvnczsp.html"/>
      <url>/blog/qbvnczsp.html</url>
      
        <content type="html"><![CDATA[<h2 id="第08课：常用数据结构之列表"><a href="#第08课：常用数据结构之列表" class="headerlink" title="第08课：常用数据结构之列表"></a>第08课：常用数据结构之列表</h2><p>在开始本节课的内容之前，我们先给大家一个编程任务，将一颗色子掷<code>6000</code>次，统计每个点数出现的次数。这个任务对大家来说应该是非常简单的，我们可以用<code>1</code>到<code>6</code>均匀分布的随机数来模拟掷色子，然后用<code>6</code>个变量分别记录每个点数出现的次数，相信大家都能写出下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomf1 = 0f2 = 0f3 = 0f4 = 0f5 = 0f6 = 0for _ in range(6000):    face = random.randint(1, 6)    if face == 1:        f1 += 1    elif face == 2:        f2 += 1    elif face == 3:        f3 += 1    elif face == 4:        f4 += 1    elif face == 5:        f5 += 1    else:        f6 += 1print(f'1点出现了{f1}次')print(f'2点出现了{f2}次')print(f'3点出现了{f3}次')print(f'4点出现了{f4}次')print(f'5点出现了{f5}次')print(f'6点出现了{f6}次')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看上面的代码，相信大家一定觉得它非常的“笨重”和“丑陋”，更可怕的是，如果要统计掷两颗或者更多的色子统计每个点数出现的次数，那就需要定义更多的变量，写更多的分支结构。讲到这里，相信大家一定想问：有没有办法用一个变量来保存多个数据，有没有办法用统一的代码对多个数据进行操作？答案是肯定的，在Python中我们可以通过容器类型的变量来保存和操作多个数据，我们首先为大家介绍列表（list）这种新的数据类型。</p><h3 id="定义和使用列表"><a href="#定义和使用列表" class="headerlink" title="定义和使用列表"></a>定义和使用列表</h3><p>在Python中，<strong>列表是由一系元素按特定顺序构成的数据序列</strong>，这样就意味着定义一个列表类型的变量，<strong>可以保存多个数据</strong>，而且<strong>允许有重复的数据</strong>。跟上一课我们讲到的字符串类型一样，列表也是一种结构化的、非标量类型，操作一个列表类型的变量，除了可以使用运算符还可以使用它的方法。</p><p>在Python中，可以使用<code>[]</code>字面量语法来定义列表，列表中的多个元素用逗号进行分隔，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items1 = [35, 12, 99, 68, 55, 87]items2 = ['Python', 'Java', 'Go', 'Kotlin']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>除此以外，还可以通过Python内置的<code>list</code>函数将其他序列变成列表。准确的说，<code>list</code>并不是一个普通的函数，它是创建列表对象的构造器（后面会讲到对象和构造器这两个概念）。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items1 = list(range(1, 10))print(items1)    # [1, 2, 3, 4, 5, 6, 7, 8, 9]items2 = list('hello')print(items2)    # ['h', 'e', 'l', 'l', 'o']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的是，列表是一种可变数据类型，也就是说列表可以添加元素、删除元素、更新元素，这一点跟我们上一课讲到的字符串有着鲜明的差别。字符串是一种不可变数据类型，也就是说对字符串做拼接、重复、转换大小写、修剪空格等操作的时候会产生新的字符串，原来的字符串并没有发生任何改变。</p><h4 id="列表的运算符"><a href="#列表的运算符" class="headerlink" title="列表的运算符"></a>列表的运算符</h4><p>和字符串类型一样，列表也支持拼接、重复、成员运算、索引和切片以及比较运算，对此我们不再进行赘述，请大家参考下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items1 = [35, 12, 99, 68, 55, 87]items2 = [45, 8, 29]# 列表的拼接items3 = items1 + items2print(items3)    # [35, 12, 99, 68, 55, 87, 45, 8, 29]# 列表的重复items4 = ['hello'] * 3print(items4)    # ['hello', 'hello', 'hello']# 列表的成员运算print(100 in items3)        # Falseprint('hello' in items4)    # True# 获取列表的长度(元素个数)size = len(items3)print(size)                 # 9# 列表的索引print(items3[0], items3[-size])        # 35 35items3[-1] = 100print(items3[size - 1], items3[-1])    # 100 100# 列表的切片print(items3[:5])          # [35, 12, 99, 68, 55]print(items3[4:])          # [55, 87, 45, 8, 100]print(items3[-5:-7:-1])    # [55, 68]print(items3[::-2])        # [100, 45, 55, 99, 35]# 列表的比较运算items5 = [1, 2, 3, 4]items6 = list(range(1, 5))# 两个列表比较相等性比的是对应索引位置上的元素是否相等print(items5 == items6)    # Trueitems7 = [3, 2, 1]# 两个列表比较大小比的是对应索引位置上的元素的大小print(items5 &lt;= items7)    # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得一提的是，由于列表是可变类型，所以通过索引操作既可以获取列表中的元素，也可以更新列表中的元素。对列表做索引操作一样要注意索引越界的问题，对于有<code>N</code>个元素的列表，正向索引的范围是<code>0</code>到<code>N-1</code>，负向索引的范围是<code>-1</code>到<code>-N</code>，如果超出这个范围，将引发<code>IndexError</code>异常，错误信息为：<code>list index out of range</code>。</p><h4 id="列表元素的遍历"><a href="#列表元素的遍历" class="headerlink" title="列表元素的遍历"></a>列表元素的遍历</h4><p>如果想逐个取出列表中的元素，可以使用<code>for</code>循环的，有以下两种做法。</p><p>方法一：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin']for index in range(len(items)):    print(items[index])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin']for item in items:    print(item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>讲到这里，我们可以用列表的知识来重构上面“掷色子统计每个点数出现次数”的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomcounters = [0] * 6for _ in range(6000):    face = random.randint(1, 6)    counters[face - 1] += 1for face in range(1, 7):    print(f'{face}点出现了{counters[face - 1]}次')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，我们用<code>counters</code>列表中的六个元素分别表示1到6的点数出现的次数，最开始的时候六个元素的值都是<code>0</code>。接下来用随机数模拟掷色子，如果摇出1点<code>counters[0]</code>的值加<code>1</code>，如果摇出2点<code>counters[1]</code>的值加<code>1</code>，以此类推。大家感受一下，这段代码是不是比之前的代码要简单优雅很多。</p><h3 id="列表的方法"><a href="#列表的方法" class="headerlink" title="列表的方法"></a>列表的方法</h3><p>和字符串一样，列表类型的方法也很多，下面为大家讲解比较重要的方法。</p><h4 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin']# 使用append方法在列表尾部添加元素items.append('Swift')print(items)    # ['Python', 'Java', 'Go', 'Kotlin', 'Swift']# 使用insert方法在列表指定索引位置插入元素items.insert(2, 'SQL')print(items)    # ['Python', 'Java', 'SQL', 'Go', 'Kotlin', 'Swift']# 删除指定的元素items.remove('Java')print(items)    # ['Python', 'SQL', 'Go', 'Kotlin', 'Swift']# 删除指定索引位置的元素items.pop(0)items.pop(len(items) - 1)print(items)    # ['SQL', 'Go', 'Kotlin']# 清空列表中的元素items.clear()print(items)    # []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要提醒大家，在使用<code>remove</code>方法删除元素时，如果要删除的元素并不在列表中，会引发<code>ValueError</code>异常，错误消息是：<code>list.remove(x): x not in list</code>。在使用<code>pop</code>方法删除元素时，如果索引的值超出了范围，会引发<code>IndexError</code>异常，错误消息是：<code>pop index out of range</code>。</p><p>从列表中删除元素其实还有一种方式，就是使用Python中的<code>del</code>关键字后面跟要删除的元素，这种做法跟使用<code>pop</code>方法指定索引删除元素没有实质性的区别，但后者会返回删除的元素，前者在性能上略优（<code>del</code>对应字节码指令是<code>DELETE_SUBSCR</code>，而<code>pop</code>对应的字节码指令是<code>CALL_METHOD</code>和<code>POP_TOP</code>，不理解就跳过，不用管它！！！）。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin']del items[1]print(items)    # ['Python', 'Go', 'Kotlin']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="元素位置和次数"><a href="#元素位置和次数" class="headerlink" title="元素位置和次数"></a>元素位置和次数</h4><p>列表类型的<code>index</code>方法可以查找某个元素在列表中的索引位置；因为列表中允许有重复的元素，所以列表类型提供了<code>count</code>方法来统计一个元素在列表中出现的次数。请看下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Java', 'Go', 'Kotlin', 'Python']# 查找元素的索引位置print(items.index('Python'))       # 0print(items.index('Python', 2))    # 5# 注意：虽然列表中有'Java'，但是从索引为3这个位置开始后面是没有'Java'的print(items.index('Java', 3))      # ValueError: 'Java' is not in list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看看下面这段代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Java', 'Go', 'Kotlin', 'Python']# 查找元素出现的次数print(items.count('Python'))    # 2print(items.count('Go'))        # 1print(items.count('Swfit'))     # 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="元素排序和反转"><a href="#元素排序和反转" class="headerlink" title="元素排序和反转"></a>元素排序和反转</h4><p>列表的<code>sort</code>操作可以实现列表元素的排序，而<code>reverse</code>操作可以实现元素的反转，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin', 'Python']# 排序items.sort()print(items)    # ['Go', 'Java', 'Kotlin', 'Python', 'Python']# 反转items.reverse()print(items)    # ['Python', 'Python', 'Kotlin', 'Java', 'Go']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列表的生成式"><a href="#列表的生成式" class="headerlink" title="列表的生成式"></a>列表的生成式</h3><p>在Python中，列表还可以通过一种特殊的字面量语法来创建，这种语法叫做生成式。我们给出两段代码，大家可以做一个对比，看看哪一种方式更加简单优雅。</p><p>通过<code>for</code>循环为空列表添加元素。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 创建一个由1到9的数字构成的列表items1 = []for x in range(1, 10):    items1.append(x)print(items1)# 创建一个由'hello world'中除空格和元音字母外的字符构成的列表items2 = []for x in 'hello world':    if x not in ' aeiou':        items2.append(x)print(items2)# 创建一个由个两个字符串中字符的笛卡尔积构成的列表items3 = []for x in 'ABC':    for y in '12':        items3.append(x + y)print(items3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过生成式创建列表。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 创建一个由1到9的数字构成的列表items1 = [x for x in range(1, 10)]print(items1)    # [1, 2, 3, 4, 5, 6, 7, 8, 9]# 创建一个由'hello world'中除空格和元音字母外的字符构成的列表items2 = [x for x in 'hello world' if x not in ' aeiou']print(items2)    # ['h', 'l', 'l', 'w', 'r', 'l', 'd']# 创建一个由个两个字符串中字符的笛卡尔积构成的列表items3 = [x + y for x in 'ABC' for y in '12']print(items3)    # ['A1', 'A2', 'B1', 'B2', 'C1', 'C2']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面这种方式不仅代码简单优雅，而且性能也优于上面使用<code>for</code>循环和<code>append</code>方法向空列表中追加元素的方式。可以简单跟大家交待下为什么生成式拥有更好的性能，那是因为Python解释器的字节码指令中有专门针对生成式的指令（<code>LIST_APPEND</code>指令）；而<code>for</code>循环是通过方法调用（<code>LOAD_METHOD</code>和<code>CALL_METHOD</code>指令）的方式为列表添加元素，方法调用本身就是一个相对耗时的操作。对这一点不理解也没有关系，记住“<strong>强烈建议用生成式语法来创建列表</strong>”这个结论就可以了。</p><h3 id="嵌套的列表"><a href="#嵌套的列表" class="headerlink" title="嵌套的列表"></a>嵌套的列表</h3><p>Python语言没有限定列表中的元素必须是相同的数据类型，也就是说一个列表中的元素可以任意的数据类型，当然也包括列表。如果列表中的元素又是列表，那么我们可以称之为嵌套的列表。嵌套的列表可以用来表示表格或数学上的矩阵，例如：我们想保存5个学生3门课程的成绩，可以定义一个保存5个元素的列表保存5个学生的信息，而每个列表元素又是3个元素构成的列表，分别代表3门课程的成绩。但是，一定要注意下面的代码是有问题的。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">scores = [[0] * 3] * 5print(scores)    # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看上去我们好像创建了一个<code>5 * 3</code>的嵌套列表，但实际上当我们录入第一个学生的第一门成绩后，你就会发现问题来了，我们看看下面代码的输出。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 嵌套的列表需要多次索引操作才能获取元素scores[0][0] = 95print(scores)# [[95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们不去过多的解释为什么会出现这样的问题，如果想深入研究这个问题，可以通过<a href="http://www.pythontutor.com/visualize.html">Python Tutor</a>网站的可视化代码执行功能，看看创建列表时计算机内存中发生了怎样的变化，下面的图就是在这个网站上生成的。建议大家不去纠结这个问题，现阶段只需要记住不能用<code>[[0] * 3] * 5]</code>这种方式来创建嵌套列表就行了。那么创建嵌套列表的正确做法是什么呢，下面的代码会给你答案。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">scores = [[0] * 3 for _ in range(5)]scores[0][0] = 95print(scores)# [[95, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python中的列表底层是一个可以动态扩容的数组，列表元素在内存中也是连续存储的，所以可以实现随机访问（通过一个有效的索引获取到对应的元素且操作时间与列表元素个数无关）。我们暂时不去触碰这些底层存储细节以及列表每个方法的渐近时间复杂度（执行这个方法耗费的时间跟列表元素个数的关系），等需要的时候再告诉大家。现阶段，大家只需要知道<strong>列表是容器</strong>，可以<strong>保存各种类型的数据</strong>，<strong>可以通过索引操作列表元素</strong>，知道这些就足够了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第09课：常用数据结构之元组</title>
      <link href="/blog/orxyj1jy.html"/>
      <url>/blog/orxyj1jy.html</url>
      
        <content type="html"><![CDATA[<h2 id="第09课：常用数据结构之元组"><a href="#第09课：常用数据结构之元组" class="headerlink" title="第09课：常用数据结构之元组"></a>第09课：常用数据结构之元组</h2><p>上一节课为大家讲解了Python中的列表，它是一种容器型数据类型，我们可以通过定义列表类型的变量来保存和操作多个元素。当然，Python中容器型的数据类型肯定不止列表一种，接下来我们为大家讲解另一种重要的容器型数据类型，它的名字叫元组（tuple）。</p><h3 id="定义和使用元组"><a href="#定义和使用元组" class="headerlink" title="定义和使用元组"></a>定义和使用元组</h3><p>在Python中，元组也是多个元素按照一定的顺序构成的序列。元组和列表的不同之处在于，元组是不可变类型，这就意味着元组类型的变量一旦定义，其中的元素不能再添加或删除，而且元素的值也不能进行修改。定义元组通常使用<code>()</code>字面量语法，也建议大家使用这种方式来创建元组。元组类型支持的运算符跟列表是一样。下面的代码演示了元组的定义和运算。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 定义一个三元组t1 = (30, 10, 55)# 定义一个四元组t2 = ('骆昊', 40, True, '四川成都')# 查看变量的类型print(type(t1), type(t2))    # &lt;class 'tuple'&gt; &lt;class 'tuple'&gt;# 查看元组中元素的数量print(len(t1), len(t2))      # 3 4# 通过索引运算获取元组中的元素print(t1[0], t1[-3])         # 30 30print(t2[3], t2[-1])         # 四川成都 四川成都# 循环遍历元组中的元素for member in t2:    print(member)# 成员运算print(100 in t1)    # Falseprint(40 in t2)     # True# 拼接t3 = t1 + t2print(t3)           # (30, 10, 55, '骆昊', 40, True, '四川成都')# 切片print(t3[::3])      # (30, '骆昊', '四川成都')# 比较运算print(t1 == t3)    # Falseprint(t1 &gt;= t3)    # Falseprint(t1 &lt; (30, 11, 55))    # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个元组中如果有两个元素，我们就称之为二元组；一个元组中如果五个元素，我们就称之为五元组。需要提醒大家注意的是，<code>()</code>表示空元组，但是如果元组中只有一个元素，需要加上一个逗号，否则<code>()</code>就不是代表元组的字面量语法，而是改变运算优先级的圆括号，所以<code>('hello', )</code>和<code>(100, )</code>才是一元组，而<code>('hello')</code>和<code>(100)</code>只是字符串和整数。我们可以通过下面的代码来加以验证。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 空元组a = ()print(type(a))    # &lt;class 'tuple'&gt;# 不是元组b = ('hello')print(type(b))    # &lt;class 'str'&gt;c = (100)print(type(c))    # &lt;class 'int'&gt;# 一元组d = ('hello', )print(type(d))    # &lt;class 'tuple'&gt;e = (100, )print(type(e))    # &lt;class 'tuple'&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="元组的应用场景"><a href="#元组的应用场景" class="headerlink" title="元组的应用场景"></a>元组的应用场景</h3><p>讲到这里，相信大家一定迫切的想知道元组有哪些应用场景，我们给大家举几个例子。</p><h4 id="例子1：打包和解包操作。"><a href="#例子1：打包和解包操作。" class="headerlink" title="例子1：打包和解包操作。"></a>例子1：打包和解包操作。</h4><p>当我们把多个用逗号分隔的值赋给一个变量时，多个值会打包成一个元组类型；当我们把一个元组赋值给多个变量时，元组会解包成多个值然后分别赋给对应的变量，如下面的代码所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 打包a = 1, 10, 100print(type(a), a)    # &lt;class 'tuple'&gt; (1, 10, 100)# 解包i, j, k = aprint(i, j, k)       # 1 10 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在解包时，如果解包出来的元素个数和变量个数不对应，会引发<code>ValueError</code>异常，错误信息为：<code>too many values to unpack</code>（解包的值太多）或<code>not enough values to unpack</code>（解包的值不足）。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 1, 10, 100, 1000# i, j, k = a             # ValueError: too many values to unpack (expected 3)# i, j, k, l, m, n = a    # ValueError: not enough values to unpack (expected 6, got 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有一种解决变量个数少于元素的个数方法，就是使用星号表达式，我们之前讲函数的可变参数时使用过星号表达式。有了星号表达式，我们就可以让一个变量接收多个值，代码如下所示。需要注意的是，用星号表达式修饰的变量会变成一个列表，列表中有0个或多个元素。还有在解包语法中，星号表达式只能出现一次。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 1, 10, 100, 1000i, j, *k = aprint(i, j, k)          # 1 10 [100, 1000]i, *j, k = aprint(i, j, k)          # 1 [10, 100] 1000*i, j, k = aprint(i, j, k)          # [1, 10] 100 1000*i, j = aprint(i, j)             # [1, 10, 100] 1000i, *j = aprint(i, j)             # 1 [10, 100, 1000]i, j, k, *l = aprint(i, j, k, l)       # 1 10 100 [1000]i, j, k, l, *m = aprint(i, j, k, l, m)    # 1 10 100 1000 []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明一点，解包语法对所有的序列都成立，这就意味着对列表以及我们之前讲到的<code>range</code>函数返回的范围序列都可以使用解包语法。大家可以尝试运行下面的代码，看看会出现怎样的结果。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a, b, *c = range(1, 10)print(a, b, c)a, b, c = [1, 10, 100]print(a, b, c)a, *b, c = 'hello'print(a, b, c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子2：交换两个变量的值。"><a href="#例子2：交换两个变量的值。" class="headerlink" title="例子2：交换两个变量的值。"></a>例子2：交换两个变量的值。</h4><p>交换两个变量的值是编程语言中的一个经典案例，在很多编程语言中，交换两个变量的值都需要借助一个中间变量才能做到，如果不用中间变量就需要使用比较晦涩的位运算来实现。在Python中，交换两个变量<code>a</code>和<code>b</code>的值只需要使用如下所示的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a, b = b, a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，如果要将三个变量<code>a</code>、<code>b</code>、<code>c</code>的值互换，即<code>b</code>赋给<code>a</code>，<code>c</code>赋给<code>b</code>，<code>a</code>赋给<code>c</code>，也可以如法炮制。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a, b, c = b, c, a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要说明的是，上面并没有用到打包和解包语法，Python的字节码指令中有<code>ROT_TWO</code>和<code>ROT_THREE</code>这样的指令可以实现这个操作，效率是非常高的。但是如果有多于三个变量的值要依次互换，这个时候没有直接可用的字节码指令，执行的原理就是我们上面讲解的打包和解包操作。</p><h3 id="元组和列表的比较"><a href="#元组和列表的比较" class="headerlink" title="元组和列表的比较"></a>元组和列表的比较</h3><p>这里还有一个非常值得探讨的问题，Python中已经有了列表类型，为什么还需要元组这样的类型呢？这个问题对于初学者来说似乎有点困难，不过没有关系，我们先抛出观点，大家可以一边学习一边慢慢体会。</p><ol><li><p>元组是不可变类型，<strong>不可变类型更适合多线程环境</strong>，因为它降低了并发访问变量的同步化开销。关于这一点，我们会在后面讲解多线程的时候为大家详细论述。</p></li><li><p>元组是不可变类型，通常<strong>不可变类型在创建时间和占用空间上面都优于对应的可变类型</strong>。我们可以使用<code>sys</code>模块的<code>getsizeof</code>函数来检查保存相同元素的元组和列表各自占用了多少内存空间。我们也可以使用<code>timeit</code>模块的<code>timeit</code>函数来看看创建保存相同元素的元组和列表各自花费的时间，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import sysimport timeita = list(range(100000))b = tuple(range(100000))print(sys.getsizeof(a), sys.getsizeof(b))    # 900120 800056print(timeit.timeit('[1, 2, 3, 4, 5, 6, 7, 8, 9]'))print(timeit.timeit('(1, 2, 3, 4, 5, 6, 7, 8, 9)'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Python中的元组和列表是可以相互转换的，我们可以通过下面的代码来做到。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 将元组转换成列表info = ('骆昊', 175, True, '四川成都')print(list(info))       # ['骆昊', 175, True, '四川成都']# 将列表转换成元组fruits = ['apple', 'banana', 'orange']print(tuple(fruits))    # ('apple', 'banana', 'orange')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p><strong>列表和元组都是容器型的数据类型</strong>，即一个变量可以保存多个数据。<strong>列表是可变数据类型</strong>，<strong>元组是不可变数据类型</strong>，所以列表添加元素、删除元素、清空、排序等方法对于元组来说是不成立的。但是列表和元组都可以进行<strong>拼接</strong>、<strong>成员运算</strong>、<strong>索引和切片</strong>这些操作，后面我们要讲到的字符串类型也是这样，因为字符串就是字符按一定顺序构成的序列，在这一点上三者并没有什么区别。我们<strong>推荐大家使用列表的生成式语法来创建列表</strong>，它很好用，也是Python中非常有特色的语法。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第10课：常用数据结构之字符串</title>
      <link href="/blog/uhkzcszq.html"/>
      <url>/blog/uhkzcszq.html</url>
      
        <content type="html"><![CDATA[<h2 id="第10课：字符串的使用"><a href="#第10课：字符串的使用" class="headerlink" title="第10课：字符串的使用"></a>第10课：字符串的使用</h2><p>第二次世界大战促使了现代电子计算机的诞生，世界上的第一台通用电子计算机叫ENIAC（电子数值积分计算机），诞生于美国的宾夕法尼亚大学，占地167平米，重量27吨，每秒钟大约能够完成约5000次浮点运算，如下图所示。ENIAC诞生之后被应用于导弹弹道的计算，而数值计算也是现代电子计算机最为重要的一项功能。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210727163610.jpg" width="65%"><p>随着时间的推移，虽然数值运算仍然是计算机日常工作中最为重要的组成部分，但是今天的计算机还要处理大量的以文本形式存在的信息。如果我们希望通过Python程序来操作本这些文本信息，就必须要先了解字符串这种数据类型以及与它相关的知识。</p><h3 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h3><p>所谓<strong>字符串</strong>，就是<strong>由零个或多个字符组成的有限序列</strong>，一般记为：<br>$$<br>s = a_1a_2 \cdots a_n ,,,,, (0 \le n \le \infty)<br>$$<br>在Python程序中，如果我们把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。字符串中的字符可以是特殊符号、英文字母、中文字符、日文的平假名或片假名、希腊字母、<a href="http://www.ruanyifeng.com/blog/2017/04/emoji.html">Emoji字符</a>等。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello, world!'s2 = "你好，世界！"print(s1, s2)# 以三个双引号或单引号开头的字符串可以折行s3 = '''hello, world!'''print(s3, end='')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：<code>print</code>函数中的<code>end=''</code>表示输出后不换行，即将默认的结束符<code>\n</code>（换行符）更换为<code>''</code>（空字符）。</p></blockquote><h3 id="转义字符和原始字符串"><a href="#转义字符和原始字符串" class="headerlink" title="转义字符和原始字符串"></a>转义字符和原始字符串</h3><p>可以在字符串中使用<code>\</code>（反斜杠）来表示转义，也就是说<code>\</code>后面的字符不再是它原来的意义，例如：<code>\n</code>不是代表反斜杠和字符<code>n</code>，而是表示换行；<code>\t</code>也不是代表反斜杠和字符<code>t</code>，而是表示制表符。所以如果字符串本身又包含了<code>'</code>、<code>"</code>、<code>\</code>这些特殊的字符，必须要通过<code>\</code>进行转义处理。例如要输出一个带单引号或反斜杠的字符串，需要用如下所示的方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = '\'hello, world!\''print(s1)s2 = '\\hello, world!\\'print(s2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Python中的字符串可以<code>r</code>或<code>R</code>开头，这种字符串被称为原始字符串，意思是字符串中的每个字符都是它本来的含义，没有所谓的转义字符。例如，在字符串<code>'hello\n'</code>中，<code>\n</code>表示换行；而在<code>r'hello\n'</code>中，<code>\n</code>不再表示换行，就是反斜杠和字符<code>n</code>。大家可以运行下面的代码，看看会输出什么。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 字符串s1中\t是制表符，\n是换行符s1 = '\time up \now'print(s1)# 字符串s2中没有转义字符，每个字符都是原始含义s2 = r'\time up \now'print(s2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python中还允许在<code>\</code>后面还可以跟一个八进制或者十六进制数来表示字符，例如<code>\141</code>和<code>\x61</code>都代表小写字母<code>a</code>，前者是八进制的表示法，后者是十六进制的表示法。另外一种表示字符的方式是在<code>\u</code>后面跟Unicode字符编码，例如<code>\u9a86\u660a</code>代表的是中文“骆昊”。运行下面的代码，看看输出了什么。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = '\141\142\143\x61\x62\x63's2 = '\u9a86\u660a'print(s1, s2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="字符串的运算"><a href="#字符串的运算" class="headerlink" title="字符串的运算"></a>字符串的运算</h3><p>Python为字符串类型提供了非常丰富的运算符，我们可以使用<code>+</code>运算符来实现字符串的拼接，可以使用<code>*</code>运算符来重复一个字符串的内容，可以使用<code>in</code>和<code>not in</code>来判断一个字符串是否包含另外一个字符串，我们也可以用<code>[]</code>和<code>[:]</code>运算符从字符串取出某个字符或某些字符。</p><h4 id="拼接和重复"><a href="#拼接和重复" class="headerlink" title="拼接和重复"></a>拼接和重复</h4><p>下面的例子演示了使用<code>+</code>和<code>*</code>运算符来实现字符串的拼接和重复操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello' + ' ' + 'world'print(s1)    # hello worlds2 = '!' * 3print(s2)    # !!!s1 += s2     # s1 = s1 + s2print(s1)    # hello world!!!s1 *= 2      # s1 = s1 * 2print(s1)    # hello world!!!hello world!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用<code>*</code>实现字符串的重复是非常有意思的一个运算符，在很多编程语言中，要表示一个有10个<code>a</code>的字符串，你只能写成<code>"aaaaaaaaaa"</code>，但是在Python中，你可以写成<code>'a' * 10</code>。你可能觉得<code>"aaaaaaaaaa"</code>这种写法也没有什么不方便的，那么想一想，如果字符<code>a</code>要重复100次或者1000次又会如何呢？</p><h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><p>对于两个字符串类型的变量，可以直接使用比较运算符比较两个字符串的相等性或大小。需要说明的是，因为字符串在计算机内存中也是以二进制形式存在的，那么字符串的大小比较比的是每个字符对应的编码的大小。例如<code>A</code>的编码是<code>65</code>， 而<code>a</code>的编码是<code>97</code>，所以<code>'A' &lt; 'a'</code>的结果相当于就是<code>65 &lt; 97</code>的结果，很显然是<code>True</code>；而<code>'boy' &lt; 'bad'</code>，因为第一个字符都是<code>'b'</code>比不出大小，所以实际比较的是第二个字符的大小，显然<code>'o' &lt; 'a'</code>的结果是<code>False</code>，所以<code>'boy' &lt; 'bad'</code>的结果也是<code>False</code>。如果不清楚两个字符对应的编码到底是多少，可以使用<code>ord</code>函数来获得，例如<code>ord('A')</code>的值是<code>65</code>，而<code>ord('昊')</code>的值是<code>26122</code>。下面的代码为大家展示了字符串的比较运算。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'a whole new world's2 = 'hello world'print(s1 == s2, s1 &lt; s2)      # False Trueprint(s2 == 'hello world')    # Trueprint(s2 == 'Hello world')    # Falseprint(s2 != 'Hello world')    # Trues3 = '骆昊'print(ord('骆'), ord('昊'))               # 39558 26122s4 = '王大锤'print(ord('王'), ord('大'), ord('锤'))    # 29579 22823 38180print(s3 &gt; s4, s3 &lt;= s4)      # True False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要强调一下的是，字符串的比较运算比较的是字符串的内容，Python中还有一个<code>is</code>运算符（身份运算符），如果用<code>is</code>来比较两个字符串，它比较的是两个变量对应的字符串对象的内存地址（不理解先跳过），简单的说就是两个变量是否对应内存中的同一个字符串。看看下面的代码就比较清楚<code>is</code>运算符的作用了。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello world's2 = 'hello world's3 = s2# 比较字符串的内容print(s1 == s2, s2 == s3)    # True True# 比较字符串的内存地址print(s1 is s2, s2 is s3)    # False True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成员运算"><a href="#成员运算" class="headerlink" title="成员运算"></a>成员运算</h4><p>Python中可以用<code>in</code>和<code>not in</code>判断一个字符串中是否存在另外一个字符或字符串，<code>in</code>和<code>not in</code>运算通常称为成员运算，会产生布尔值<code>True</code>或<code>False</code>，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello, world'print('wo' in s1)    # Trues2 = 'goodbye'print(s2 in s1)      # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>获取字符串长度没有直接的运算符，而是使用内置函数<code>len</code>，我们在上节课的提到过这个内置函数，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello, world'print(len(s))                   # 12print(len('goodbye, world'))    # 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h4><p>如果希望从字符串中取出某个字符，我们可以对字符串进行索引运算，运算符是<code>[n]</code>，其中<code>n</code>是一个整数，假设字符串的长度为<code>N</code>，那么<code>n</code>可以是从<code>0</code>到<code>N-1</code>的整数，其中<code>0</code>是字符串中第一个字符的索引，而<code>N-1</code>是字符串中最后一个字符的索引，通常称之为正向索引；在Python中，字符串的索引也可以是从<code>-1</code>到<code>-N</code>的整数，其中<code>-1</code>是最后一个字符的索引，而<code>-N</code>则是第一个字符的索引，通常称之为负向索引。注意，因为<strong>字符串是不可变类型</strong>，所以<strong>不能通过索引运算修改字符串中的字符</strong>。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'abc123456'N = len(s)# 获取第一个字符print(s[0], s[-N])    # a a# 获取最后一个字符print(s[N-1], s[-1])  # 6 6# 获取索引为2或-7的字符print(s[2], s[-7])    # c c# 获取索引为5和-4的字符print(s[5], s[-4])    # 3 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要提醒大家注意的是，在进行索引操作时，如果索引越界（正向索引不在<code>0</code>到<code>N-1</code>范围，负向索引不在<code>-1</code>到<code>-N</code>范围），会引发<code>IndexError</code>异常，错误提示信息为：<code>string index out of range</code>（字符串索引超出范围）。</p><p>如果要从字符串中取出多个字符，我们可以对字符串进行切片，运算符是<code>[i:j:k]</code>，其中<code>i</code>是开始索引，索引对应的字符可以取到；<code>j</code>是结束索引，索引对应的字符不能取到；<code>k</code>是步长，默认值为<code>1</code>，表示从前向后获取相邻字符的连续切片，所以<code>:k</code>部分可以省略。假设字符串的长度为<code>N</code>，当<code>k &gt; 0</code>时表示正向切片（从前向后获取字符），如果没有给出<code>i</code>和<code>j</code>的值，则<code>i</code>的默认值是<code>0</code>，<code>j</code>的默认值是<code>N</code>；当<code>k &lt; 0</code>时表示负向切片（从后向前获取字符），如果没有给出<code>i</code>和<code>j</code>的值，则<code>i</code>的默认值是<code>-1</code>，j的默认值是<code>-N - 1</code>。如果不理解，直接看下面的例子，记住第一个字符的索引是<code>0</code>或<code>-N</code>，最后一个字符的索引是<code>N-1</code>或<code>-1</code>就行了。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'abc123456'# i=2, j=5, k=1的正向切片操作print(s[2:5])       # c12# i=-7, j=-4, k=1的正向切片操作print(s[-7:-4])     # c12# i=2, j=9, k=1的正向切片操作print(s[2:])        # c123456# i=-7, j=9, k=1的正向切片操作print(s[-7:])       # c123456# i=2, j=9, k=2的正向切片操作print(s[2::2])      # c246# i=-7, j=9, k=2的正向切片操作print(s[-7::2])     # c246# i=0, j=9, k=2的正向切片操作print(s[::2])       # ac246# i=1, j=-1, k=2的正向切片操作print(s[1:-1:2])    # b135# i=7, j=1, k=-1的负向切片操作print(s[7:1:-1])    # 54321c# i=-2, j=-8, k=-1的负向切片操作print(s[-2:-8:-1])  # 54321c# i=7, j=-10, k=-1的负向切片操作print(s[7::-1])     # 54321cba# i=-1, j=1, k=-1的负向切片操作print(s[:1:-1])     # 654321c# i=0, j=9, k=1的正向切片print(s[:])         # abc123456# i=0, j=9, k=2的正向切片print(s[::2])       # ac246# i=-1, j=-10, k=-1的负向切片print(s[::-1])      # 654321cba# i=-1, j=-10, k=-2的负向切片print(s[::-2])      # 642ca<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环遍历每个字符"><a href="#循环遍历每个字符" class="headerlink" title="循环遍历每个字符"></a>循环遍历每个字符</h4><p>如果希望从字符串中取出每个字符，可以使用<code>for</code>循环对字符串进行遍历，有两种方式。</p><p>方式一：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello'for index in range(len(s1)):    print(s1[index])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>方式二：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello'for ch in s1:    print(ch)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><p>在Python中，我们可以通过字符串类型自带的方法对字符串进行操作和处理，对于一个字符串类型的变量，我们可以用<code>变量名.方法名()</code>的方式来调用它的方法。所谓方法其实就是跟某个类型的变量绑定的函数，后面我们讲面向对象编程的时候还会对这一概念详加说明。</p><h4 id="大小写相关操作"><a href="#大小写相关操作" class="headerlink" title="大小写相关操作"></a>大小写相关操作</h4><p>下面的代码演示了和字符串大小写变换相关的方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello, world!'# 使用capitalize方法获得字符串首字母大写后的字符串print(s1.capitalize())   # Hello, world!# 使用title方法获得字符串每个单词首字母大写后的字符串print(s1.title())        # Hello, World!# 使用upper方法获得字符串大写后的字符串print(s1.upper())        # HELLO, WORLD!s2 = 'GOODBYE'# 使用lower方法获得字符串小写后的字符串print(s2.lower())        # goodbye<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>如果想在一个字符串中从前向后查找有没有另外一个字符串，可以使用字符串的<code>find</code>或<code>index</code>方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello, world!'# find方法从字符串中查找另一个字符串所在的位置# 找到了返回字符串中另一个字符串首字符的索引print(s.find('or'))        # 8# 找不到返回-1print(s.find('shit'))      # -1# index方法与find方法类似# 找到了返回字符串中另一个字符串首字符的索引print(s.index('or'))       # 8# 找不到引发异常print(s.index('shit'))     # ValueError: substring not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用<code>find</code>和<code>index</code>方法时还可以通过方法的参数来指定查找的范围，也就是查找不必从索引为<code>0</code>的位置开始。<code>find</code>和<code>index</code>方法还有逆向查找（从后向前查找）的版本，分别是<code>rfind</code>和<code>rindex</code>，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello good world!'# 从前向后查找字符o出现的位置(相当于第一次出现)print(s.find('o'))       # 4# 从索引为5的位置开始查找字符o出现的位置print(s.find('o', 5))    # 7# 从后向前查找字符o出现的位置(相当于最后一次出现)print(s.rfind('o'))      # 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="性质判断"><a href="#性质判断" class="headerlink" title="性质判断"></a>性质判断</h4><p>可以通过字符串的<code>startswith</code>、<code>endswith</code>来判断字符串是否以某个字符串开头和结尾；还可以用<code>is</code>开头的方法判断字符串的特征，这些方法都返回布尔值，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello, world!'# startwith方法检查字符串是否以指定的字符串开头返回布尔值print(s1.startswith('He'))    # Falseprint(s1.startswith('hel'))   # True# endswith方法检查字符串是否以指定的字符串结尾返回布尔值print(s1.endswith('!'))       # Trues2 = 'abc123456'# isdigit方法检查字符串是否由数字构成返回布尔值print(s2.isdigit())    # False# isalpha方法检查字符串是否以字母构成返回布尔值print(s2.isalpha())    # False# isalnum方法检查字符串是否以数字和字母构成返回布尔值print(s2.isalnum())    # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>在Python中，字符串类型可以通过<code>center</code>、<code>ljust</code>、<code>rjust</code>方法做居中、左对齐和右对齐的处理。如果要在字符串的左侧补零，也可以使用<code>zfill</code>方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello, world'# center方法以宽度20将字符串居中并在两侧填充*print(s.center(20, '*'))  # ****hello, world****# rjust方法以宽度20将字符串右对齐并在左侧填充空格print(s.rjust(20))        #         hello, world# ljust方法以宽度20将字符串左对齐并在右侧填充~print(s.ljust(20, '~'))   # hello, world~~~~~~~~# 在字符串的左侧补零print('33'.zfill(5))      # 00033print('-33'.zfill(5))     # -0033<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们之前讲过，在用<code>print</code>函数输出字符串时，可以用下面的方式对字符串进行格式化。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 321b = 123print('%d * %d = %d' % (a, b, a * b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，我们也可以用字符串的方法来完成字符串的格式，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 321b = 123print('{0} * {1} = {2}'.format(a, b, a * b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从Python 3.6开始，格式化字符串还有更为简洁的书写方式，就是在字符串前加上<code>f</code>来格式化字符串，在这种以<code>f</code>打头的字符串中，<code>{变量名}</code>是一个占位符，会被变量对应的值将其替换掉，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 321b = 123print(f'{a} * {b} = {a * b}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果需要进一步控制格式化语法中变量值的形式，可以参照下面的表格来进行字符串格式化操作。</p><table><thead><tr><th>变量值</th><th>占位符</th><th>格式化结果</th><th>说明</th></tr></thead><tbody><tr><td><code>3.1415926</code></td><td><code>{:.2f}</code></td><td><code>'3.14'</code></td><td>保留小数点后两位</td></tr><tr><td><code>3.1415926</code></td><td><code>{:+.2f}</code></td><td><code>'+3.14'</code></td><td>带符号保留小数点后两位</td></tr><tr><td><code>-1</code></td><td><code>{:+.2f}</code></td><td><code>'-1.00'</code></td><td>带符号保留小数点后两位</td></tr><tr><td><code>3.1415926</code></td><td><code>{:.0f}</code></td><td><code>'3'</code></td><td>不带小数</td></tr><tr><td><code>123</code></td><td><code>{:0&gt;10d}</code></td><td><code>'0000000123'</code></td><td>左边补<code>0</code>，补够10位</td></tr><tr><td><code>123</code></td><td><code>{:x&lt;10d}</code></td><td><code>'123xxxxxxx'</code></td><td>右边补<code>x</code> ，补够10位</td></tr><tr><td><code>123</code></td><td><code>{:&gt;10d}</code></td><td><code>'       123'</code></td><td>左边补空格，补够10位</td></tr><tr><td><code>123</code></td><td><code>{:&lt;10d}</code></td><td><code>'123       '</code></td><td>右边补空格，补够10位</td></tr><tr><td><code>123456789</code></td><td><code>{:,}</code></td><td><code>'123,456,789'</code></td><td>逗号分隔格式</td></tr><tr><td><code>0.123</code></td><td><code>{:.2%}</code></td><td><code>'12.30%'</code></td><td>百分比格式</td></tr><tr><td><code>123456789</code></td><td><code>{:.2e}</code></td><td><code>'1.23e+08'</code></td><td>科学计数法格式</td></tr></tbody></table><h4 id="修剪操作"><a href="#修剪操作" class="headerlink" title="修剪操作"></a>修剪操作</h4><p>字符串的<code>strip</code>方法可以帮我们获得将原字符串修剪掉左右两端空格之后的字符串。这个方法非常有实用价值，通常用来将用户输入中因为不小心键入的头尾空格去掉，<code>strip</code>方法还有<code>lstrip</code>和<code>rstrip</code>两个版本，相信从名字大家已经猜出来这两个方法是做什么用的。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = '   jackfrued@126.com  \t\r\n'# strip方法获得字符串修剪左右两侧空格之后的字符串print(s.strip())    # jackfrued@126.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h4><p>如果希望用新的内容替换字符串中指定的内容，可以使用<code>replace</code>方法，代码如下所示。<code>replace</code>方法的第一个参数是被替换的内容，第二个参数是替换后的内容，还可以通过第三个参数指定替换的次数。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello, world'print(s.replace('o', '@'))     # hell@, w@rldprint(s.replace('o', '@', 1))  # hell@, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="拆分-x2F-合并操作"><a href="#拆分-x2F-合并操作" class="headerlink" title="拆分/合并操作"></a>拆分/合并操作</h4><p>可以使用字符串的<code>split</code>方法将一个字符串拆分为多个字符串（放在一个列表中），也可以使用字符串的<code>join</code>方法将列表中的多个字符串连接成一个字符串，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'I love you'words = s.split()print(words)            # ['I', 'love', 'you']print('#'.join(words))  # I#love#you<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的是，<code>split</code>方法默认使用空格进行拆分，我们也可以指定其他的字符来拆分字符串，而且还可以指定最大拆分次数来控制拆分的效果，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'I#love#you#so#much'words = s.split('#')print(words)  # ['I', 'love', 'you', 'so', 'much']words = s.split('#', 3)print(words)  # ['I', 'love', 'you', 'so#much']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="编码-x2F-解码操作"><a href="#编码-x2F-解码操作" class="headerlink" title="编码/解码操作"></a>编码/解码操作</h4><p>Python中除了字符串<code>str</code>类型外，还有一种表示二进制数据的字节串类型（<code>bytes</code>）。所谓字节串，就是<strong>由零个或多个字节组成的有限序列</strong>。通过字符串的<code>encode</code>方法，我们可以按照某种编码方式将字符串编码为字节串，我们也可以使用字节串的<code>decode</code>方法，将字节串解码为字符串，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = '骆昊'b = a.encode('utf-8')c = a.encode('gbk')print(b, c)  # b'\xe9\xaa\x86\xe6\x98\x8a' b'\xc2\xe6\xea\xbb'print(b.decode('utf-8'))print(c.decode('gbk'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，如果编码和解码的方式不一致，会导致乱码问题（无法再现原始的内容）或引发<code>UnicodeDecodeError</code>错误导致程序崩溃。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>对于字符串类型来说，还有一个常用的操作是对字符串进行匹配检查，即检查字符串是否满足某种特定的模式。例如，一个网站对用户注册信息中用户名和邮箱的检查，就属于模式匹配检查。实现模式匹配检查的工具叫做正则表达式，Python语言通过标准库中的<code>re</code>模块提供了对正则表达式的支持，我们会在后续的课程中为大家讲解这个知识点。</p><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>知道如何表示和操作字符串对程序员来说是非常重要的，因为我们需要处理文本信息，Python中操作字符串可以用拼接、切片等运算符，也可以使用字符串类型的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第11课：常用数据结构之集合</title>
      <link href="/blog/ivncgczl.html"/>
      <url>/blog/ivncgczl.html</url>
      
        <content type="html"><![CDATA[<h2 id="第11课：常用数据结构之集合"><a href="#第11课：常用数据结构之集合" class="headerlink" title="第11课：常用数据结构之集合"></a>第11课：常用数据结构之集合</h2><p>在学习了列表和元组之后，我们再来学习一种容器型的数据类型，它的名字叫集合（set）。说到集合这个词大家一定不会陌生，在数学课本上就有这个概念。通常我们对集合的定义是“<strong>把一定范围的、确定的、可以区别的事物当作一个整体来看待</strong>”，集合中的各个事物通常称为集合的<strong>元素</strong>。集合应该满足以下特性：</p><ol><li><strong>无序性</strong>：一个集合中，每个元素的地位都是相同的，元素之间是无序的。</li><li><strong>互异性</strong>：一个集合中，任何两个元素都是不相同的，即元素在集合中只能出现一次。</li><li><strong>确定性</strong>：给定一个集合和一个任意元素，该元素要么属这个集合，要么不属于这个集合，二者必居其一，不允许有模棱两可的情况出现。</li></ol><p>Python程序中的集合跟数学上的集合是完全一致的，需要强调的是上面所说的无序性和互异性。无序性说明集合中的元素并不像列中的元素那样一个挨着一个，可以通过索引实现随机访问（随机访问指的是给定一个有效的范围，随机抽取出一个数字，然后通过这个数字可以获取到对应的元素），所以Python中的<strong>集合肯定不能够支持索引运算</strong>。另外，集合的互异性决定了<strong>集合中不能有重复元素</strong>，这一点也是集合区别于列表的关键，说得更直白一些就是，Python中的集合类型会对其中的元素做去重处理。Python中的集合一定是支持<code>in</code>和<code>not in</code>成员运算的，这样就可以确定一个元素是否属于集合，也就是上面所说的集合的确定性。<strong>集合的成员运算在性能上要优于列表的成员运算</strong>，这是集合的底层存储特性（哈希存储）决定的，此处我们暂时不做讨论，大家可以先记下这个结论。</p><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>在Python中，创建集合可以使用<code>{}</code>字面量语法，<code>{}</code>中需要至少有一个元素，因为没有元素的<code>{}</code>并不是空集合而是一个空字典，我们下一节课就会大家介绍字典的知识。当然，也可以使用内置函数<code>set</code>来创建一个集合，准确的说<code>set</code>并不是一个函数，而是创建集合对象的构造器，这个知识点我们很快也会讲到，现在不理解跳过它就可以了。要创建空集合可以使用<code>set()</code>；也可以将其他序列转换成集合，例如：<code>set('hello')</code>会得到一个包含了4个字符的集合（重复的<code>l</code>会被去掉）。除了这两种方式，我们还可以使用生成式语法来创建集合，就像我们之前用生成式创建列表那样。要知道集合中有多少个元素，还是使用内置函数<code>len</code>；使用<code>for</code>循环可以实现对集合元素的遍历。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 创建集合的字面量语法(重复元素不会出现在集合中)set1 = {1, 2, 3, 3, 3, 2}print(set1)         # {1, 2, 3}print(len(set1))    # 3# 创建集合的构造器语法(后面会讲到什么是构造器)set2 = set('hello')print(set2)         # {'h', 'l', 'o', 'e'}# 将列表转换成集合(可以去掉列表中的重复元素)set3 = set([1, 2, 3, 3, 2, 1])print(set3)         # {1, 2, 3}# 创建集合的生成式语法(将列表生成式的[]换成{})set4 = {num for num in range(1, 20) if num % 3 == 0 or num % 5 == 0}print(set4)         # {3, 5, 6, 9, 10, 12, 15, 18}# 集合元素的循环遍历for elem in set4:    print(elem)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要提醒大家，集合中的元素必须是<code>hashable</code>类型。所谓<code>hashable</code>类型指的是能够计算出哈希码的数据类型，大家可以暂时将哈希码理解为和变量对应的唯一的ID值。通常不可变类型都是<code>hashable</code>类型，如整数、浮点、字符串、元组等，而可变类型都不是<code>hashable</code>类型，因为可变类型无法确定唯一的ID值，所以也就不能放到集合中。集合本身也是可变类型，所以集合不能够作为集合中的元素，这一点在使用集合的时候一定要注意。</p><h3 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h3><p>Python为集合类型提供了非常丰富的运算符，主要包括：成员运算、交集运算、并集运算、差集运算、比较运算（相等性、子集、超集）等。</p><h4 id="成员运算"><a href="#成员运算" class="headerlink" title="成员运算"></a>成员运算</h4><p>可以通过成员运算<code>in</code>和<code>not in </code>检查元素是否在集合中，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">set1 = {11, 12, 13, 14, 15}print(10 in set1)        # False print(15 in set1)        # Trueset2 = {'Python', 'Java', 'Go', 'Swift'}print('Ruby' in set2)    # Falseprint('Java' in set2)    # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="交并差运算"><a href="#交并差运算" class="headerlink" title="交并差运算"></a>交并差运算</h4><p>Python中的集合跟数学上的集合一样，可以进行交集、并集、差集等运算，而且可以通过运算符和方法调用两种方式来进行操作，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">set1 = {1, 2, 3, 4, 5, 6, 7}set2 = {2, 4, 6, 8, 10}# 交集# 方法一: 使用 &amp; 运算符print(set1 &amp; set2)                # {2, 4, 6}# 方法二: 使用intersection方法print(set1.intersection(set2))    # {2, 4, 6}# 并集# 方法一: 使用 | 运算符print(set1 | set2)         # {1, 2, 3, 4, 5, 6, 7, 8, 10}# 方法二: 使用union方法print(set1.union(set2))    # {1, 2, 3, 4, 5, 6, 7, 8, 10}# 差集# 方法一: 使用 - 运算符print(set1 - set2)              # {1, 3, 5, 7}# 方法二: 使用difference方法print(set1.difference(set2))    # {1, 3, 5, 7}# 对称差# 方法一: 使用 ^ 运算符print(set1 ^ set2)                        # {1, 3, 5, 7, 8, 10}# 方法二: 使用symmetric_difference方法print(set1.symmetric_difference(set2))    # {1, 3, 5, 7, 8, 10}# 方法三: 对称差相当于两个集合的并集减去交集print((set1 | set2) - (set1 &amp; set2))      # {1, 3, 5, 7, 8, 10}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码可以看出，对两个集合求交集，<code>&amp;</code>运算符和<code>intersection</code>方法的作用是完全相同的，使用运算符的方式更直观而且代码也比较简短。相信大家对交集、并集、差集、对称差这几个概念是比较清楚的，如果没什么印象了可以看看下面的图。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210819154520.png" width="90%"><p>集合的交集、并集、差集运算还可以跟赋值运算一起构成复合赋值运算，如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">set1 = {1, 3, 5, 7}set2 = {2, 4, 6}# 将set1和set2求并集再赋值给set1# 也可以通过set1.update(set2)来实现set1 |= set2print(set1)    # {1, 2, 3, 4, 5, 6, 7}set3 = {3, 6, 9}# 将set1和set3求交集再赋值给set1# 也可以通过set1.intersection_update(set3)来实现set1 &amp;= set3print(set1)    # {3, 6}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><p>两个集合可以用<code>==</code>和<code>!=</code>进行相等性判断，如果两个集合中的元素完全相同，那么<code>==</code>比较的结果就是<code>True</code>，否则就是<code>False</code>。如果集合<code>A</code>的任意一个元素都是集合<code>B</code>的元素，那么集合<code>A</code>称为集合<code>B</code>的子集，即对于$ \forall{a} \in {A}$，均有$ {a} \in {B} $，则$ {A} \subseteq {B} $，<code>A</code>是<code>B</code>的子集，反过来也可以称<code>B</code>是<code>A</code>的超集。如果<code>A</code>是<code>B</code>的子集且<code>A</code>不等于<code>B</code>，那么<code>A</code>就是<code>B</code>的真子集。Python为集合类型提供了判断子集和超集的运算符，其实就是我们非常熟悉的<code>&lt;</code>和<code>&gt;</code>运算符，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">set1 = {1, 3, 5}set2 = {1, 2, 3, 4, 5}set3 = set2# &lt;运算符表示真子集，&lt;=运算符表示子集print(set1 &lt; set2, set1 &lt;= set2)    # True Trueprint(set2 &lt; set3, set2 &lt;= set3)    # False True# 通过issubset方法也能进行子集判断print(set1.issubset(set2))      # True# 反过来可以用issuperset或&gt;运算符进行超集判断print(set2.issuperset(set1))    # Trueprint(set2 &gt; set1)              # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="集合的方法"><a href="#集合的方法" class="headerlink" title="集合的方法"></a>集合的方法</h3><p>Python中的集合是可变类型，我们可以通过集合类型的方法为集合添加或删除元素。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 创建一个空集合set1 = set()# 通过add方法添加元素set1.add(33)set1.add(55)set1.update({1, 10, 100, 1000})print(set1)    # {33, 1, 100, 55, 1000, 10}# 通过discard方法删除指定元素set1.discard(100)set1.discard(99)print(set1)    # {1, 10, 33, 55, 1000}# 通过remove方法删除指定元素，建议先做成员运算再删除# 否则元素如果不在集合中就会引发KeyError异常if 10 in set1:    set1.remove(10)print(set1)    # {33, 1, 55, 1000}# pop方法可以从集合中随机删除一个元素并返回该元素print(set1.pop())# clear方法可以清空整个集合set1.clear()print(set1)    # set()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要判断两个集合有没有相同的元素可以使用<code>isdisjoint</code>方法，没有相同元素返回<code>True</code>，否则返回<code>False</code>，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">set1 = {'Java', 'Python', 'Go', 'Kotlin'}set2 = {'Kotlin', 'Swift', 'Java', 'Objective-C', 'Dart'}set3 = {'HTML', 'CSS', 'JavaScript'}print(set1.isdisjoint(set2))    # Falseprint(set1.isdisjoint(set3))    # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>Python中还有一种不可变类型的集合，名字叫<code>frozenset</code>。<code>set</code>跟<code>frozenset</code>的区别就如同<code>list</code>跟<code>tuple</code>的区别，<code>frozenset</code>由于是不可变类型，能够计算出哈希码，因此它可以作为<code>set</code>中的元素。除了不能添加和删除元素，<code>frozenset</code>在其他方面跟<code>set</code>基本是一样的，下面的代码简单的展示了<code>frozenset</code>的用法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">set1 = frozenset({1, 3, 5, 7})set2 = frozenset(range(1, 6))print(set1 &amp; set2)    # frozenset({1, 3, 5})print(set1 | set2)    # frozenset({1, 2, 3, 4, 5, 7})print(set1 - set2)    # frozenset({7})print(set1 &lt; set2)    # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python中的集合底层使用了<strong>哈希存储</strong>的方式，对于这一点我们暂时不做介绍，在后面的课程有需要的时候再为大家讲解集合的底层原理，现阶段大家只需要知道<strong>集合是一种容器</strong>，元素必须是<code>hashable</code>类型，与列表不同的地方在于集合中的元素<strong>没有序</strong>、<strong>不能用索引运算</strong>、<strong>不能重复</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第12课：常用数据结构之字典</title>
      <link href="/blog/9zg5rsvf.html"/>
      <url>/blog/9zg5rsvf.html</url>
      
        <content type="html"><![CDATA[<h2 id="第12课：常用数据结构之字典"><a href="#第12课：常用数据结构之字典" class="headerlink" title="第12课：常用数据结构之字典"></a>第12课：常用数据结构之字典</h2><p>迄今为止，我们已经为大家介绍了Python中的三种容器型数据类型，但是这些数据类型仍然不足以帮助我们解决所有的问题。例如，我们要保存一个人的信息，包括姓名、年龄、体重、单位地址、家庭住址、本人手机号、紧急联系人手机号等信息，你会发现我们之前学过的列表、元组和集合都不是最理想的选择。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">person1 = ['王大锤', 55, 60, '科华北路62号', '中同仁路8号', '13122334455', '13800998877']person2 = ('王大锤', 55, 60, '科华北路62号', '中同仁路8号', '13122334455', '13800998877')person3 = {'王大锤', 55, 60, '科华北路62号', '中同仁路8号', '13122334455', '13800998877'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>集合肯定是最不合适的，因为集合有去重特性，如果一个人的年龄和体重相同，那么集合中就会少一项信息；同理，如果这个人的家庭住址和单位地址是相同的，那么集合中又会少一项信息。另一方面，虽然列表和元组可以把一个人的所有信息都保存下来，但是当你想要获取这个人的手机号时，你得先知道他的手机号是列表或元组中的第6个还是第7个元素；当你想获取一个人的家庭住址时，你还得知道家庭住址是列表或元组中的第几项。总之，在遇到上述的场景时，列表、元组、字典都不是最合适的选择，我们还需字典（dictionary）类型，这种数据类型最适合把相关联的信息组装到一起，并且可以帮助我们解决程序中为真实事物建模的问题。</p><p>说到字典这个词，大家一定不陌生，读小学的时候每个人基本上都有一本《新华字典》，如下图所示。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210820204829.jpg" alt="dictionary"></p><p>Python程序中的字典跟现实生活中的字典很像，它以键值对（键和值的组合）的方式把数据组织到一起，我们可以通过键找到与之对应的值并进行操作。就像《新华字典》中，每个字（键）都有与它对应的解释（值）一样，每个字和它的解释合在一起就是字典中的一个条目，而字典中通常包含了很多个这样的条目。</p><h3 id="创建和使用字典"><a href="#创建和使用字典" class="headerlink" title="创建和使用字典"></a>创建和使用字典</h3><p>在Python中创建字典可以使用<code>{}</code>字面量语法，这一点跟上一节课讲的集合是一样的。但是字典的<code>{}</code>中的元素是以键值对的形式存在的，每个元素由<code>:</code>分隔的两个值构成，<code>:</code>前面是键，<code>:</code>后面是值，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">xinhua = {    '麓': '山脚下',    '路': '道，往来通行的地方；方面，地区：南～货，外～货；种类：他俩是一～人',    '蕗': '甘草的别名',    '潞': '潞水，水名，即今山西省的浊漳河；潞江，水名，即云南省的怒江'}print(xinhua)person = {    'name': '王大锤', 'age': 55, 'weight': 60, 'office': '科华北路62号',    'home': '中同仁路8号', 'tel': '13122334455', 'econtact': '13800998877'}print(person)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码，相信大家已经看出来了，用字典来保存一个人的信息远远优于使用列表或元组，因为我们可以用<code>:</code>前面的键来表示条目的含义，而<code>:</code>后面就是这个条目所对应的值。</p><p>当然，如果愿意，我们也可以使用内置函数<code>dict</code>或者是字典的生成式语法来创建字典，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># dict函数(构造器)中的每一组参数就是字典中的一组键值对person = dict(name='王大锤', age=55, weight=60, home='中同仁路8号')print(person)    # {'name': '王大锤', 'age': 55, 'weight': 60, 'home': '中同仁路8号'}# 可以通过Python内置函数zip压缩两个序列并创建字典items1 = dict(zip('ABCDE', '12345'))print(items1)    # {'A': '1', 'B': '2', 'C': '3', 'D': '4', 'E': '5'}items2 = dict(zip('ABCDE', range(1, 10)))print(items2)    # {'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5}# 用字典生成式语法创建字典items3 = {x: x ** 3 for x in range(1, 6)}print(items3)     # {1: 1, 2: 8, 3: 27, 4: 64, 5: 125}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想知道字典中一共有多少组键值对，仍然是使用<code>len</code>函数；如果想对字典进行遍历，可以用<code>for</code>循环，但是需要注意，<code>for</code>循环只是对字典的键进行了遍历，不过没关系，在讲完字典的运算后，我们可以通过字典的键获取到和这个键对应的值。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">person = {'name': '王大锤', 'age': 55, 'weight': 60, 'office': '科华北路62号'}print(len(person))    # 4for key in person:    print(key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字典的运算"><a href="#字典的运算" class="headerlink" title="字典的运算"></a>字典的运算</h3><p>对于字典类型来说，成员运算和索引运算肯定是最为重要的，前者可以判定指定的键在不在字典中，后者可以通过键获取对应的值或者向字典中加入新的键值对。值得注意的是，字典的索引不同于列表的索引，列表中的元素因为有属于自己有序号，所以列表的索引是一个整数；字典中因为保存的是键值对，所以字典的索引是键值对中的键，通过索引操作可以修改原来的值或者向字典中存入新的键值对。需要<strong>特别提醒</strong>大家注意的是，<strong>字典中的键必须是不可变类型</strong>，例如整数（<code>int</code>）、浮点数（<code>float</code>）、字符串（<code>str</code>）、元组（<code>tuple</code>）等类型的值；显然，列表（<code>list</code>）和集合（<code>set</code>）是不能作为字典中的键的，当然字典类型本身也不能再作为字典中的键，因为字典也是可变类型，但是字典可以作为字典中的值。关于可变类型不能作为字典中的键的原因，我们在后面的课程中再为大家详细说明。这里，我们先看看下面的代码，了解一下字典的成员运算和索引运算。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">person = {'name': '王大锤', 'age': 55, 'weight': 60, 'office': '科华北路62号'}# 检查name和tel两个键在不在person字典中print('name' in person, 'tel' in person)    # True False# 通过age修将person字典中对应的值修改为25if 'age' in person:    person['age'] = 25# 通过索引操作向person字典中存入新的键值对person['tel'] = '13122334455'person['signature'] = '你的男朋友是一个盖世垃圾，他会踏着五彩祥云去迎娶你的闺蜜'print('name' in person, 'tel' in person)    # True True# 检查person字典中键值对的数量print(len(person))    # 6# 对字典的键进行循环并通索引运算获取键对应的值for key in person:    print(f'{key}: {person[key]}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 需要注意，在通过索引运算获取字典中的值时，如指定的键没有在字典中，将会引发<code>KeyError</code>异常。</p><h3 id="字典的方法"><a href="#字典的方法" class="headerlink" title="字典的方法"></a>字典的方法</h3><p>字典类型的方法基本上都跟字典的键值对操作相关，可以通过下面的例子来了解这些方法的使用。例如，我们要用一个字典来保存学生的信息，我们可以使用学生的学号作为字典中的键，通过学号做索引运算就可以得到对应的学生；我们可以把字典的值也做成一个字典，这样就可以用多组键值对分别存储学生的姓名、性别、年龄、籍贯等信息，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 字典中的值又是一个字典(嵌套的字典)students = {    1001: {'name': '狄仁杰', 'sex': True, 'age': 22, 'place': '山西大同'},    1002: {'name': '白元芳', 'sex': True, 'age': 23, 'place': '河北保定'},    1003: {'name': '武则天', 'sex': False, 'age': 20, 'place': '四川广元'}}# 使用get方法通过键获取对应的值，如果取不到不会引发KeyError异常而是返回None或设定的默认值print(students.get(1002))    # {'name': '白元芳', 'sex': True, 'age': 23, 'place': '河北保定'}print(students.get(1005))    # Noneprint(students.get(1005, {'name': '无名氏'}))    # {'name': '无名氏'}# 获取字典中所有的键print(students.keys())      # dict_keys([1001, 1002, 1003])# 获取字典中所有的值print(students.values())    # dict_values([{...}, {...}, {...}])# 获取字典中所有的键值对print(students.items())     # dict_items([(1001, {...}), (1002, {....}), (1003, {...})])# 对字典中所有的键值对进行循环遍历for key, value in students.items():    print(key, '---&gt;', value)# 使用pop方法通过键删除对应的键值对并返回该值stu1 = students.pop(1002)print(stu1)             # {'name': '白元芳', 'sex': True, 'age': 23, 'place': '河北保定'}print(len(students))    # 2# stu2 = students.pop(1005)    # KeyError: 1005stu2 = students.pop(1005, {})print(stu2)             # {}# 使用popitem方法删除字典中最后一组键值对并返回对应的二元组# 如果字典中没有元素，调用该方法将引发KeyError异常key, value = students.popitem()print(key, value)    # 1003 {'name': '武则天', 'sex': False, 'age': 20, 'place': '四川广元'}# 如果这个键在字典中存在，setdefault返回原来与这个键对应的值# 如果这个键在字典中不存在，向字典中添加键值对，返回第二个参数的值，默认为Noneresult = students.setdefault(1005, {'name': '方启鹤', 'sex': True})print(result)        # {'name': '方启鹤', 'sex': True}print(students)      # {1001: {...}, 1005: {...}}# 使用update更新字典元素，相同的键会用新值覆盖掉旧值，不同的键会添加到字典中others = {    1005: {'name': '乔峰', 'sex': True, 'age': 32, 'place': '北京大兴'},    1010: {'name': '王语嫣', 'sex': False, 'age': 19},    1008: {'name': '钟灵', 'sex': False}}students.update(others)print(students)      # {1001: {...}, 1005: {...}, 1010: {...}, 1008: {...}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟列表一样，从字典中删除元素也可以使用<code>del</code>关键字，在删除元素的时候如果指定的键索引不到对应的值，一样会引发<code>KeyError</code>异常，具体的做法如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">person = {'name': '王大锤', 'age': 25, 'sex': True}del person['age']print(person)    # {'name': '王大锤', 'sex': True}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="字典的应用"><a href="#字典的应用" class="headerlink" title="字典的应用"></a>字典的应用</h3><p>我们通过几个简单的例子来讲解字典的应用。</p><p><strong>例子1</strong>：输入一段话，统计每个英文字母出现的次数。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">sentence = input('请输入一段话: ')counter = {}for ch in sentence:    if 'A' &lt;= ch &lt;= 'Z' or 'a' &lt;= ch &lt;= 'z':        counter[ch] = counter.get(ch, 0) + 1for key, value in counter.items():    print(f'字母{key}出现了{value}次.')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例子2</strong>：在一个字典中保存了股票的代码和价格，找出股价大于100元的股票并创建一个新的字典。</p><blockquote><p><strong>说明</strong>：可以用字典的生成式语法来创建这个新字典。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">stocks = {    'AAPL': 191.88,    'GOOG': 1186.96,    'IBM': 149.24,    'ORCL': 48.44,    'ACN': 166.89,    'FB': 208.09,    'SYMC': 21.29}stocks2 = {key: value for key, value in stocks.items() if value &gt; 100}print(stocks2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python程序中的字典跟现实生活中字典非常像，允许我们<strong>以键值对的形式保存数据</strong>，再<strong>通过键索引对应的值</strong>。这是一种非常<strong>有利于数据检索</strong>的数据类型，底层原理我们在后续的课程中为大家讲解。再次提醒大家注意，<strong>字典中的键必须是不可变类型</strong>，字典中的值可以是任意类型。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第13课：函数和模块</title>
      <link href="/blog/drxaoam4.html"/>
      <url>/blog/drxaoam4.html</url>
      
        <content type="html"><![CDATA[<h2 id="第13课：函数和模块"><a href="#第13课：函数和模块" class="headerlink" title="第13课：函数和模块"></a>第13课：函数和模块</h2><p>在讲解本节课的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。<br>$$<br>x_1 + x_2 + x_3 + x_4 = 8<br>$$<br>你可能已经想到了，这个问题其实等同于将<code>8</code>个苹果分成四组且每组至少一个苹果有多少种方案，因此该问题还可以进一步等价于在分隔<code>8</code>个苹果的<code>7</code>个空隙之间插入三个隔板将苹果分成四组有多少种方案，也就是从<code>7</code>个空隙选出<code>3</code>个空隙放入隔板的组合数，所以答案是$ C_7^3=35 $。组合数的计算公式如下所示。<br>$$<br>C_M^N = \frac {M!} {N!(M-N)!}<br>$$<br>根据我们前面学习的知识，可以用循环做累乘的方式来计算阶乘，那么通过下面的Python代码我们就可以计算出组合数$ C_M^N $的值，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入M和N计算C(M,N)Version: 0.1Author: 骆昊"""m = int(input('m = '))n = int(input('n = '))# 计算m的阶乘fm = 1for num in range(1, m + 1):    fm *= num# 计算n的阶乘fn = 1for num in range(1, n + 1):    fn *= num# 计算m-n的阶乘fk = 1for num in range(1, m - n + 1):    fk *= num# 计算C(M,N)的值print(fm // fn // fk)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数的作用"><a href="#函数的作用" class="headerlink" title="函数的作用"></a>函数的作用</h3><p>不知大家是否注意到，上面的代码中我们做了三次求阶乘，虽然<code>m</code>、<code>n</code>、<code>m - n</code>的值各不相同，但是三段代码并没有实质性的区别，属于重复代码。世界级的编程大师<em>Martin Fowler</em>先生曾经说过：“<strong>代码有很多种坏味道，重复是最坏的一种！</strong>”。要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称为“函数”的代码块中，在需要计算阶乘的地方，我们只需要“调用函数”就可以了。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>数学上的函数通常形如<code>y = f(x)</code>或者<code>z = g(x, y)</code>这样的形式，在<code>y = f(x)</code>中，<code>f</code>是函数的名字，<code>x</code>是函数的自变量，<code>y</code>是函数的因变量；而在<code>z = g(x, y)</code>中，<code>g</code>是函数名，<code>x</code>和<code>y</code>是函数的自变量，<code>z</code>是函数的因变量。Python中的函数跟这个结构是一致的，每个函数都有自己的名字、自变量和因变量。我们通常把Python中函数的自变量称为函数的参数，而因变量称为函数的返回值。</p><p>在Python中可以使用<code>def</code>关键字来定义函数，和变量一样每个函数也应该有一个漂亮的名字，命名规则跟变量的命名规则是一致的（赶紧想一想我们之前讲过的变量的命名规则）。在函数名后面的圆括号中可以放置传递给函数的参数，就是我们刚才说到的函数的自变量，而函数执行完成后我们会通过<code>return</code>关键字来返回函数的执行结果，就是我们刚才说的函数的因变量。一个函数要执行的代码块（要做的事情）也是通过缩进的方式来表示的，跟之前分支和循环结构的代码块是一样的。大家不要忘了<code>def</code>那一行的最后面还有一个<code>:</code>，之前提醒过大家，那是在英文输入法状态下输入的冒号。</p><p>我们可以通过函数对上面的代码进行重构。<strong>所谓重构，是在不影响代码执行结果的前提下对代码的结构进行调整。</strong>重构之后的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入M和N计算C(M,N)Version: 0.1Author: 骆昊"""# 定义函数：def是定义函数的关键字、fac是函数名，num是参数（自变量）def fac(num):    """求阶乘"""    result = 1    for n in range(1, num + 1):        result *= n    # 返回num的阶乘（因变量）    return resultm = int(input('m = '))n = int(input('n = '))# 当需要计算阶乘的时候不用再写重复的代码而是直接调用函数fac# 调用函数的语法是在函数名后面跟上圆括号并传入参数print(fac(m) // fac(n) // fac(m - n))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：事实上，Python标准库的<code>math</code>模块中有一个名为<code>factorial</code>的函数已经实现了求阶乘的功能，我们可以直接使用该函数来计算阶乘。<strong>将来我们使用的函数，要么是自定义的函数，要么是Python标准库或者三方库中提供的函数</strong>。</p></blockquote><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><h4 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h4><p>如果函数中没有<code>return</code>语句，那么函数默认返回代表空值的<code>None</code>。另外，在定义函数时，函数也可以没有自变量，但是函数名后面的圆括号是必须有的。Python中还允许函数的参数拥有默认值，我们可以把之前讲过的一个例子“CRAPS赌博游戏”中摇色子获得点数的功能封装成函数，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""参数的默认值Version: 0.1Author: 骆昊"""from random import randint# 定义摇色子的函数，n表示色子的个数，默认值为2def roll_dice(n=2):    """摇色子返回总的点数"""    total = 0    for _ in range(n):        total += randint(1, 6)    return total# 如果没有指定参数，那么n使用默认值2，表示摇两颗色子print(roll_dice())# 传入参数3，变量n被赋值为3，表示摇三颗色子获得点数print(roll_dice(3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再来看一个更为简单的例子。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def add(a=0, b=0, c=0):    """三个数相加求和"""    return a + b + c# 调用add函数，没有传入参数，那么a、b、c都使用默认值0print(add())         # 0# 调用add函数，传入一个参数，那么该参数赋值给变量a, 变量b和c使用默认值0print(add(1))        # 1# 调用add函数，传入两个参数，1和2分别赋值给变量a和b，变量c使用默认值0print(add(1, 2))     # 3# 调用add函数，传入三个参数，分别赋值给a、b、c三个变量print(add(1, 2, 3))  # 6# 传递参数时可以不按照设定的顺序进行传递，但是要用“参数名=参数值”的形式print(add(c=50, a=100, b=200))    # 350<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：带默认值的参数必须放在不带默认值的参数之后，否则将产生<code>SyntaxError</code>错误，错误消息是：<code>non-default argument follows default argument</code>，翻译成中文的意思是“没有默认值的参数放在了带默认值的参数后面”。</p></blockquote><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>接下来，我们还可以实现一个对任意多个数求和的<code>add</code>函数，因为Python语言中的函数可以通过星号表达式语法来支持可变参数。所谓可变参数指的是在调用函数时，可以向函数传入<code>0</code>个或任意多个参数。将来我们以团队协作的方式开发商业项目时，很有可能要设计函数给其他人使用，但有的时候我们并不知道函数的调用者会向该函数传入多少个参数，这个时候可变参数就可以派上用场。下面的代码演示了用可变参数实现对任意多个数求和的<code>add</code>函数。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""可变参数Version: 0.1Author: 骆昊"""# 用星号表达式来表示args可以接收0个或任意多个参数def add(*args):    total = 0    # 可变参数可以放在for循环中取出每个参数的值    for val in args:        if type(val) in (int, float):            total += val    return total# 在调用add函数时可以传入0个或任意多个参数print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用模块管理函数"><a href="#用模块管理函数" class="headerlink" title="用模块管理函数"></a>用模块管理函数</h3><p>不管用什么样的编程语言来写代码，给变量、函数起名字都是一个让人头疼的问题，因为我们会遇到<strong>命名冲突</strong>这种尴尬的情况。最简单的场景就是在同一个<code>.py</code>文件中定义了两个同名的函数，如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def foo():    print('hello, world!')def foo():    print('goodbye, world!')    foo()    # 大家猜猜调用foo函数会输出什么<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然上面的这种情况我们很容易就能避免，但是如果项目是团队协作多人开发的时候，团队中可能有多个程序员都定义了名为<code>foo</code>的函数，这种情况下怎么解决命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过<code>import</code>关键字导入指定的模块再使用<strong>完全限定名</strong>的调用方式就可以区分到底要使用的是哪个模块中的<code>foo</code>函数，代码如下所示。</p><p><code>module1.py</code></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def foo():    print('hello, world!')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>module2.py</code></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def foo():    print('goodbye, world!')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>test.py</code></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import module1import module2# 用“模块名.函数名”的方式（完全限定名）调用函数，module1.foo()    # hello, world!module2.foo()    # goodbye, world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在导入模块时，还可以使用<code>as</code>关键字对模块进行别名，这样我们可以使用更为简短的完全限定名。</p><p><code>test.py</code></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import module1 as m1import module2 as m2m1.foo()    # hello, world!m2.foo()    # goodbye, world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码我们导入了定义函数的模块，我们也可以使用<code>from...import...</code>语法从模块中直接导入需要使用的函数，代码如下所示。</p><p><code>test.py</code></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from module1 import foofoo()    # hello, world!from module2 import foofoo()    # goodbye, world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，如果我们如果从两个不同的模块中导入了同名的函数，后导入的函数会覆盖掉先前的导入，就像下面的代码中，调用<code>foo</code>会输出<code>hello, world!</code>，因为我们先导入了<code>module2</code>的<code>foo</code>，后导入了<code>module1</code>的<code>foo</code> 。如果两个<code>from...import...</code>反过来写，就是另外一番光景了。</p><p><code>test.py</code></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from module2 import foofrom module1 import foofoo()    # hello, world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果想在上面的代码中同时使用来自两个模块中的<code>foo</code>函数也是有办法的，大家可能已经猜到了，还是用<code>as</code>关键字对导入的函数进行别名，代码如下所示。</p><p><code>test.py</code></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from module1 import foo as f1from module2 import foo as f2f1()    # hello, world!f2()    # goodbye, world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="标准库中的模块和函数"><a href="#标准库中的模块和函数" class="headerlink" title="标准库中的模块和函数"></a>标准库中的模块和函数</h3><p>Python标准库中提供了大量的模块和函数来简化我们的开发工作，我们之前用过的<code>random</code>模块就为我们提供了生成随机数和进行随机抽样的函数；而<code>time</code>模块则提供了和时间操作相关的函数；上面求阶乘的函数在Python标准库中的<code>math</code>模块中已经有了，实际开发中并不需要我们自己编写，而<code>math</code>模块中还包括了计算正弦、余弦、指数、对数等一系列的数学函数。随着我们进一步的学习Python编程知识，我们还会用到更多的模块和函数。</p><p>Python标准库中还有一类函数是不需要<code>import</code>就能够直接使用的，我们将其称之为内置函数，这些内置函数都是很有用也是最常用的，下面的表格列出了一部分的内置函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>abs</code></td><td>返回一个数的绝对值，例如：<code>abs(-1.3)</code>会返回<code>1.3</code>。</td></tr><tr><td><code>bin</code></td><td>把一个整数转换成以<code>'0b'</code>开头的二进制字符串，例如：<code>bin(123)</code>会返回<code>'0b1111011'</code>。</td></tr><tr><td><code>chr</code></td><td>将Unicode编码转换成对应的字符，例如：<code>chr(8364)</code>会返回<code>'€'</code>。</td></tr><tr><td><code>hex</code></td><td>将一个整数转换成以<code>'0x'</code>开头的十六进制字符串，例如：<code>hex(123)</code>会返回<code>'0x7b'</code>。</td></tr><tr><td><code>input</code></td><td>从输入中读取一行，返回读到的字符串。</td></tr><tr><td><code>len</code></td><td>获取字符串、列表等的长度。</td></tr><tr><td><code>max</code></td><td>返回多个参数或一个可迭代对象中的最大值，例如：<code>max(12, 95, 37)</code>会返回<code>95</code>。</td></tr><tr><td><code>min</code></td><td>返回多个参数或一个可迭代对象中的最小值，例如：<code>min(12, 95, 37)</code>会返回<code>12</code>。</td></tr><tr><td><code>oct</code></td><td>把一个整数转换成以<code>'0o'</code>开头的八进制字符串，例如：<code>oct(123)</code>会返回<code>'0o173'</code>。</td></tr><tr><td><code>open</code></td><td>打开一个文件并返回文件对象。</td></tr><tr><td><code>ord</code></td><td>将字符转换成对应的Unicode编码，例如：<code>ord('€')</code>会返回<code>8364</code>。</td></tr><tr><td><code>pow</code></td><td>求幂运算，例如：<code>pow(2, 3)</code>会返回<code>8</code>；<code>pow(2, 0.5)</code>会返回<code>1.4142135623730951</code>。</td></tr><tr><td><code>print</code></td><td>打印输出。</td></tr><tr><td><code>range</code></td><td>构造一个范围序列，例如：<code>range(100)</code>会产生<code>0</code>到<code>99</code>的整数序列。</td></tr><tr><td><code>round</code></td><td>按照指定的精度对数值进行四舍五入，例如：<code>round(1.23456, 4)</code>会返回<code>1.2346</code>。</td></tr><tr><td><code>sum</code></td><td>对一个序列中的项从左到右进行求和运算，例如：<code>sum(range(1, 101))</code>会返回<code>5050</code>。</td></tr><tr><td><code>type</code></td><td>返回对象的类型，例如：<code>type(10)</code>会返回<code>int</code>；而<code> type('hello')</code>会返回<code>str</code>。</td></tr></tbody></table><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p><strong>函数是对功能相对独立且会重复使用的代码的封装</strong>。学会使用定义和使用函数，就能够写出更为优质的代码。当然，Python语言的标准库中已经为我们提供了大量的模块和常用的函数，用好这些模块和函数就能够用更少的代码做更多的事情；如果这些模块和函数不能满足我们的要求，我们就需要自定义函数，然后用模块的概念来管理这些自定义函数。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第14课：函数的应用</title>
      <link href="/blog/b8uhs2dk.html"/>
      <url>/blog/b8uhs2dk.html</url>
      
        <content type="html"><![CDATA[<h2 id="第14课：函数的应用"><a href="#第14课：函数的应用" class="headerlink" title="第14课：函数的应用"></a>第14课：函数的应用</h2><p>接下来我们通过一些案例来为大家讲解函数的应用。</p><h3 id="经典小案例"><a href="#经典小案例" class="headerlink" title="经典小案例"></a>经典小案例</h3><h4 id="案例1：设计一个生成验证码的函数。"><a href="#案例1：设计一个生成验证码的函数。" class="headerlink" title="案例1：设计一个生成验证码的函数。"></a>案例1：设计一个生成验证码的函数。</h4><blockquote><p><strong>说明</strong>：验证码由数字和英文大小写字母构成，长度可以用参数指定。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport stringALL_CHARS = string.digits + string.ascii_lettersdef generate_code(code_len=4):    """生成指定长度的验证码        :param code_len: 验证码的长度(默认4个字符)    :return: 由大小写英文字母和数字构成的随机验证码字符串    """    return ''.join(random.choices(ALL_CHARS, k=code_len))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以用下面的代码生成10组随机验证码来测试上面的函数。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">for _ in range(10):    print(generate_code()) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：<code>random</code>模块的<code>sample</code>和<code>choices</code>函数都可以实现随机抽样，<code>sample</code>实现无放回抽样，这意味着抽样取出的字符是不重复的；<code>choices</code>实现有放回抽样，这意味着可能会重复选中某些字符。这两个函数的第一个参数代表抽样的总体，而参数<code>k</code>代表抽样的数量。</p></blockquote><h4 id="案例2：设计一个函数返回给定文件的后缀名。"><a href="#案例2：设计一个函数返回给定文件的后缀名。" class="headerlink" title="案例2：设计一个函数返回给定文件的后缀名。"></a>案例2：设计一个函数返回给定文件的后缀名。</h4><blockquote><p><strong>说明</strong>：文件名通常是一个字符串，而文件的后缀名指的是文件名中最后一个<code>.</code>后面的部分，也称为文件的扩展名，它是某些操作系统用来标记文件类型的一种机制，例如在Windows系统上，后缀名<code>exe</code>表示这是一个可执行程序，而后缀名<code>txt</code>表示这是一个纯文本文件。需要注意的是，在Linux和macOS系统上，文件名可以以<code>.</code>开头，表示这是一个隐藏文件，像<code>.gitignore</code>这样的文件名，<code>.</code>后面并不是后缀名，这个文件没有后缀名或者说后缀名为<code>''</code>。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def get_suffix(filename, ignore_dot=True):    """获取文件名的后缀名        :param filename: 文件名    :param ignore_dot: 是否忽略后缀名前面的点    :return: 文件的后缀名    """    # 从字符串中逆向查找.出现的位置    pos = filename.rfind('.')    # 通过切片操作从文件名中取出后缀名    if pos &lt;= 0:        return ''    return filename[pos + 1:] if ignore_dot else filename[pos:]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以用下面的代码对上面的函数做一个简单的测验。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">print(get_suffix('readme.txt'))       # txtprint(get_suffix('readme.txt.md'))    # mdprint(get_suffix('.readme'))          #print(get_suffix('readme.'))          #print(get_suffix('readme'))           #<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>get_suffix</code>函数还有一个更为便捷的实现方式，就是直接使用<code>os.path</code>模块的<code>splitext</code>函数，这个函数会将文件名拆分成带路径的文件名和扩展名两个部分，然后返回一个二元组，二元组中的第二个元素就是文件的后缀名（包含<code>.</code>），如果要去掉后缀名中的<code>.</code>，可以做一个字符串的切片操作，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from os.path import splitextdef get_suffix(filename, ignore_dot=True):    return splitext(filename)[1][1:]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>思考</strong>：如果要给上面的函数增加一个参数，用来控制文件的后缀名是否包含<code>.</code>，应该怎么做？</p></blockquote><h4 id="案例3：写一个判断给定的正整数是不是质数的函数。"><a href="#案例3：写一个判断给定的正整数是不是质数的函数。" class="headerlink" title="案例3：写一个判断给定的正整数是不是质数的函数。"></a>案例3：写一个判断给定的正整数是不是质数的函数。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def is_prime(num: int) -&gt; bool:    """判断一个正整数是不是质数    :param num: 正整数    :return: 如果是质数返回True，否则返回False    """    for i in range(2, int(num ** 0.5) + 1):        if num % i == 0:            return False    return num != 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="案例4：写出计算两个正整数最大公约数和最小公倍数的函数。"><a href="#案例4：写出计算两个正整数最大公约数和最小公倍数的函数。" class="headerlink" title="案例4：写出计算两个正整数最大公约数和最小公倍数的函数。"></a>案例4：写出计算两个正整数最大公约数和最小公倍数的函数。</h4><p>代码一：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def gcd_and_lcm(x: int, y: int) -&gt; int:    """求最大公约数和最小公倍数"""    a, b = x, y    while b % a != 0:        a, b = b % a, a    return a, x * y // a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码二：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def gcd(x: int, y: int) -&gt; int:    """求最大公约数"""    while y % x != 0:        x, y = y % x, x    return xdef lcm(x: int, y: int) -&gt; int:    """求最小公倍数"""    return x * y // gcd(x, y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>思考</strong>：请比较上面的代码一和代码二，想想哪种做法是更好的选择。</p></blockquote><h4 id="案例5：写出计算一组样本数据描述性统计信息的函数。"><a href="#案例5：写出计算一组样本数据描述性统计信息的函数。" class="headerlink" title="案例5：写出计算一组样本数据描述性统计信息的函数。"></a>案例5：写出计算一组样本数据描述性统计信息的函数。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import mathdef ptp(data):    """求极差（全距）"""    return max(data) - min(data)def average(data):    """求均值"""    return sum(data) / len(data)def variance(data):    """求方差"""    x_bar = average(data)    temp = [(num - x_bar) ** 2 for num in data]    return sum(temp) / (len(temp) - 1)def standard_deviation(data):    """求标准差"""    return math.sqrt(variance(data))def median(data):    """找中位数"""    temp, size = sorted(data), len(data)    if size % 2 != 0:        return temp[size // 2]    else:        return average(temp[size // 2 - 1:size // 2 + 1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>在写代码尤其是开发商业项目的时候，一定要有意识的<strong>将相对独立且重复出现的功能封装成函数</strong>，这样不管是自己还是团队的其他成员都可以通过调用函数的方式来使用这些功能。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第15课：函数使用进阶</title>
      <link href="/blog/jvofrsso.html"/>
      <url>/blog/jvofrsso.html</url>
      
        <content type="html"><![CDATA[<h2 id="第15课：函数使用进阶"><a href="#第15课：函数使用进阶" class="headerlink" title="第15课：函数使用进阶"></a>第15课：函数使用进阶</h2><p>前面我们讲到了关于函数的知识，我们还讲到过Python中常用的数据类型，这些类型的变量都可以作为函数的参数或返回值，用好函数还可以让我们做更多的事情。</p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>下面是一个判断传入的三条边长能否构成三角形的函数，在调用函数传入参数时，我们可以指定参数名，也可以不指定参数名，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def is_triangle(a, b, c):    print(f'a = {a}, b = {b}, c = {c}')    return a + b &gt; c and b + c &gt; a and a + c &gt; b# 调用函数传入参数不指定参数名按位置对号入座print(is_triangle(1, 2, 3))# 调用函数通过“参数名=参数值”的形式按顺序传入参数print(is_triangle(a=1, b=2, c=3))# 调用函数通过“参数名=参数值”的形式不按顺序传入参数print(is_triangle(c=3, a=1, b=2))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在没有特殊处理的情况下，函数的参数都是<strong>位置参数</strong>，也就意味着传入参数的时候对号入座即可，如上面代码的第7行所示，传入的参数值<code>1</code>、<code>2</code>、<code>3</code>会依次赋值给参数<code>a</code>、<code>b</code>、<code>c</code>。当然，也可以通过<code>参数名=参数值</code>的方式传入函数所需的参数，因为指定了参数名，传入参数的顺序可以进行调整，如上面代码的第9行和第11行所示。</p><p>调用函数时，如果希望函数的调用者必须以<code>参数名=参数值</code>的方式传参，可以用<strong>命名关键字参数</strong>（keyword-only argument）取代位置参数。所谓命名关键字参数，是在函数的参数列表中，写在<code>*</code>之后的参数，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def is_triangle(*, a, b, c):    print(f'a = {a}, b = {b}, c = {c}')    return a + b &gt; c and b + c &gt; a and a + c &gt; b# TypeError: is_triangle() takes 0 positional arguments but 3 were given# print(is_triangle(3, 4, 5))# 传参时必须使用“参数名=参数值”的方式，位置不重要print(is_triangle(a=3, b=4, c=5))print(is_triangle(c=5, b=4, a=3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：上面的<code>is_triangle</code>函数，参数列表中的<code>*</code>是一个分隔符，<code>*</code>前面的参数都是位置参数，而<code>*</code>后面的参数就是命名关键字参数。</p></blockquote><p>我们之前讲过在函数的参数列表中可以使用<strong>可变参数</strong><code>*args</code>来接收任意数量的参数，但是我们需要看看，<code>*args</code>是否能够接收带参数名的参数。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def calc(*args):    result = 0    for arg in args:        if type(arg) in (int, float):            result += arg    return resultprint(calc(a=1, b=2, c=3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上面的代码会引发<code>TypeError</code>错误，错误消息为<code>calc() got an unexpected keyword argument 'a'</code>，由此可见，<code>*args</code>并不能处理带参数名的参数。我们在设计函数时，如果既不知道调用者会传入的参数个数，也不知道调用者会不会指定参数名，那么同时使用可变参数和<strong>关键字参数</strong>。关键字参数会将传入的带参数名的参数组装成一个字典，参数名就是字典中键值对的键，而参数值就是字典中键值对的值，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def calc(*args, **kwargs):    result = 0    for arg in args:        if type(arg) in (int, float):            result += arg    for value in kwargs.values():        if type(value) in (int, float):            result += value    return resultprint(calc())                  # 0print(calc(1, 2, 3))           # 6print(calc(a=1, b=2, c=3))     # 6print(calc(1, 2, c=3, d=4))    # 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：<strong>不带参数名的参数（位置参数）必须出现在带参数名的参数（关键字参数）之前</strong>，否则将会引发异常。例如，执行<code>calc(1, 2, c=3, d=4, 5)</code>将会引发<code>SyntaxError</code>错误，错误消息为<code>positional argument follows keyword argument</code>，翻译成中文意思是“位置参数出现在关键字参数之后”。</p></blockquote><h3 id="高阶函数的用法"><a href="#高阶函数的用法" class="headerlink" title="高阶函数的用法"></a>高阶函数的用法</h3><p>在前面几节课中，我们讲到了面向对象程序设计，在面向对象的世界中，一切皆为对象，所以类和函数也是对象。函数的参数和返回值可以是任意类型的对象，这就意味着<strong>函数本身也可以作为函数的参数或返回值</strong>，这就是所谓的<strong>高阶函数</strong>。</p><p>如果我们希望上面的<code>calc</code>函数不仅仅可以做多个参数求和，还可以做多个参数求乘积甚至更多的二元运算，我们就可以使用高阶函数的方式来改写上面的代码，将加法运算从函数中移除掉，具体的做法如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def calc(*args, init_value, op, **kwargs):    result = init_value    for arg in args:        if type(arg) in (int, float):            result = op(result, arg)    for value in kwargs.values():        if type(value) in (int, float):            result = op(result, value)    return result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，上面的函数增加了两个参数，其中<code>init_value</code>代表运算的初始值，<code>op</code>代表二元运算函数。经过改造的<code>calc</code>函数不仅仅可以实现多个参数的累加求和，也可以实现多个参数的累乘运算，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def add(x, y):    return x + ydef mul(x, y):    return x * yprint(calc(1, 2, 3, init_value=0, op=add, x=4, y=5))      # 15print(calc(1, 2, x=3, y=4, z=5, init_value=1, op=mul))    # 120<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对高阶函数的运用，<code>calc</code>函数不再和加法运算耦合，所以灵活性和通用性会变强，这是一种解耦合的编程技巧，但是最初学者来说可能会稍微有点难以理解。需要注意的是，将函数作为参数和调用函数是有显著的区别的，<strong>调用函数需要在函数名后面跟上圆括号，而把函数作为参数时只需要函数名即可</strong>。上面的代码也可以不用定义<code>add</code>和<code>mul</code>函数，因为Python标准库中的<code>operator</code>模块提供了代表加法运算的<code>add</code>和代表乘法运算的<code>mul</code>函数，我们直接使用即可，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import operatorprint(calc(1, 2, 3, init_value=0, op=operator.add, x=4, y=5))      # 15print(calc(1, 2, x=3, y=4, z=5, init_value=1, op=operator.mul))    # 120<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Python内置函数中有不少高阶函数，我们前面提到过的<code>filter</code>和<code>map</code>函数就是高阶函数，前者可以实现对序列中元素的过滤，后者可以实现对序列中元素的映射，例如我们要去掉一个整数列表中的奇数，并对所有的偶数求平方得到一个新的列表，就可以直接使用这两个函数来做到，具体的做法是如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def is_even(num):    return num % 2 == 0def square(num):    return num ** 2numbers1 = [35, 12, 8, 99, 60, 52]numbers2 = list(map(square, filter(is_even, numbers1)))print(numbers2)    # [144, 64, 3600, 2704]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，要完成上面代码的功能，也可以使用列表生成式，列表生成式的做法更为简单优雅。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">numbers1 = [35, 12, 8, 99, 60, 52]numbers2 = [num ** 2 for num in numbers1 if num % 2 == 0]print(numbers2)    # [144, 64, 3600, 2704]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Lambda函数"><a href="#Lambda函数" class="headerlink" title="Lambda函数"></a>Lambda函数</h3><p>在使用高阶函数的时候，如果作为参数或者返回值的函数本身非常简单，一行代码就能够完成，那么我们可以使用<strong>Lambda函数</strong>来表示。Python中的Lambda函数是没有的名字函数，所以很多人也把它叫做<strong>匿名函数</strong>，匿名函数只能有一行代码，代码中的表达式产生的运算结果就是这个匿名函数的返回值。上面代码中的<code>is_even</code>和<code>square</code>函数都只有一行代码，我们可以用Lambda函数来替换掉它们，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">numbers1 = [35, 12, 8, 99, 60, 52]numbers2 = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, numbers1)))print(numbers2)    # [144, 64, 3600, 2704]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过上面的代码可以看出，定义Lambda函数的关键字是<code>lambda</code>，后面跟函数的参数，如果有多个参数用逗号进行分隔；冒号后面的部分就是函数的执行体，通常是一个表达式，表达式的运算结果就是Lambda函数的返回值，不需要写<code>return</code> 关键字。</p><p>如果需要使用加减乘除这种简单的二元函数，也可以用Lambda函数来书写，例如调用上面的<code>calc</code>函数时，可以通过传入Lambda函数来作为<code>op</code>参数的参数值。当然，<code>op</code>参数也可以有默认值，例如我们可以用一个代表加法运算的Lambda函数来作为<code>op</code>参数的默认值。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def calc(*args, init_value=0, op=lambda x, y: x + y, **kwargs):    result = init_value    for arg in args:        if type(arg) in (int, float):            result = op(result, arg)    for value in kwargs.values():        if type(value) in (int, float):            result = op(result, value)    return result# 调用calc函数，使用init_value和op的默认值print(calc(1, 2, 3, x=4, y=5))    # 15# 调用calc函数，通过lambda函数给op参数赋值print(calc(1, 2, 3, x=4, y=5, init_value=1, op=lambda x, y: x * y))    # 120<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：注意上面的代码中的<code>calc</code>函数，它同时使用了可变参数、关键字参数、命名关键字参数，其中命名关键字参数要放在可变参数和关键字参数之间，传参时先传入可变参数，关键字参数和命名关键字参数的先后顺序并不重要。</p></blockquote><p>有很多函数在Python中用一行代码就能实现，我们可以用Lambda函数来定义这些函数，调用Lambda函数就跟调用普通函数一样，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import operator, functools# 一行代码定义求阶乘的函数fac = lambda num: functools.reduce(operator.mul, range(1, num + 1), 1)# 一行代码定义判断素数的函数is_prime = lambda x: x &gt; 1 and all(map(lambda f: x % f, range(2, int(x ** 0.5) + 1)))# 调用Lambda函数print(fac(10))        # 3628800print(is_prime(9))    # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示1</strong>：上面使用的<code>reduce</code>函数是Python标准库<code>functools</code>模块中的函数，它可以实现对数据的归约操作，通常情况下，<strong>过滤</strong>（filter）、<strong>映射</strong>（map）和<strong>归约</strong>（reduce）是处理数据中非常关键的三个步骤，而Python的标准库也提供了对这三个操作的支持。</p><p><strong>提示2</strong>：上面使用的<code>all</code>函数是Python内置函数，如果传入的序列中所有布尔值都是<code>True</code>，<code>all</code>函数就返回<code>True</code>，否则<code>all</code>函数就返回<code>False</code>。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python中的函数可以使用可变参数<code>*args</code>和关键字参数<code>**kwargs</code>来接收任意数量的参数，而且传入参数时可以带上参数名也可以没有参数名，可变参数会被处理成一个元组，而关键字参数会被处理成一个字典。<strong>Python中的函数是一等函数，可以赋值给变量，也可以作为函数的参数和返回值</strong>，这也就意味着我们可以在Python中使用高阶函数。如果我们要定义的函数非常简单，只有一行代码且不需要函数名，可以使用Lambda函数（匿名函数）。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第16课：函数的高级应用</title>
      <link href="/blog/u03encob.html"/>
      <url>/blog/u03encob.html</url>
      
        <content type="html"><![CDATA[<h2 id="第16课：函数的高级应用"><a href="#第16课：函数的高级应用" class="headerlink" title="第16课：函数的高级应用"></a>第16课：函数的高级应用</h2><p>在上一节课中，我们已经对函数进行了更为深入的研究，还探索了Python中的高阶函数和Lambda函数。在这些知识的基础上，这节课我们为大家分享两个和函数相关的内容，一个是装饰器，一个是函数的递归调用。</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器是Python中<strong>用一个函数装饰另外一个函数或类并为其提供额外功能</strong>的语法现象。装饰器本身是一个函数，它的参数是被装饰的函数或类，它的返回值是一个带有装饰功能的函数。很显然，装饰器是一个高阶函数，它的参数和返回值都是函数。下面我们先通过一个简单的例子来说明装饰器的写法和作用，假设已经有名为<code>downlaod</code>和<code>upload</code>的两个函数，分别用于文件的上传和下载，下面的代码用休眠一段随机时间的方式模拟了下载和上传需要花费的时间，并没有联网做上传下载。</p><blockquote><p><strong>说明</strong>：用Python语言实现联网的上传下载也很简单，继续你的学习，这个环节很快就会来到。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport timedef download(filename):    print(f'开始下载{filename}.')    time.sleep(random.randint(2, 6))    print(f'{filename}下载完成.')    def upload(filename):    print(f'开始上传{filename}.')    time.sleep(random.randint(4, 8))    print(f'{filename}上传完成.')    download('MySQL从删库到跑路.avi')upload('Python从入门到住院.pdf')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们希望知道调用<code>download</code>和<code>upload</code>函数做文件上传下载到底用了多少时间，这个应该如何实现呢？相信很多小伙伴已经想到了，我们可以在函数开始执行的时候记录一个时间，在函数调用结束后记录一个时间，两个时间相减就可以计算出下载或上传的时间，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">start = time.time()download('MySQL从删库到跑路.avi')end = time.time()print(f'花费时间: {end - start:.3f}秒')start = time.time()upload('Python从入门到住院.pdf')end = time.time()print(f'花费时间: {end - start:.3f}秒')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码，我们可以得到下载和上传花费的时间，但不知道大家是否注意到，上面记录时间、计算和显示执行时间的代码都是重复代码。有编程经验的人都知道，<strong>重复的代码是万恶之源</strong>，那么有没有办法在不写重复代码的前提下，用一种简单优雅的方式记录下函数的执行时间呢？在Python中，装饰器就是解决这类问题的最佳选择。我们可以把记录函数执行时间的功能封装到一个装饰器中，在有需要的地方直接使用这个装饰器就可以了，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import time# 定义装饰器函数，它的参数是被装饰的函数或类def record_time(func):        # 定义一个带装饰功能（记录被装饰函数的执行时间）的函数    # 因为不知道被装饰的函数有怎样的参数所以使用*args和**kwargs接收所有参数    # 在Python中函数可以嵌套的定义（函数中可以再定义函数）    def wrapper(*args, **kwargs):        # 在执行被装饰的函数之前记录开始时间        start = time.time()        # 执行被装饰的函数并获取返回值        result = func(*args, **kwargs)        # 在执行被装饰的函数之后记录结束时间        end = time.time()        # 计算和显示被装饰函数的执行时间        print(f'{func.__name__}执行时间: {end - start:.3f}秒')        # 返回被装饰函数的返回值（装饰器通常不会改变被装饰函数的执行结果）        return result        # 返回带装饰功能的wrapper函数    return wrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用上面的装饰器函数有两种方式，第一种方式就是直接调用装饰器函数，传入被装饰的函数并获得返回值，我们可以用这个返回值直接覆盖原来的函数，那么在调用时就已经获得了装饰器提供的额外的功能（记录执行时间），大家可以试试下面的代码就明白了。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">download = record_time(download)upload = record_time(upload)download('MySQL从删库到跑路.avi')upload('Python从入门到住院.pdf')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中已经没有重复代码了，虽然写装饰器会花费一些心思，但是这是一个一劳永逸的骚操作，如果还有其他的函数也需要记录执行时间，按照上面的代码如法炮制即可。</p><p>在Python中，使用装饰器很有更为便捷的<strong>语法糖</strong>（编程语言中添加的某种语法，这种语法对语言的功能没有影响，但是使用更加方法，代码的可读性也更强，我们将其称之为“语法糖”或“糖衣语法”），可以用<code>@装饰器函数</code>将装饰器函数直接放在被装饰的函数上，效果跟上面的代码相同，下面是完整的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport timedef record_time(func):    def wrapper(*args, **kwargs):        start = time.time()        result = func(*args, **kwargs)        end = time.time()        print(f'{func.__name__}执行时间: {end - start:.3f}秒')        return result    return wrapper@record_timedef download(filename):    print(f'开始下载{filename}.')    time.sleep(random.randint(2, 6))    print(f'{filename}下载完成.')@record_timedef upload(filename):    print(f'开始上传{filename}.')    time.sleep(random.randint(4, 8))    print(f'{filename}上传完成.')download('MySQL从删库到跑路.avi')upload('Python从入门到住院.pdf')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码，我们通过装饰器语法糖为<code>download</code>和<code>upload</code>函数添加了装饰器，这样调用<code>download</code>和<code>upload</code>函数时，会记录下函数的执行时间。事实上，被装饰后的<code>download</code>和<code>upload</code>函数是我们在装饰器<code>record_time</code>中返回的<code>wrapper</code>函数，调用它们其实就是在调用<code>wrapper</code>函数，所以拥有了记录函数执行时间的功能。</p><p>如果希望取消装饰器的作用，那么在定义装饰器函数的时候，需要做一些额外的工作。Python标准库<code>functools</code>模块的<code>wraps</code>函数也是一个装饰器，我们将它放在<code>wrapper</code>函数上，这个装饰器可以帮我们保留被装饰之前的函数，这样在需要取消装饰器时，可以通过被装饰函数的<code>__wrapped__</code>属性获得被装饰之前的函数。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport timefrom functools import wrapsdef record_time(func):    @wraps(func)    def wrapper(*args, **kwargs):        start = time.time()        result = func(*args, **kwargs)        end = time.time()        print(f'{func.__name__}执行时间: {end - start:.3f}秒')        return result    return wrapper@record_timedef download(filename):    print(f'开始下载{filename}.')    time.sleep(random.randint(2, 6))    print(f'{filename}下载完成.')@record_timedef upload(filename):    print(f'开始上传{filename}.')    time.sleep(random.randint(4, 8))    print(f'{filename}上传完成.')download('MySQL从删库到跑路.avi')upload('Python从入门到住院.pdf')# 取消装饰器download.__wrapped__('MySQL必知必会.pdf')upload = upload.__wrapped__upload('Python从新手到大师.pdf')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>装饰器函数本身也可以参数化</strong>，简单的说就是通过我们的装饰器也是可以通过调用者传入的参数来定制的，这个知识点我们在后面用到它的时候再为大家讲解。</p><h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p>Python中允许函数嵌套定义，也允许函数之间相互调用，而且一个函数还可以直接或间接的调用自身。函数自己调用自己称为递归调用，那么递归调用有什么用处呢？现实中，有很多问题的定义本身就是一个递归定义，例如我们之前讲到的阶乘，非负整数<code>N</code>的阶乘是<code>N</code>乘以<code>N-1</code>的阶乘，即$ N! = N \times (N-1)! $，定义的左边和右边都出现了阶乘的概念，所以这是一个递归定义。既然如此，我们可以使用递归调用的方式来写一个求阶乘的函数，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def fac(num):    if num in (0, 1):        return 1    return num * fac(num - 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，<code>fac</code>函数中又调用了<code>fac</code>函数，这就是所谓的递归调用。代码第2行的<code>if</code>条件叫做递归的收敛条件，简单的说就是什么时候要结束函数的递归调用，在计算阶乘时，如果计算到<code>0</code>或<code>1</code>的阶乘，就停止递归调用，直接返回<code>1</code>；代码第4行的<code>num * fac(num - 1)</code>是递归公式，也就是阶乘的递归定义。下面，我们简单的分析下，如果用<code>fac(5)</code>计算<code>5</code>的阶乘，整个过程会是怎样的。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 递归调用函数入栈# 5 * fac(4)# 5 * (4 * fac(3))# 5 * (4 * (3 * fac(2)))# 5 * (4 * (3 * (2 * fac(1))))# 停止递归函数出栈# 5 * (4 * (3 * (2 * 1)))# 5 * (4 * (3 * 2))# 5 * (4 * 6)# 5 * 24# 120print(fac(5))    # 120<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，函数调用会通过内存中称为“栈”（stack）的数据结构来保存当前代码的执行现场，函数调用结束后会通过这个栈结构恢复之前的执行现场。栈是一种先进后出的数据结构，这也就意味着最早入栈的函数最后才会返回，而最后入栈的函数会最先返回。例如调用一个名为<code>a</code>的函数，函数<code>a</code>的执行体中又调用了函数<code>b</code>，函数<code>b</code>的执行体中又调用了函数<code>c</code>，那么最先入栈的函数是<code>a</code>，最先出栈的函数是<code>c</code>。每进入一个函数调用，栈就会增加一层栈帧（stack frame），栈帧就是我们刚才提到的保存当前代码执行现场的结构；每当函数调用结束后，栈就会减少一层栈帧。通常，内存中的栈空间很小，因此递归调用的次数如果太多，会导致栈溢出（stack overflow），所以<strong>递归调用一定要确保能够快速收敛</strong>。我们可以尝试执行<code>fac(5000)</code>，看看是不是会提示<code>RecursionError</code>错误，错误消息为：<code>maximum recursion depth exceeded in comparison</code>（超出最大递归深度），其实就是发生了栈溢出。</p><p>我们使用的Python官方解释器，默认将函数调用的栈结构最大深度设置为<code>1000</code>层。如果超出这个深度，就会发生上面说的<code>RecursionError</code>。当然，我们可以使用<code>sys</code>模块的<code>setrecursionlimit</code>函数来改变递归调用的最大深度，例如：<code>sys.setrecursionlimit(10000)</code>，这样就可以让上面的<code>fac(5000)</code>顺利执行出结果，但是我们不建议这样做，因为让递归快速收敛才是我们应该做的事情，否则就应该考虑使用循环递推而不是递归。</p><p>再举一个之前讲过的生成斐波那契数列的例子，因为斐波那契数列前两个数都是<code>1</code>，从第3个数开始，每个数是前两个数相加的和，可以记为<code>f(n) = f(n - 1) + f(n - 2)</code>，很显然这又是一个递归的定义，所以我们可以用下面的递归调用函数来计算第​<code>n</code>个斐波那契数。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def fib(n):    if n in (1, 2):        return 1    return fib(n - 1) + fib(n - 2)# 打印前20个斐波那契数for i in range(1, 21):    print(fib(i))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要提醒大家，上面计算斐波那契数的代码虽然看起来非常简单明了，但执行性能是比较糟糕的，原因大家可以自己思考一下，更好的做法还是之前讲过的使用循环递推的方式，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def fib(n):    a, b = 0, 1    for _ in range(n):        a, b = b, a + b    return a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>装饰器是Python中的特色语法，<strong>可以通过装饰器来增强现有的函数</strong>，这是一种非常有用的编程技巧。一些复杂的问题用函数递归调用的方式写起来真的很简单，但是<strong>函数的递归调用一定要注意收敛条件和递归公式</strong>，找到递归公式才有机会使用递归调用，而收敛条件确定了递归什么时候停下来。函数调用通过内存中的栈空间来保存现场和恢复现场，栈空间通常都很小，所以<strong>递归如果不能迅速收敛，很可能会引发栈溢出错误，从而导致程序的崩溃</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第17课：面向对象编程入门</title>
      <link href="/blog/eci7psjz.html"/>
      <url>/blog/eci7psjz.html</url>
      
        <content type="html"><![CDATA[<h2 id="第17课：面向对象编程入门"><a href="#第17课：面向对象编程入门" class="headerlink" title="第17课：面向对象编程入门"></a>第17课：面向对象编程入门</h2><p>面向对象编程是一种非常流行的<strong>编程范式</strong>（programming paradigm），所谓编程范式就是<strong>程序设计的方法论</strong>，简单的说就是程序员对程序的认知和理解以及他们编写代码的方式。</p><p>在前面的课程中，我们说过“<strong>程序是指令的集合</strong>”，运行程序时，程序中的语句会变成一条或多条指令，然后由CPU（中央处理器）去执行。为了简化程序的设计，我们又讲到了函数，<strong>把相对独立且经常重复使用的代码放置到函数中</strong>，在需要使用这些代码的时候调用函数即可。如果一个函数的功能过于复杂和臃肿，我们又可以进一步<strong>将函数进一步拆分为多个子函数</strong>来降低系统的复杂性。</p><p>不知大家是否发现，我们的编程工作其实是写程序的人按照计算机的工作方式通过代码控制机器完成任务。但是，计算机的工作方式与人类正常的思维模式是不同的，如果编程就必须抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，而“每个人都应该学习编程”的豪言壮语也就只能喊喊口号而已。这里，我想说的并不是我们不能按照计算机的工作方式去编写代码，但是当我们需要开发一个复杂的系统时，这种方式会让代码过于复杂，从而导致开发和维护工作都变得举步维艰。</p><p>随着软件复杂性的增加，编写正确可靠的代码会变成了一项极为艰巨的任务，这也是很多人都坚信“软件开发是人类改造世界所有活动中最为复杂的活动”的原因。如何用程序描述复杂系统和解决复杂问题，就成为了所有程序员必须要思考和直面的问题。诞生于上世纪70年代的Smalltalk语言让软件开发者看到了希望，因为它引入了一种新的编程范式叫面向对象编程。在面向对象编程的世界里，程序中的<strong>数据和操作数据的函数是一个逻辑上的整体</strong>，我们称之为<strong>对象</strong>，<strong>对象可以接收消息</strong>，解决问题的方法就是<strong>创建对象并向对象发出各种各样的消息</strong>；通过消息传递，程序中的多个对象可以协同工作，这样就能构造出复杂的系统并解决现实中的问题。当然，面向对象编程的雏形还可以向前追溯到更早期的Simula语言，但这不是我们现在要讨论的重点。</p><blockquote><p><strong>说明：</strong> 今天我们使用的很多高级程序设计语言都支持面向对象编程，但是面向对象编程也不是解决软件开发中所有问题的“银弹”，或者说在软件开发这个行业目前还找不到这种所谓的“银弹”。关于这个问题，大家可以参考IBM360系统之父弗雷德里克·布鲁克斯所发表的论文《没有银弹：软件工程的本质性与附属性工作》或软件工程的经典著作《人月神话》一书。</p></blockquote><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>如果要用一句话来概括面向对象编程，我认为下面的说法是相当精辟和准确的。</p><blockquote><p><strong>面向对象编程</strong>：把一组数据和处理数据的方法组成<strong>对象</strong>，把行为相同的对象归纳为<strong>类</strong>，通过<strong>封装</strong>隐藏对象的内部细节，通过<strong>继承</strong>实现类的特化和泛化，通过<strong>多态</strong>实现基于对象类型的动态分派。</p></blockquote><p>这句话对初学者来说可能不那么容易理解，但是我可以先为大家圈出几个关键词：<strong>对象</strong>（object）、<strong>类</strong>（class）、<strong>封装</strong>（encapsulation）、<strong>继承</strong>（inheritance）、<strong>多态</strong>（polymorphism）。</p><p>我们先说说类和对象这两个词。在面向对象编程中，<strong>类是一个抽象的概念，对象是一个具体的概念</strong>。我们把同一类对象的共同特征抽取出来就是一个类，比如我们经常说的人类，这是一个抽象概念，而我们每个人就是人类的这个抽象概念下的实实在在的存在，也就是一个对象。简而言之，<strong>类是对象的蓝图和模板，对象是类的实例，是可以接受消息的实体</strong>。</p><p>在面向对象编程的世界中，<strong>一切皆为对象</strong>，<strong>对象都有属性和行为</strong>，<strong>每个对象都是独一无二的</strong>，而且<strong>对象一定属于某个类</strong>。对象的属性是对象的静态特征，对象的行为是对象的动态特征。按照上面的说法，如果我们把拥有共同特征的对象的属性和行为都抽取出来，就可以定义出一个类。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210731182741.png" width="75%"><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>在Python中，可以使用<code>class</code>关键字加上类名来定义类，通过缩进我们可以确定类的代码块，就如同定义函数那样。在类的代码块中，我们需要写一些函数，我们说过类是一个抽象概念，那么这些函数就是我们对一类对象共同的动态特征的提取。写在类里面的函数我们通常称之为<strong>方法</strong>，方法就是对象的行为，也就是对象可以接收的消息。方法的第一个参数通常都是<code>self</code>，它代表了接收这个消息的对象本身。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Student:    def study(self, course_name):        print(f'学生正在学习{course_name}.')    def play(self):        print(f'学生正在玩游戏.')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h3><p>在我们定义好一个类之后，可以使用构造器语法来创建对象，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">stu1 = Student()stu2 = Student()print(stu1)    # &lt;__main__.Student object at 0x10ad5ac50&gt;print(stu2)    # &lt;__main__.Student object at 0x10ad5acd0&gt; print(hex(id(stu1)), hex(id(stu2)))    # 0x10ad5ac50 0x10ad5acd0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在类的名字后跟上圆括号就是所谓的构造器语法，上面的代码创建了两个学生对象，一个赋值给变量<code>stu1</code>，一个复制给变量<code>stu2</code>。当我们用<code>print</code>函数打印<code>stu1</code>和<code>stu2</code>两个变量时，我们会看到输出了对象在内存中的地址（十六进制形式），跟我们用<code>id</code>函数查看对象标识获得的值是相同的。现在我们可以告诉大家，我们定义的变量其实保存的是一个对象在内存中的逻辑地址（位置），通过这个逻辑地址，我们就可以在内存中找到这个对象。所以<code>stu3 = stu2</code>这样的赋值语句并没有创建新的对象，只是用一个新的变量保存了已有对象的地址。</p><p>接下来，我们尝试给对象发消息，即调用对象的方法。刚才的<code>Student</code>类中我们定义了<code>study</code>和<code>play</code>两个方法，两个方法的第一个参数<code>self</code>代表了接收消息的学生对象，<code>study</code>方法的第二个参数是学习的课程名称。Python中，给对象发消息有两种方式，请看下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 通过“类.方法”调用方法，第一个参数是接收消息的对象，第二个参数是学习的课程名称Student.study(stu1, 'Python程序设计')    # 学生正在学习Python程序设计.# 通过“对象.方法”调用方法，点前面的对象就是接收消息的对象，只需要传入第二个参数stu1.study('Python程序设计')             # 学生正在学习Python程序设计.Student.play(stu2)    # 学生正在玩游戏.stu2.play()           # 学生正在玩游戏. <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><p>大家可能已经注意到了，刚才我们创建的学生对象只有行为没有属性，如果要给学生对象定义属性，我们可以修改<code>Student</code>类，为其添加一个名为<code>__init__</code>的方法。在我们调用<code>Student</code>类的构造器创建对象时，首先会在内存中获得保存学生对象所需的内存空间，然后通过自动执行<code>__init__</code>方法，完成对内存的初始化操作，也就是把数据放到内存空间中。所以我们可以通过给<code>Student</code>类添加<code>__init__</code>方法的方式为学生对象指定属性，同时完成对属性赋初始值的操作，正因如此，<code>__init__</code>方法通常也被称为初始化方法。</p><p>我们对上面的<code>Student</code>类稍作修改，给学生对象添加<code>name</code>（姓名）和<code>age</code>（年龄）两个属性。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Student:    """学生"""    def __init__(self, name, age):        """初始化方法"""        self.name = name        self.age = age    def study(self, course_name):        """学习"""        print(f'{self.name}正在学习{course_name}.')    def play(self):        """玩耍"""        print(f'{self.name}正在玩游戏.')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改刚才创建对象和给对象发消息的代码，重新执行一次，看看程序的执行结果有什么变化。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 由于初始化方法除了self之外还有两个参数# 所以调用Student类的构造器创建对象时要传入这两个参数stu1 = Student('骆昊', 40)stu2 = Student('王大锤', 15)stu1.study('Python程序设计')    # 骆昊正在学习Python程序设计.stu2.play()                    # 王大锤正在玩游戏.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打印对象"><a href="#打印对象" class="headerlink" title="打印对象"></a>打印对象</h3><p>上面我们通过<code>__init__</code>方法在创建对象时为对象绑定了属性并赋予了初始值。在Python中，以两个下划线<code>__</code>（读作“dunder”）开头和结尾的方法通常都是有特殊用途和意义的方法，我们一般称之为<strong>魔术方法</strong>或<strong>魔法方法</strong>。如果我们在打印对象的时候不希望看到对象的地址而是看到我们自定义的信息，可以通过在类中放置<code>__repr__</code>魔术方法来做到，该方法返回的字符串就是用<code>print</code>函数打印对象的时候会显示的内容，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Student:    """学生"""    def __init__(self, name, age):        """初始化方法"""        self.name = name        self.age = age    def study(self, course_name):        """学习"""        print(f'{self.name}正在学习{course_name}.')    def play(self):        """玩耍"""        print(f'{self.name}正在玩游戏.')        def __repr__(self):        return f'{self.name}: {self.age}'stu1 = Student('骆昊', 40)print(stu1)        # 骆昊: 40students = [stu1, Student('李元芳', 36), Student('王大锤', 25)]print(students)    # [骆昊: 40, 李元芳: 36, 王大锤: 25]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面向对象的支柱"><a href="#面向对象的支柱" class="headerlink" title="面向对象的支柱"></a>面向对象的支柱</h3><p>面向对象编程有三大支柱，就是我们之前给大家划重点的时候圈出的三个词：<strong>封装</strong>、<strong>继承</strong>和<strong>多态</strong>。后面两个概念在下一节课中会详细说明，这里我们先说一下什么是封装。我自己对封装的理解是：<strong>隐藏一切可以隐藏的实现细节，只向外界暴露简单的调用接口</strong>。我们在类中定义的对象方法其实就是一种封装，这种封装可以让我们在创建对象之后，只需要给对象发送一个消息就可以执行方法中的代码，也就是说我们在只知道方法的名字和参数（方法的外部视图），不知道方法内部实现细节（方法的内部视图）的情况下就完成了对方法的使用。</p><p>举一个例子，假如要控制一个机器人帮我倒杯水，如果不使用面向对象编程，不做任何的封装，那么就需要向这个机器人发出一系列的指令，如站起来、向左转、向前走5步、拿起面前的水杯、向后转、向前走10步、弯腰、放下水杯、按下出水按钮、等待10秒、松开出水按钮、拿起水杯、向右转、向前走5步、放下水杯等，才能完成这个简单的操作，想想都觉得麻烦。按照面向对象编程的思想，我们可以将倒水的操作封装到机器人的一个方法中，当需要机器人帮我们倒水的时候，只需要向机器人对象发出倒水的消息就可以了，这样做不是更好吗？</p><p>在很多场景下，面向对象编程其实就是一个三步走的问题。第一步定义类，第二步创建对象，第三步给对象发消息。当然，有的时候我们是不需要第一步的，因为我们想用的类可能已经存在了。之前我们说过，Python内置的<code>list</code>、<code>set</code>、<code>dict</code>其实都不是函数而是类，如果要创建列表、集合、字典对象，我们就不用自定义类了。当然，有的类并不是Python标准库中直接提供的，它可能来自于第三方的代码，如何安装和使用三方代码在后续课程中会进行讨论。在某些特殊的场景中，我们会用到名为“内置对象”的对象，所谓“内置对象”就是说上面三步走的第一步和第二步都不需要了，因为类已经存在而且对象已然创建过了，直接向对象发消息就可以了，这也就是我们常说的“开箱即用”。</p><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><h4 id="案例1：定义一个类描述数字时钟。"><a href="#案例1：定义一个类描述数字时钟。" class="headerlink" title="案例1：定义一个类描述数字时钟。"></a>案例1：定义一个类描述数字时钟。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import time# 定义数字时钟类class Clock(object):    """数字时钟"""    def __init__(self, hour=0, minute=0, second=0):        """初始化方法        :param hour: 时        :param minute: 分        :param second: 秒        """        self.hour = hour        self.min = minute        self.sec = second    def run(self):        """走字"""        self.sec += 1        if self.sec == 60:            self.sec = 0            self.min += 1            if self.min == 60:                self.min = 0                self.hour += 1                if self.hour == 24:                    self.hour = 0    def show(self):        """显示时间"""        return f'{self.hour:0&gt;2d}:{self.min:0&gt;2d}:{self.sec:0&gt;2d}'# 创建时钟对象clock = Clock(23, 59, 58)while True:    # 给时钟对象发消息读取时间    print(clock.show())    # 休眠1秒钟    time.sleep(1)    # 给时钟对象发消息使其走字    clock.run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="案例2：定义一个类描述平面上的点，要求提供计算到另一个点距离的方法。"><a href="#案例2：定义一个类描述平面上的点，要求提供计算到另一个点距离的方法。" class="headerlink" title="案例2：定义一个类描述平面上的点，要求提供计算到另一个点距离的方法。"></a>案例2：定义一个类描述平面上的点，要求提供计算到另一个点距离的方法。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Point(object):    """屏面上的点"""    def __init__(self, x=0, y=0):        """初始化方法        :param x: 横坐标        :param y: 纵坐标        """        self.x, self.y = x, y    def distance_to(self, other):        """计算与另一个点的距离        :param other: 另一个点        """        dx = self.x - other.x        dy = self.y - other.y        return (dx * dx + dy * dy) ** 0.5    def __str__(self):        return f'({self.x}, {self.y})'p1 = Point(3, 5)p2 = Point(6, 9)print(p1, p2)print(p1.distance_to(p2))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>面向对象编程是一种非常流行的编程范式，除此之外还有<strong>指令式编程</strong>、<strong>函数式编程</strong>等编程范式。由于现实世界是由对象构成的，而对象是可以接收消息的实体，所以<strong>面向对象编程更符合人类正常的思维习惯</strong>。类是抽象的，对象是具体的，有了类就能创建对象，有了对象就可以接收消息，这就是面向对象编程的基础。定义类的过程是一个抽象的过程，找到对象公共的属性属于数据抽象，找到对象公共的方法属于行为抽象。抽象的过程是一个仁者见仁智者见智的过程，对同一类对象进行抽象可能会得到不同的结果，如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210731182914.png" width="75%"><blockquote><p><strong>说明：</strong> 本节课的插图来自于 Grady Booc 等撰写的《面向对象分析与设计》一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第18课：面向对象编程进阶</title>
      <link href="/blog/autilscp.html"/>
      <url>/blog/autilscp.html</url>
      
        <content type="html"><![CDATA[<h2 id="第18课：面向对象编程进阶"><a href="#第18课：面向对象编程进阶" class="headerlink" title="第18课：面向对象编程进阶"></a>第18课：面向对象编程进阶</h2><p>上一节课我们讲解了Python面向对象编程的基础知识，这一节课我们继续来讨论面向对象编程相关的内容。</p><h3 id="可见性和属性装饰器"><a href="#可见性和属性装饰器" class="headerlink" title="可见性和属性装饰器"></a>可见性和属性装饰器</h3><p>在很多面向对象编程语言中，对象的属性通常会被设置为私有（private）或受保护（protected）的成员，简单的说就是不允许直接访问这些属性；对象的方法通常都是公开的（public），因为公开的方法是对象能够接受的消息，也是对象暴露给外界的调用接口，这就是所谓的访问可见性。在Python中，可以通过给对象属性名添加前缀下划线的方式来说明属性的访问可见性，例如，可以用<code>__name</code>表示一个私有属性，<code>_name</code>表示一个受保护属性，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Student:    def __init__(self, name, age):        self.__name = name        self.__age = age    def study(self, course_name):        print(f'{self.__name}正在学习{course_name}.')stu = Student('王大锤', 20)stu.study('Python程序设计')print(stu.__name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码的最后一行会引发<code>AttributeError</code>（属性错误）异常，异常消息为：<code>'Student' object has no attribute '__name'</code>。由此可见，以<code>__</code>开头的属性<code>__name</code>是私有的，在类的外面无法直接访问，但是类里面的<code>study</code>方法中可以通过<code>self.__name</code>访问该属性。</p><p>需要提醒大家的是，Python并没有从语法上严格保证私有属性的私密性，它只是给私有的属性和方法换了一个名字来阻挠对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，我们可以对上面的代码稍作修改就可以访问到私有的属性。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Student:    def __init__(self, name, age):        self.__name = name        self.__age = age    def study(self, course_name):        print(f'{self.__name}正在学习{course_name}.')stu = Student('王大锤', 20)stu.study('Python程序设计')print(stu._Student__name, stu._Student__age)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python中有一句名言：“<strong>We are all consenting adults here</strong>”（大家都是成年人）。Python语言的设计者认为程序员要为自己的行为负责，而不是由Python语言本身来严格限制访问可见性，而大多数的程序员都认为<strong>开放比封闭要好</strong>，把对象的属性私有化并不是编程语言必须的东西，所以Python并没有从语法上做出最严格的限定。</p><p>Python中可以通过<code>property</code>装饰器为“私有”属性提供读取和修改的方法，之前我们提到过，装饰器通常会放在类、函数或方法的声明之前，通过一个<code>@</code>符号表示将装饰器应用于类、函数或方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Student:    def __init__(self, name, age):        self.__name = name        self.__age = age    # 属性访问器(getter方法) - 获取__name属性    @property    def name(self):        return self.__name        # 属性修改器(setter方法) - 修改__name属性    @name.setter    def name(self, name):        # 如果name参数不为空就赋值给对象的__name属性        # 否则将__name属性赋值为'无名氏'，有两种写法        # self.__name = name if name else '无名氏'        self.__name = name or '无名氏'        @property    def age(self):        return self.__agestu = Student('王大锤', 20)print(stu.name, stu.age)    # 王大锤 20stu.name = ''print(stu.name)    # 无名氏# stu.age = 30     # AttributeError: can't set attribute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际项目开发中，我们并不经常使用私有属性，属性装饰器的使用也比较少，所以上面的知识点大家简单了解一下就可以了。</p><h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>Python是一门动态语言，维基百科对动态语言的解释是：“在运行时可以改变其结构的语言，例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。动态语言非常灵活，目前流行的Python和JavaScript都是动态语言，除此之外如PHP、Ruby等也都属于动态语言，而C、C++等语言则不属于动态语言”。</p><p>在Python中，我们可以动态为对象添加属性，这是Python作为动态类型语言的一项特权，代码如下所示。需要提醒大家的是，对象的方法其实本质上也是对象的属性，如果给对象发送一个无法接收的消息，引发的异常仍然是<code>AttributeError</code>。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Student:    def __init__(self, name, age):        self.name = name        self.age = agestu = Student('王大锤', 20)# 为Student对象动态添加sex属性stu.sex = '男'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不希望在使用对象时动态的为对象添加属性，可以使用Python的<code>__slots__</code>魔法。对于<code>Student</code>类来说，可以在类中指定<code>__slots__ = ('name', 'age')</code>，这样<code>Student</code>类的对象只能有<code>name</code>和<code>age</code>属性，如果想动态添加其他属性将会引发异常，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Student:    __slots__ = ('name', 'age')    def __init__(self, name, age):        self.name = name        self.age = agestu = Student('王大锤', 20)# AttributeError: 'Student' object has no attribute 'sex'stu.sex = '男'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h3><p>之前我们在类中定义的方法都是对象方法，换句话说这些方法都是对象可以接收的消息。除了对象方法之外，类中还可以有静态方法和类方法，这两类方法是发给类的消息，二者并没有实质性的区别。在面向对象的世界里，一切皆为对象，我们定义的每一个类其实也是一个对象，而静态方法和类方法就是发送给类对象的消息。那么，什么样的消息会直接发送给类对象呢？</p><p>举一个例子，定义一个三角形类，通过传入三条边的长度来构造三角形，并提供计算周长和面积的方法。计算周长和面积肯定是三角形对象的方法，这一点毫无疑问。但是在创建三角形对象时，传入的三条边长未必能构造出三角形，为此我们可以先写一个方法来验证给定的三条边长是否可以构成三角形，这种方法很显然就不是对象方法，因为在调用这个方法时三角形对象还没有创建出来。我们可以把这类方法设计为静态方法或类方法，也就是说这类方法不是发送给三角形对象的消息，而是发送给三角形类的消息，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Triangle(object):    """三角形类"""    def __init__(self, a, b, c):        """初始化方法"""        self.a = a        self.b = b        self.c = c    @staticmethod    def is_valid(a, b, c):        """判断三条边长能否构成三角形(静态方法)"""        return a + b &gt; c and b + c &gt; a and a + c &gt; b    # @classmethod    # def is_valid(cls, a, b, c):    #     """判断三条边长能否构成三角形(类方法)"""    #     return a + b &gt; c and b + c &gt; a and a + c &gt; b    def perimeter(self):        """计算周长"""        return self.a + self.b + self.c    def area(self):        """计算面积"""        p = self.perimeter() / 2        return (p * (p - self.a) * (p - self.b) * (p - self.c)) ** 0.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码使用<code>staticmethod</code>装饰器声明了<code>is_valid</code>方法是<code>Triangle</code>类的静态方法，如果要声明类方法，可以使用<code>classmethod</code>装饰器。可以直接使用<code>类名.方法名</code>的方式来调用静态方法和类方法，二者的区别在于，类方法的第一个参数是类对象本身，而静态方法则没有这个参数。简单的总结一下，<strong>对象方法、类方法、静态方法都可以通过<code>类名.方法名</code>的方式来调用，区别在于方法的第一个参数到底是普通对象还是类对象，还是没有接受消息的对象</strong>。静态方法通常也可以直接写成一个独立的函数，因为它并没有跟特定的对象绑定。</p><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p>面向对象的编程语言支持在已有类的基础上创建新类，从而减少重复代码的编写。提供继承信息的类叫做父类（超类、基类），得到继承信息的类叫做子类（派生类、衍生类）。例如，我们定义一个学生类和一个老师类，我们会发现他们有大量的重复代码，而这些重复代码都是老师和学生作为人的公共属性和行为，所以在这种情况下，我们应该先定义人类，再通过继承，从人类派生出老师类和学生类，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Person:    """人类"""    def __init__(self, name, age):        self.name = name        self.age = age        def eat(self):        print(f'{self.name}正在吃饭.')        def sleep(self):        print(f'{self.name}正在睡觉.')class Student(Person):    """学生类"""        def __init__(self, name, age):        # super(Student, self).__init__(name, age)        super().__init__(name, age)        def study(self, course_name):        print(f'{self.name}正在学习{course_name}.')class Teacher(Person):    """老师类"""    def __init__(self, name, age, title):        # super(Teacher, self).__init__(name, age)        super().__init__(name, age)        self.title = title        def teach(self, course_name):        print(f'{self.name}{self.title}正在讲授{course_name}.')stu1 = Student('白元芳', 21)stu2 = Student('狄仁杰', 22)teacher = Teacher('武则天', 35, '副教授')stu1.eat()stu2.sleep()teacher.teach('Python程序设计')stu1.study('Python程序设计')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继承的语法是在定义类的时候，在类名后的圆括号中指定当前类的父类。如果定义一个类的时候没有指定它的父类是谁，那么默认的父类是<code>object</code>类。<code>object</code>类是Python中的顶级类，这也就意味着所有的类都是它的子类，要么直接继承它，要么间接继承它。Python语言允许多重继承，也就是说一个类可以有一个或多个父类，关于多重继承的问题我们在后面会有更为详细的讨论。在子类的初始化方法中，我们可以通过<code>super().__init__()</code>来调用父类初始化方法，<code>super</code>函数是Python内置函数中专门为获取当前对象的父类对象而设计的。从上面的代码可以看出，子类除了可以通过继承得到父类提供的属性和方法外，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力。在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，也叫做“里氏替换原则”（Liskov Substitution Principle）。</p><p>子类继承父类的方法后，还可以对方法进行重写（重新实现该方法），不同的子类可以对父类的同一个方法给出不同的实现版本，这样的方法在程序运行时就会表现出多态行为（调用相同的方法，做了不同的事情）。多态是面向对象编程中最精髓的部分，当然也是对初学者来说最难以理解和灵活运用的部分，我们会在下一节课中用专门的例子来讲解多态这个知识点。</p><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python是动态语言，Python中的对象可以动态的添加属性。在面向对象的世界中，<strong>一切皆为对象</strong>，我们定义的类也是对象，所以<strong>类也可以接收消息</strong>，对应的方法是类方法或静态方法。通过继承，我们<strong>可以从已有的类创建新类</strong>，实现对已有类代码的复用。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第19课：面向对象编程应用</title>
      <link href="/blog/qadm5tc2.html"/>
      <url>/blog/qadm5tc2.html</url>
      
        <content type="html"><![CDATA[<h2 id="第19课：面向对象编程应用"><a href="#第19课：面向对象编程应用" class="headerlink" title="第19课：面向对象编程应用"></a>第19课：面向对象编程应用</h2><p>面向对象编程对初学者来说不难理解但很难应用，虽然我们为大家总结过面向对象的三步走方法（定义类、创建对象、给对象发消息），但是说起来容易做起来难。<strong>大量的编程练习</strong>和<strong>阅读优质的代码</strong>可能是这个阶段最能够帮助到大家的两件事情。接下来我们还是通过经典的案例来剖析面向对象编程的知识，同时也通过这些案例为大家讲解如何运用之前学过的Python知识。</p><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><h4 id="案例1：扑克游戏。"><a href="#案例1：扑克游戏。" class="headerlink" title="案例1：扑克游戏。"></a>案例1：扑克游戏。</h4><blockquote><p><strong>说明</strong>：简单起见，我们的扑克只有52张牌（没有大小王），游戏需要将52张牌发到4个玩家的手上，每个玩家手上有13张牌，按照黑桃、红心、草花、方块的顺序和点数从小到大排列，暂时不实现其他的功能。</p></blockquote><p>使用面向对象编程方法，首先需要从问题的需求中找到对象并抽象出对应的类，此外还要找到对象的属性和行为。当然，这件事情并不是特别困难，我们可以从需求的描述中找出名词和动词，名词通常就是对象或者是对象的属性，而动词通常是对象的行为。扑克游戏中至少应该有三类对象，分别是牌、扑克和玩家，牌、扑克、玩家三个类也并不是孤立的。类和类之间的关系可以粗略的分为<strong>is-a关系（继承）</strong>、<strong>has-a关系（关联）</strong>和<strong>use-a关系（依赖）</strong>。很显然扑克和牌是has-a关系，因为一副扑克有（has-a）52张牌；玩家和牌之间不仅有关联关系还有依赖关系，因为玩家手上有（has-a）牌而且玩家使用了（use-a）牌。</p><p>牌的属性显而易见，有花色和点数。我们可以用0到3的四个数字来代表四种不同的花色，但是这样的代码可读性会非常糟糕，因为我们并不知道黑桃、红心、草花、方块跟0到3的数字的对应关系。如果一个变量的取值只有有限多个选项，我们可以使用枚举。与C、Java等语言不同的是，Python中没有声明枚举类型的关键字，但是可以通过继承<code>enum</code>模块的<code>Enum</code>类来创建枚举类型，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from enum import Enumclass Suite(Enum):    """花色(枚举)"""    SPADE, HEART, CLUB, DIAMOND = range(4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码可以看出，定义枚举类型其实就是定义符号常量，如<code>SPADE</code>、<code>HEART</code>等。每个符号常量都有与之对应的值，这样表示黑桃就可以不用数字<code>0</code>，而是用<code>Suite.SPADE</code>；同理，表示方块可以不用数字<code>3</code>， 而是用<code>Suite.DIAMOND</code>。注意，使用符号常量肯定是优于使用字面常量的，因为能够读懂英文就能理解符号常量的含义，代码的可读性会提升很多。Python中的枚举类型是可迭代类型，简单的说就是可以将枚举类型放到<code>for-in</code>循环中，依次取出每一个符号常量及其对应的值，如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">for suite in Suite:    print(f'{suite}: {suite.value}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来我们可以定义牌类。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Card:    """牌"""    def __init__(self, suite, face):        self.suite = suite        self.face = face    def __repr__(self):        suites = '♠♥♣♦'        faces = ['', 'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']        # 根据牌的花色和点数取到对应的字符        return f'{suites[self.suite.value]}{faces[self.face]}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过下面的代码来测试下<code>Card</code>类。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">card1 = Card(Suite.SPADE, 5)card2 = Card(Suite.HEART, 13)print(card1, card2)    # ♠5 ♥K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来我们定义扑克类。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomclass Poker:    """扑克"""    def __init__(self):        # 通过列表的生成式语法创建一个装52张牌的列表        self.cards = [Card(suite, face) for suite in Suite                      for face in range(1, 14)]        # current属性表示发牌的位置        self.current = 0    def shuffle(self):        """洗牌"""        self.current = 0        # 通过random模块的shuffle函数实现列表的随机乱序        random.shuffle(self.cards)    def deal(self):        """发牌"""        card = self.cards[self.current]        self.current += 1        return card    @property    def has_next(self):        """还有没有牌可以发"""        return self.current &lt; len(self.cards)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过下面的代码来测试下<code>Poker</code>类。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">poker = Poker()poker.shuffle()print(poker.cards)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义玩家类。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Player:    """玩家"""    def __init__(self, name):        self.name = name        self.cards = []    def get_one(self, card):        """摸牌"""        self.cards.append(card)    def arrange(self):        self.cards.sort()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建四个玩家并将牌发到玩家的手上。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">poker = Poker()poker.shuffle()players = [Player('东邪'), Player('西毒'), Player('南帝'), Player('北丐')]for _ in range(13):    for player in players:        player.get_one(poker.deal())for player in players:    player.arrange()    print(f'{player.name}: ', end='')    print(player.cards)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上面的代码会在<code>player.arrange()</code>那里出现异常，因为<code>Player</code>的<code>arrange</code>方法使用了列表的<code>sort</code>对玩家手上的牌进行排序，排序需要比较两个<code>Card</code>对象的大小，而<code>&lt;</code>运算符又不能直接作用于<code>Card</code>类型，所以就出现了<code>TypeError</code>异常，异常消息为：<code>'&lt;' not supported between instances of 'Card' and 'Card'</code>。</p><p>为了解决这个问题，我们可以对<code>Card</code>类的代码稍作修改，使得两个<code>Card</code>对象可以直接用<code>&lt;</code>进行大小的比较。这里用到技术叫<strong>运算符重载</strong>，Python中要实现对<code>&lt;</code>运算符的重载，需要在类中添加一个名为<code>__lt__</code>的魔术方法。很显然，魔术方法<code>__lt__</code>中的<code>lt</code>是英文单词“less than”的缩写，以此类推，魔术方法<code>__gt__</code>对应<code>&gt;</code>运算符，魔术方法<code>__le__</code>对应<code>&lt;=</code>运算符，<code>__ge__</code>对应<code>&gt;=</code>运算符，<code>__eq__</code>对应<code>==</code>运算符，<code>__ne__</code>对应<code>!=</code>运算符。</p><p>修改后的<code>Card</code>类代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Card:    """牌"""    def __init__(self, suite, face):        self.suite = suite        self.face = face    def __repr__(self):        suites = '♠♥♣♦'        faces = ['', 'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']        # 根据牌的花色和点数取到对应的字符        return f'{suites[self.suite.value]}{faces[self.face]}'        def __lt__(self, other):        # 花色相同比较点数的大小        if self.suite == other.suite:            return self.face &lt; other.face        # 花色不同比较花色对应的值        return self.suite.value &lt; other.suite.value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明：</strong> 大家可以尝试在上面代码的基础上写一个简单的扑克游戏，如21点游戏（Black Jack），游戏的规则可以自己在网上找一找。</p></blockquote><h4 id="案例2：工资结算系统。"><a href="#案例2：工资结算系统。" class="headerlink" title="案例2：工资结算系统。"></a>案例2：工资结算系统。</h4><blockquote><p><strong>要求</strong>：某公司有三种类型的员工，分别是部门经理、程序员和销售员。需要设计一个工资结算系统，根据提供的员工信息来计算员工的月薪。其中，部门经理的月薪是固定15000元；程序员按工作时间（以小时为单位）支付月薪，每小时200元；销售员的月薪由1800元底薪加上销售额5%的提成两部分构成。</p></blockquote><p>通过对上述需求的分析，可以看出部门经理、程序员、销售员都是员工，有相同的属性和行为，那么我们可以先设计一个名为<code>Employee</code>的父类，再通过继承的方式从这个父类派生出部门经理、程序员和销售员三个子类。很显然，后续的代码不会创建<code>Employee</code> 类的对象，因为我们需要的是具体的员工对象，所以这个类可以设计成专门用于继承的抽象类。Python中没有定义抽象类的关键字，但是可以通过<code>abc</code>模块中名为<code>ABCMeta</code> 的元类来定义抽象类。关于元类的知识，后面的课程中会有专门的讲解，这里不用太纠结这个概念，记住用法即可。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from abc import ABCMeta, abstractmethodclass Employee(metaclass=ABCMeta):    """员工"""    def __init__(self, name):        self.name = name    @abstractmethod    def get_salary(self):        """结算月薪"""        pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的员工类中，有一个名为<code>get_salary</code>的方法用于结算月薪，但是由于还没有确定是哪一类员工，所以结算月薪虽然是员工的公共行为但这里却没有办法实现。对于暂时无法实现的方法，我们可以使用<code>abstractmethod</code>装饰器将其声明为抽象方法，所谓<strong>抽象方法就是只有声明没有实现的方法</strong>，<strong>声明这个方法是为了让子类去重写这个方法</strong>。接下来的代码展示了如何从员工类派生出部门经理、程序员、销售员这三个子类以及子类如何重写父类的抽象方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Manager(Employee):    """部门经理"""    def get_salary(self):        return 15000.0class Programmer(Employee):    """程序员"""    def __init__(self, name, working_hour=0):        super().__init__(name)        self.working_hour = working_hour    def get_salary(self):        return 200 * self.working_hourclass Salesman(Employee):    """销售员"""    def __init__(self, name, sales=0):        super().__init__(name)        self.sales = sales    def get_salary(self):        return 1800 + self.sales * 0.05<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>Manager</code>、<code>Programmer</code>、<code>Salesman</code>三个类都继承自<code>Employee</code>，三个类都分别重写了<code>get_salary</code>方法。<strong>重写就是子类对父类已有的方法重新做出实现</strong>。相信大家已经注意到了，三个子类中的<code>get_salary</code>各不相同，所以这个方法在程序运行时会产生<strong>多态行为</strong>，多态简单的说就是<strong>调用相同的方法</strong>，<strong>不同的子类对象做不同的事情</strong>。</p><p>我们通过下面的代码来完成这个工资结算系统，由于程序员和销售员需要分别录入本月的工作时间和销售额，所以在下面的代码中我们使用了Python内置的<code>isinstance</code>函数来判断员工对象的类型。我们之前讲过的<code>type</code>函数也能识别对象的类型，但是<code>isinstance</code>函数更加强大，因为它可以判断出一个对象是不是某个继承结构下的子类型，你可以简答的理解为<code>type</code>函数是对对象类型的精准匹配，而<code>isinstance</code>函数是对对象类型的模糊匹配。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">emps = [    Manager('刘备'), Programmer('诸葛亮'), Manager('曹操'),     Programmer('荀彧'), Salesman('吕布'), Programmer('张辽'),]for emp in emps:    if isinstance(emp, Programmer):        emp.working_hour = int(input(f'请输入{emp.name}本月工作时间: '))    elif isinstance(emp, Salesman):        emp.sales = float(input(f'请输入{emp.name}本月销售额: '))    print(f'{emp.name}本月工资为: ￥{emp.get_salary():.2f}元')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>面向对象的编程思想非常的好，也符合人类的正常思维习惯，但是要想灵活运用面向对象编程中的抽象、封装、继承、多态需要长时间的积累和沉淀，这件事情无法一蹴而就，属于“路漫漫其修远兮，吾将上下而求索”的东西。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第20课：Python标准库初探</title>
      <link href="/blog/gyioqt1s.html"/>
      <url>/blog/gyioqt1s.html</url>
      
        <content type="html"><![CDATA[<h2 id="第20课：Python标准库初探"><a href="#第20课：Python标准库初探" class="headerlink" title="第20课：Python标准库初探"></a>第20课：Python标准库初探</h2><p>Python语言最可爱的地方在于它的标准库和三方库实在是太丰富了，日常开发工作中的很多任务都可以通过这些标准库或者三方库直接解决。下面我们先介绍Python标准库中的一些常用模块，后面的课程中再陆陆续续为大家介绍Python常用三方库的用途和用法。</p><h3 id="base64-Base64编解码模块"><a href="#base64-Base64编解码模块" class="headerlink" title="base64 - Base64编解码模块"></a>base64 - Base64编解码模块</h3><p><strong>Base64</strong>是一种基于64个可打印字符来表示二进制数据的方法。由于$log _{2}64=6$，所以Base64以6个比特（二进制位，可以表示0或1）为一个单元，每个单元对应一个可打印字符。对于3字节（24比特）的二进制数据，我们可以将其处理成对应于4个Base64单元，即3个字节可由4个可打印字符来表示。Base64编码可用来作为电子邮件的传输编码，也可以用于其他需要将二进制数据转成文本字符的场景，这使得在XML、JSON、YAML这些文本数据格式中传输二进制内容成为可能。在Base64中的可打印字符包括<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>，这里一共是62个字符，另外两个可打印符号通常是<code>+</code>和<code>/</code>，<code>=</code>用于在Base64编码最后进行补位。</p><p>关于Base64编码的细节，大家可以参考<a href="http://www.ruanyifeng.com/blog/2008/06/base64.html">《Base64笔记》</a>一文，Python标准库中的<code>base64</code>模块提供了<code>b64encode</code>和<code>b64decode</code>两个函数，专门用于实现Base64的编码和解码，下面演示了在<strong>Python的交互式环境</strong>中执行这两个函数的效果。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; import base64&gt;&gt;&gt; &gt;&gt;&gt; content = 'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.'&gt;&gt;&gt; base64.b64encode(content.encode())b'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4='&gt;&gt;&gt; content = b'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4='&gt;&gt;&gt; base64.b64decode(content).decode()'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="collections-容器数据类型模块"><a href="#collections-容器数据类型模块" class="headerlink" title="collections - 容器数据类型模块"></a>collections - 容器数据类型模块</h3><p><code>collections</code>模块提供了诸多非常好用的数据结构，主要包括：</p><ul><li><code>namedtuple</code>：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。</li><li><code>deque</code>：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而<code>deque</code>底层是双向链表，因此当你需要在头尾添加和删除元素是，<code>deque</code>会表现出更好的性能，渐近时间复杂度为$O(1)$。</li><li><code>Counter</code>：<code>dict</code>的子类，键是元素，值是元素的计数，它的<code>most_common()</code>方法可以帮助我们获取出现频率最高的元素。<code>Counter</code>和<code>dict</code>的继承关系我认为是值得商榷的，按照CARP原则，<code>Counter</code>跟<code>dict</code>的关系应该设计为关联关系更为合理。</li><li><code>OrderedDict</code>：<code>dict</code>的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。</li><li><code>defaultdict</code>：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的<code>setdefault()</code>方法，这种做法更加高效。</li></ul><p>下面是在<strong>Python交互式环境中</strong>使用<code>namedtuple</code>创建扑克牌类的例子。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt;&gt;&gt;&gt; Card = namedtuple('Card', ('suite', 'face'))&gt;&gt;&gt; card1 = Card('红桃', 5)&gt;&gt;&gt; card2 = Card('草花', 9)&gt;&gt;&gt; card1Card(suite='红桃', face=5)&gt;&gt;&gt; card2Card(suite='草花', face=9)&gt;&gt;&gt; print(f'{card1.suite}{card1.face}')红桃5&gt;&gt;&gt; print(f'{card2.suite}{card2.face}')草花9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是使用<code>Counter</code>类统计列表中出现次数最多的三个元素的例子。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from collections import Counterwords = [    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around',    'the', 'eyes', "don't", 'look', 'around', 'the', 'eyes',    'look', 'into', 'my', 'eyes', "you're", 'under']counter = Counter(words)# 打印words列表中出现频率最高的3个元素及其出现次数for elem, count in counter.most_common(3):    print(elem, count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="hashlib-哈希函数模块"><a href="#hashlib-哈希函数模块" class="headerlink" title="hashlib - 哈希函数模块"></a>hashlib - 哈希函数模块</h3><p>哈希函数又称哈希算法或散列函数，是一种为已有的数据创建“数字指纹”（哈希摘要）的方法。哈希函数把数据压缩成摘要，对于相同的输入，哈希函数可以生成相同的摘要（数字指纹），需要注意的是这个过程并不可逆（不能通过摘要计算出输入的内容）。一个优质的哈希函数能够为不同的输入生成不同的摘要，出现哈希冲突（不同的输入产生相同的摘要）的概率极低，<a href="https://zh.wikipedia.org/wiki/MD5">MD5</a>、<a href="%5Bhttps://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F%5D(https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)">SHA家族</a>就是这类好的哈希函数。</p><blockquote><p><strong>说明</strong>：在2011年的时候，RFC 6151中已经禁止将MD5用作密钥散列消息认证码，这个问题不在我们讨论的范围内。</p></blockquote><p>Python标准库的<code>hashlib</code>模块提供了对哈希函数的封装，通过使用<code>md5</code>、<code>sha1</code>、<code>sha256</code>等类，我们可以轻松的生成“数字指纹”。举一个简单的例子，用户注册时我们希望在数据库中保存用户的密码，很显然我们不能将用户密码直接保存在数据库中，这样可能会导致用户隐私的泄露，所以在数据库中保存用户密码时，通常都会将密码的“指纹”保存起来，用户登录时通过哈希函数计算密码的“指纹”再进行匹配来判断用户登录是否成功。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import hashlib# 计算字符串"123456"的MD5摘要print(hashlib.md5('123456'.encode()).hexdigest())# 计算文件"Python-3.7.1.tar.xz"的MD5摘要hasher = hashlib.md5()with open('Python-3.7.1.tar.xz', 'rb') as file:    data = file.read(512)    while data:        hasher.update(data)        data = file.read(512)print(hasher.hexdigest())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：很多网站在下载链接的旁边都提供了哈希摘要，完成文件下载后，我们可以计算该文件的哈希摘要并检查它与网站上提供的哈希摘要是否一致（指纹比对）。如果计算出的哈希摘要与网站提供的并不一致，很有可能是下载出错或该文件在传输过程中已经被篡改，这时候就不应该直接使用这个文件。</p></blockquote><h3 id="heapq-堆排序模块"><a href="#heapq-堆排序模块" class="headerlink" title="heapq - 堆排序模块"></a>heapq - 堆排序模块</h3><p><code>heapq</code>模块实现了堆排序算法，如果希望使用堆排序，尤其是要解决<strong>TopK问题</strong>（从序列中找到K个最大或最小元素），直接使用该模块即可，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import heapqlist1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]# 找出列表中最大的三个元素print(heapq.nlargest(3, list1))# 找出列表中最小的三个元素print(heapq.nsmallest(3, list1))list2 = [    {'name': 'IBM', 'shares': 100, 'price': 91.1},    {'name': 'AAPL', 'shares': 50, 'price': 543.22},    {'name': 'FB', 'shares': 200, 'price': 21.09},    {'name': 'HPQ', 'shares': 35, 'price': 31.75},    {'name': 'YHOO', 'shares': 45, 'price': 16.35},    {'name': 'ACME', 'shares': 75, 'price': 115.65}]# 找出价格最高的三只股票print(heapq.nlargest(3, list2, key=lambda x: x['price']))# 找出持有数量最高的三只股票print(heapq.nlargest(3, list2, key=lambda x: x['shares']))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="itertools-迭代工具模块"><a href="#itertools-迭代工具模块" class="headerlink" title="itertools - 迭代工具模块"></a>itertools - 迭代工具模块</h3><p><code>itertools</code>可以帮助我们生成各种各样的迭代器，大家可以看看下面的例子。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import itertools# 产生ABCD的全排列for value in itertools.permutations('ABCD'):    print(value)# 产生ABCDE的五选三组合for value in itertools.combinations('ABCDE', 3):    print(value)# 产生ABCD和123的笛卡尔积for value in itertools.product('ABCD', '123'):    print(value)# 产生ABC的无限循环序列it = itertools.cycle(('A', 'B', 'C'))print(next(it))print(next(it))print(next(it))print(next(it))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="random-随机数和随机抽样模块"><a href="#random-随机数和随机抽样模块" class="headerlink" title="random - 随机数和随机抽样模块"></a>random - 随机数和随机抽样模块</h3><p>这个模块我们之前已经用过很多次了，生成随机数、实现随机乱序和随机抽样，下面是常用函数的列表。</p><ul><li><code>getrandbits(k)</code>：返回具有<code>k</code>个随机比特位的整数。</li><li><code>randrange(start, stop[, step])</code>：从<code>range(start, stop, step)</code> 返回一个随机选择的元素，但实际上并没有构建一个<code>range</code>对象。</li><li><code>randint(a, b)</code>：返回随机整数<code>N</code>满足<code>a &lt;= N &lt;= b</code>，相当于<code>randrange(a, b+1)</code>。</li><li><code>choice(seq)</code>：从非空序列<code>seq</code>返回一个随机元素。 如果<code>seq</code>为空，则引发<code>IndexError</code>。</li><li><code>choices(population, weight=None, *, cum_weights=None, k=1)</code>：从<code>population</code>中选择替换，返回大小为<code>k</code>的元素列表。 如果<code>population</code>为空，则引发<code>IndexError</code>。</li><li><code>shuffle(x[, random])</code>：将序列<code>x</code>随机打乱位置。</li><li><code>sample(population, k)</code>：返回从总体序列或集合中选择<code>k</code>个不重复元素构造的列表，用于无重复的随机抽样。</li><li><code>random()</code>：返回<code>[0.0, 1.0)</code>范围内的下一个随机浮点数。</li><li><code>expovariate(lambd)</code>：指数分布。</li><li><code>gammavariate(alpha, beta)</code>：伽玛分布。</li><li><code>gauss(mu, sigma)</code> / <code>normalvariate(mu, sigma)</code>：正态分布。</li><li><code>paretovariate(alpha)</code>：帕累托分布。 </li><li><code>weibullvariate(alpha, beta)</code>：威布尔分布。</li></ul><h3 id="os-path-路径操作相关模块"><a href="#os-path-路径操作相关模块" class="headerlink" title="os.path - 路径操作相关模块"></a>os.path - 路径操作相关模块</h3><p><code>os.path</code>模块封装了操作路径的工具函数，如果程序中需要对文件路径做拼接、拆分、获取以及获取文件的存在性和其他属性，这个模块将会非常有帮助，下面为大家罗列一些常用的函数。</p><ul><li><code>dirname(path)</code>：返回路径<code>path</code>的目录名称。</li><li><code>exists(path)</code>：如果<code>path</code>指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。</li><li><code>getatime(path)</code> / <code>getmtime(path)</code> / <code>getctime(path)</code>：返回<code>path</code>的最后访问时间/最后修改时间/创建时间。</li><li><code>getsize(path)</code>：返回<code>path</code>的大小，以字节为单位。如果该文件不存在或不可访问，则抛出<code>OSError</code>异常。</li><li><code>isfile(path)</code>：如果<code>path</code>是普通文件，则返回 <code>True</code>。</li><li><code>isdir(path)</code>：如果<code>path</code>是目录（文件夹），则返回<code>True</code>。</li><li><code>join(path, *paths)</code>：合理地拼接一个或多个路径部分。返回值是<code>path</code>和<code>paths</code>所有值的连接，每个非空部分后面都紧跟一个目录分隔符 (<code>os.sep</code>)，除了最后一部分。这意味着如果最后一部分为空，则结果将以分隔符结尾。如果参数中某个部分是绝对路径，则绝对路径前的路径都将被丢弃，并从绝对路径部分开始连接。</li><li><code>splitext(path)</code>：将路径<code>path</code>拆分为一对，即<code>(root, ext)</code>，使得<code>root + ext == path</code>，其中<code>ext</code>为空或以英文句点开头，且最多包含一个句点。</li></ul><h3 id="uuid-UUID生成模块"><a href="#uuid-UUID生成模块" class="headerlink" title="uuid - UUID生成模块"></a>uuid - UUID生成模块</h3><p><code>uuid</code>模块可以帮助我们生成全局唯一标识符（Universal Unique IDentity）。该模块提供了四个用于生成UUID的函数，分别是：</p><ul><li><code>uuid1()</code>：由MAC地址、当前时间戳、随机数生成，可以保证全球范围内的唯一性。</li><li><code>uuid3(namespace, name)</code>：通过计算命名空间和名字的MD5哈希摘要（“指纹”）值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字会生成相同的UUID。</li><li><code>uuid4()</code>：由伪随机数生成UUID，有一定的重复概率，该概率可以计算出来。</li><li><code>uuid5()</code>：算法与<code>uuid3</code>相同，只不过哈希函数用SHA-1取代了MD5。</li></ul><p>由于<code>uuid4</code>存在概率型重复，那么在真正需要全局唯一标识符的地方最好不用使用它。在分布式环境下，<code>uuid1</code>是很好的选择，因为它能够保证生成ID的全局唯一性。下面是在<strong>Python交互式环境中</strong>使用<code>uuid1</code>函数生成全局唯一标识符的例子。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; import uuid&gt;&gt;&gt; uuid.uuid1().hex'622a8334baab11eaaa9c60f81da8d840'&gt;&gt;&gt; uuid.uuid1().hex'62b066debaab11eaaa9c60f81da8d840'&gt;&gt;&gt; uuid.uuid1().hex'642c0db0baab11eaaa9c60f81da8d840'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python标准库中有大量的模块，日常开发中有很多常见的任务在Python标准库中都有封装好的函数或类可供使用，这也是Python这门语言最可爱的地方。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第21课：文件读写和异常处理</title>
      <link href="/blog/eizomhn8.html"/>
      <url>/blog/eizomhn8.html</url>
      
        <content type="html"><![CDATA[<h2 id="第21课：文件读写和异常处理"><a href="#第21课：文件读写和异常处理" class="headerlink" title="第21课：文件读写和异常处理"></a>第21课：文件读写和异常处理</h2><p>实际开发中常常会遇到对数据进行持久化的场景，所谓持久化是指将数据从无法长久保存数据的存储介质（通常是内存）转移到可以长久保存数据的存储介质（通常是硬盘）中。实现数据持久化最直接简单的方式就是通过<strong>文件系统</strong>将数据保存到<strong>文件</strong>中。</p><p>计算机的<strong>文件系统</strong>是一种存储和组织计算机数据的方法，它使得对数据的访问和查找变得容易，文件系统使用<strong>文件</strong>和<strong>树形目录</strong>的抽象逻辑概念代替了硬盘、光盘、闪存等物理设备的数据块概念，用户使用文件系统来保存数据时，不必关心数据实际保存在硬盘的哪个数据块上，只需要记住这个文件的路径和文件名。在写入新数据之前，用户不必关心硬盘上的哪个数据块没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。</p><h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><p>有了文件系统，我们可以非常方便的通过文件来读写数据；在Python中要实现文件操作是非常简单的。我们可以使用Python内置的<code>open</code>函数来打开文件，在使用<code>open</code>函数时，我们可以通过函数的参数指定<strong>文件名</strong>、<strong>操作模式</strong>和<strong>字符编码</strong>等信息，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件或二进制文件）以及做什么样的操作（读、写或追加），具体如下表所示。</p><table><thead><tr><th>操作模式</th><th>具体含义</th></tr></thead><tbody><tr><td><code>'r'</code></td><td>读取 （默认）</td></tr><tr><td><code>'w'</code></td><td>写入（会先截断之前的内容）</td></tr><tr><td><code>'x'</code></td><td>写入，如果文件已经存在会产生异常</td></tr><tr><td><code>'a'</code></td><td>追加，将内容写入到已有文件的末尾</td></tr><tr><td><code>'b'</code></td><td>二进制模式</td></tr><tr><td><code>'t'</code></td><td>文本模式（默认）</td></tr><tr><td><code>'+'</code></td><td>更新（既可以读又可以写）</td></tr></tbody></table><p>下图展示了如何根据程序的需要来设置<code>open</code>函数的操作模式。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210803201644.png" width="75%"><p>在使用<code>open</code>函数时，如果打开的文件是字符文件（文本文件），可以通过<code>encoding</code>参数来指定读写文件使用的字符编码。如果对字符编码和字符集这些概念不了解，可以看看<a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html">《字符集和字符编码》</a>一文，此处不再进行赘述。</p><p>使用<code>open</code>函数打开文件成功后会返回一个文件对象，通过这个对象，我们就可以实现对文件的读写操作；如果打开文件失败，<code>open</code>函数会引发异常，稍后会对此加以说明。如果要关闭打开的文件，可以使用文件对象的<code>close</code>方法，这样可以在结束文件操作时释放掉这个文件。</p><h3 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h3><p>用<code>open</code>函数打开文本文件时，需要指定文件名并将文件的操作模式设置为<code>'r'</code>，如果不指定，默认值也是<code>'r'</code>；如果需要指定字符编码，可以传入<code>encoding</code>参数，如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码。需要提醒大家，如果不能保证保存文件时使用的编码方式与<code>encoding</code>参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取文件失败。</p><p>下面的例子演示了如何读取一个纯文本文件（一般指只有字符原生编码构成的文件，与富文本相比，纯文本不包含字符样式的控制元素，能够被最简单的文本编辑器直接读取）。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">file = open('致橡树.txt', 'r', encoding='utf-8')print(file.read())file.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：<a href="http://www.china.org.cn/learning_english/2011-02/21/content_21967654.htm">《致橡树》</a>是舒婷老师在1977年3月创建的爱情诗，也是我最喜欢的现代诗之一。</p></blockquote><p>除了使用文件对象的<code>read</code>方法读取文件之外，还可以使用<code>for-in</code>循环逐行读取或者用<code>readlines</code>方法将文件按行读取到一个列表容器中，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">file = open('致橡树.txt', 'r', encoding='utf-8')for line in file:    print(line, end='')file.close()file = open('致橡树.txt', 'r', encoding='utf-8')lines = file.readlines()for line in lines:    print(line, end='')file.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要向文件中写入内容，可以在打开文件时使用<code>w</code>或者<code>a</code>作为操作模式，前者会截断之前的文本内容写入新的内容，后者是在原来内容的尾部追加新的内容。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">file = open('致橡树.txt', 'a', encoding='utf-8')file.write('\n标题：《致橡树》')file.write('\n作者：舒婷')file.write('\n时间：1977年3月')file.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>请注意上面的代码，如果<code>open</code>函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码具有健壮性和容错性，我们可以<strong>使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理</strong>。Python中和异常相关的关键字有五个，分别是<code>try</code>、<code>except</code>、<code>else</code>、<code>finally</code>和<code>raise</code>，我们先看看下面的代码，再来为大家介绍这些关键字的用法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">file = Nonetry:    file = open('致橡树.txt', 'r', encoding='utf-8')    print(file.read())except FileNotFoundError:    print('无法打开指定的文件!')except LookupError:    print('指定了未知的编码!')except UnicodeDecodeError:    print('读取文件时解码错误!')finally:    if file:        file.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Python中，我们可以将运行时会出现状况的代码放在<code>try</code>代码块中，在<code>try</code>后面可以跟上一个或多个<code>except</code>块来捕获异常并进行相应的处理。例如，在上面的代码中，文件找不到会引发<code>FileNotFoundError</code>，指定了未知的编码会引发<code>LookupError</code>，而如果读取文件时无法按指定编码方式解码文件会引发<code>UnicodeDecodeError</code>，所以我们在<code>try</code>后面跟上了三个<code>except</code>分别处理这三种不同的异常状况。在<code>except</code>后面，我们还可以加上<code>else</code>代码块，这是<code>try</code> 中的代码没有出现异常时会执行的代码，而且<code>else</code>中的代码不会再进行异常捕获，也就是说如果遇到异常状况，程序会因异常而终止并报告异常信息。最后我们使用<code>finally</code>代码块来关闭打开的文件，释放掉程序中获取的外部资源。由于<code>finally</code>块的代码不论程序正常还是异常都会执行，甚至是调用了<code>sys</code>模块的<code>exit</code>函数终止Python程序，<code>finally</code>块中的代码仍然会被执行（因为<code>exit</code>函数的本质是引发了<code>SystemExit</code>异常），因此我们把<code>finally</code>代码块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。</p><p>Python中内置了大量的异常类型，除了上面代码中用到的异常类型以及之前的课程中遇到过的异常类型外，还有许多的异常类型，其继承结构如下所示。</p><pre class="line-numbers language-none"><code class="language-none">BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception      +-- StopIteration      +-- StopAsyncIteration      +-- ArithmeticError      |    +-- FloatingPointError      |    +-- OverflowError      |    +-- ZeroDivisionError      +-- AssertionError      +-- AttributeError      +-- BufferError      +-- EOFError      +-- ImportError      |    +-- ModuleNotFoundError      +-- LookupError      |    +-- IndexError      |    +-- KeyError      +-- MemoryError      +-- NameError      |    +-- UnboundLocalError      +-- OSError      |    +-- BlockingIOError      |    +-- ChildProcessError      |    +-- ConnectionError      |    |    +-- BrokenPipeError      |    |    +-- ConnectionAbortedError      |    |    +-- ConnectionRefusedError      |    |    +-- ConnectionResetError      |    +-- FileExistsError      |    +-- FileNotFoundError      |    +-- InterruptedError      |    +-- IsADirectoryError      |    +-- NotADirectoryError      |    +-- PermissionError      |    +-- ProcessLookupError      |    +-- TimeoutError      +-- ReferenceError      +-- RuntimeError      |    +-- NotImplementedError      |    +-- RecursionError      +-- SyntaxError      |    +-- IndentationError      |         +-- TabError      +-- SystemError      +-- TypeError      +-- ValueError      |    +-- UnicodeError      |         +-- UnicodeDecodeError      |         +-- UnicodeEncodeError      |         +-- UnicodeTranslateError      +-- Warning           +-- DeprecationWarning           +-- PendingDeprecationWarning           +-- RuntimeWarning           +-- SyntaxWarning           +-- UserWarning           +-- FutureWarning           +-- ImportWarning           +-- UnicodeWarning           +-- BytesWarning           +-- ResourceWarning<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的继承结构可以看出，Python中所有的异常都是<code>BaseException</code>的子类型，它有四个直接的子类，分别是：<code>SystemExit</code>、<code>KeyboardInterrupt</code>、<code>GeneratorExit</code>和<code>Exception</code>。其中，<code>SystemExit</code>表示解释器请求退出，<code>KeyboardInterrupt</code>是用户中断程序执行（按下<code>Ctrl+c</code>），<code>GeneratorExit</code>表示生成器发生异常通知退出，不理解这些异常没有关系，继续学习就好了。值得一提的是<code>Exception</code>类，它是常规异常类型的父类型，很多的异常都是直接或间接的继承自<code>Exception</code>类。如果Python内置的异常类型不能满足应用程序的需要，我们可以自定义异常类型，而自定义的异常类型也应该直接或间接继承自<code>Exception</code>类，当然还可以根据需要重写或添加方法。</p><p>在Python中，可以使用<code>raise</code>关键字来引发异常（抛出异常对象），而调用者可以通过<code>try...except...</code>结构来捕获并处理异常。例如在函数中，当函数的执行条件不满足时，可以使用抛出异常的方式来告知调用者问题的所在，而调用者可以通过捕获处理异常来使得代码从异常中恢复，定义异常和抛出异常的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class InputError(ValueError):    """自定义异常类型"""    passdef fac(num):    """求阶乘"""    if num &lt; 0:        raise InputError('只能计算非负整数的阶乘')    if num in (0, 1):        return 1    return num * fac(num - 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用求阶乘的函数<code>fac</code>，通过<code>try...except...</code>结构捕获输入错误的异常并打印异常对象（显示异常信息），如果输入正确就计算阶乘并结束程序。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">flag = Truewhile flag:    num = int(input('n = '))    try:        print(f'{num}! = {fac(num)}')        flag = False    except InputError as err:        print(err)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上下文语法"><a href="#上下文语法" class="headerlink" title="上下文语法"></a>上下文语法</h3><p>对于<code>open</code>函数返回的文件对象，还可以使用<code>with</code>上下文语法在文件操作完成后自动执行文件对象的<code>close</code>方法，这样可以让代码变得更加简单优雅，因为不需要再写<code>finally</code>代码块来执行关闭文件释放资源的操作。需要提醒大家的是，并不是所有的对象都可以放在<code>with</code>上下文语法中，只有符合<strong>上下文管理器协议</strong>（有<code>__enter__</code>和<code>__exit__</code>魔术方法）的对象才能使用这种语法，Python标准库中的<code>contextlib</code>模块也提供了对<code>with</code>上下文语法的支持，后面再为大家进行讲解。</p><p>用<code>with</code>上下文语法改写后的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">try:    with open('致橡树.txt', 'r', encoding='utf-8') as file:        print(file.read())except FileNotFoundError:    print('无法打开指定的文件!')except LookupError:    print('指定了未知的编码!')except UnicodeDecodeError:    print('读取文件时解码错误!')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h3><p>读写二进制文件跟读写文本文件的操作类似，但是需要注意，在使用<code>open</code>函数打开文件时，如果要进行读操作，操作模式是<code>'rb'</code>，如果要进行写操作，操作模式是<code>'wb'</code>。还有一点，读写文本文件时，<code>read</code>方法的返回值以及<code>write</code>方法的参数是<code>str</code>对象（字符串），而读写二进制文件时，<code>read</code>方法的返回值以及<code>write</code>方法的参数是<code>bytes-like</code>对象（字节串）。下面的代码实现了将当前路径下名为<code>guido.jpg</code>的图片文件复制到<code>吉多.jpg</code>文件中的操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">try:    with open('guido.jpg', 'rb') as file1:        data = file1.read()    with open('吉多.jpg', 'wb') as file2:        file2.write(data)except FileNotFoundError:    print('指定的文件无法打开.')except IOError:    print('读写文件时出现错误.')print('程序执行结束.')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要复制的图片文件很大，一次将文件内容直接读入内存中可能会造成非常大的内存开销，为了减少对内存的占用，可以为<code>read</code>方法传入<code>size</code>参数来指定每次读取的字节数，通过循环读取和写入的方式来完成上面的操作，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">try:    with open('guido.jpg', 'rb') as file1, open('吉多.jpg', 'wb') as file2:        data = file1.read(512)        while data:            file2.write(data)            data = file1.read()except FileNotFoundError:    print('指定的文件无法打开.')except IOError:    print('读写文件时出现错误.')print('程序执行结束.')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>通过读写文件的操作，我们可以实现数据持久化。在Python中可以通过<code>open</code>函数来获得文件对象，可以通过文件对象的<code>read</code>和<code>write</code>方法实现文件读写操作。程序在运行时可能遭遇无法预料的异常状况，可以使用Python的异常机制来处理这些状况。Python的异常机制主要包括<code>try</code>、<code>except</code>、<code>else</code>、<code>finally</code>和<code>raise</code>这五个核心关键字。<code>try</code>后面的<code>except</code>语句不是必须的，<code>finally</code>语句也不是必须的，但是二者必须要有一个；<code>except</code>语句可以有一个或多个，多个<code>except</code>会按照书写的顺序依次匹配指定的异常，如果异常已经处理就不会再进入后续的<code>except</code>语句；<code>except</code>语句中还可以通过元组同时指定多个异常类型进行捕获；<code>except</code>语句后面如果不指定异常类型，则默认捕获所有异常；捕获异常后可以使用<code>raise</code>要再次抛出，但是不建议捕获并抛出同一个异常；不建议在不清楚逻辑的情况下捕获所有异常，这可能会掩盖程序中严重的问题。最后强调一点，<strong>不要使用异常机制来处理正常业务逻辑或控制程序流程</strong>，简单的说就是不要滥用异常机制，这是初学者常犯的错误。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第22课：对象的序列化和反序列化</title>
      <link href="/blog/wyrd52mr.html"/>
      <url>/blog/wyrd52mr.html</url>
      
        <content type="html"><![CDATA[<h2 id="第22课：对象的序列化和反序列化"><a href="#第22课：对象的序列化和反序列化" class="headerlink" title="第22课：对象的序列化和反序列化"></a>第22课：对象的序列化和反序列化</h2><p>###JSON概述</p><p>通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？在Python中，我们可以将程序中的数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨语言跨平台的数据交换。使用JSON的原因非常简单，因为它结构紧凑而且是纯文本，任何操作系统和编程语言都能处理纯文本，这就是<strong>实现跨语言跨平台数据交换</strong>的前提条件。目前JSON基本上已经取代了XML（可扩展标记语言）作为<strong>异构系统间交换数据的事实标准</strong>。可以在<a href="https://www.json.org/json-zh.html">JSON的官方网站</a>找到更多关于JSON的知识，这个网站还提供了每种语言处理JSON数据格式可以使用的工具或三方库。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">{    name: "骆昊",    age: 40,    friends: ["王大锤", "白元芳"],    cars: [        {"brand": "BMW", "max_speed": 240},        {"brand": "Benz", "max_speed": 280},        {"brand": "Audi", "max_speed": 280}    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是JSON的一个简单例子，大家可能已经注意到了，它跟Python中的字典非常类似而且支持嵌套结构，就好比Python字典中的值可以是另一个字典。我们可以尝试把下面的代码输入浏览器的控制台（对于Chrome浏览器，可以通过“更多工具”菜单找到“开发者工具”子菜单，就可以打开浏览器的控制台），浏览器的控制台提供了一个运行JavaScript代码的交互式环境（类似于Python的交互式环境），下面的代码会帮我们创建出一个JavaScript的对象，我们将其赋值给名为<code>obj</code>的变量。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let obj = {    name: "骆昊",    age: 40,    friends: ["王大锤", "白元芳"],    cars: [        {"brand": "BMW", "max_speed": 240},        {"brand": "Benz", "max_speed": 280},        {"brand": "Audi", "max_speed": 280}    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://github.com/jackfrued/mypic/raw/master/20210820143803.png" alt="image-20210820143756353" width="80%"><p>上面的<code>obj</code>就是JavaScript中的一个对象，我们可以通过<code>obj.name</code>或<code>obj["name"]</code>两种方式获取到<code>name</code>对应的值，如下图所示。可以注意到，<code>obj["name"]</code>这种获取数据的方式跟Python字典通过键获取值的索引操作是完全一致的，而Python中也通过名为<code>json</code>的模块提供了字典与JSON双向转换的支持。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210820144411.png" width="85%"><p>我们在JSON中使用的数据类型（JavaScript数据类型）和Python中的数据类型也是很容易找到对应关系的，大家可以看看下面的两张表。</p><p>表1：JavaScript数据类型（值）对应的Python数据类型（值）</p><table><thead><tr><th>JSON</th><th>Python</th></tr></thead><tbody><tr><td><code>object</code></td><td><code>dict</code></td></tr><tr><td><code>array</code></td><td><code>list</code></td></tr><tr><td><code>string</code></td><td><code>str</code></td></tr><tr><td><code>number </code></td><td><code>int</code> / <code>float</code></td></tr><tr><td><code>number</code> (real)</td><td><code>float</code></td></tr><tr><td><code>boolean</code> (<code>true</code> / <code>false</code>)</td><td><code>bool</code> (<code>True</code> / <code>False</code>)</td></tr><tr><td><code>null</code></td><td><code>None</code></td></tr></tbody></table><p>表2：Python数据类型（值）对应的JavaScript数据类型（值）</p><table><thead><tr><th>Python</th><th>JSON</th></tr></thead><tbody><tr><td><code>dict</code></td><td><code>object</code></td></tr><tr><td><code>list</code> / <code>tuple</code></td><td><code>array</code></td></tr><tr><td><code>str</code></td><td><code>string</code></td></tr><tr><td><code>int</code> / <code>float</code></td><td><code>number</code></td></tr><tr><td><code>bool</code> （<code>True</code> / <code>False</code>）</td><td><code>boolean</code> (<code>true</code> / <code>false</code>)</td></tr><tr><td><code>None</code></td><td><code>null</code></td></tr></tbody></table><h3 id="读写JSON格式的数据"><a href="#读写JSON格式的数据" class="headerlink" title="读写JSON格式的数据"></a>读写JSON格式的数据</h3><p>在Python中，如果要将字典处理成JSON格式（以字符串形式存在），可以使用<code>json</code>模块的<code>dumps</code>函数，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import jsonmy_dict = {    'name': '骆昊',    'age': 40,    'friends': ['王大锤', '白元芳'],    'cars': [        {'brand': 'BMW', 'max_speed': 240},        {'brand': 'Audi', 'max_speed': 280},        {'brand': 'Benz', 'max_speed': 280}    ]}print(json.dumps(my_dict))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上面的代码，输出如下所示，可以注意到中文字符都是用Unicode编码显示的。</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{"name": "\u9a86\u660a", "age": 40, "friends": ["\u738b\u5927\u9524", "\u767d\u5143\u82b3"], "cars": [{"brand": "BMW", "max_speed": 240}, {"brand": "Audi", "max_speed": 280}, {"brand": "Benz", "max_speed": 280}]}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要将字典处理成JSON格式并写入文本文件，只需要将<code>dumps</code>函数换成<code>dump</code>函数并传入文件对象即可，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import jsonmy_dict = {    'name': '骆昊',    'age': 40,    'friends': ['王大锤', '白元芳'],    'cars': [        {'brand': 'BMW', 'max_speed': 240},        {'brand': 'Audi', 'max_speed': 280},        {'brand': 'Benz', 'max_speed': 280}    ]}with open('data.json', 'w') as file:    json.dump(my_dict, file)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上面的代码，会创建<code>data.json</code>文件，文件的内容跟上面代码的输出是一样的。</p><p><code>json</code>模块有四个比较重要的函数，分别是：</p><ul><li><code>dump</code> - 将Python对象按照JSON格式序列化到文件中</li><li><code>dumps</code> - 将Python对象处理成JSON格式的字符串</li><li><code>load</code> - 将文件中的JSON数据反序列化成对象</li><li><code>loads</code> - 将字符串的内容反序列化成Python对象</li></ul><p>这里出现了两个概念，一个叫序列化，一个叫反序列化，<a href="https://zh.wikipedia.org/">维基百科</a>上的解释是：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。</p><p>我们可以通过下面的代码，读取上面创建的<code>data.json</code>文件，将JSON格式的数据还原成Python中的字典。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import jsonwith open('data.json', 'r') as file:    my_dict = json.load(file)    print(type(my_dict))    print(my_dict)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="包管理工具pip的使用"><a href="#包管理工具pip的使用" class="headerlink" title="包管理工具pip的使用"></a>包管理工具pip的使用</h3><p>Python标准库中的<code>json</code>模块在数据序列化和反序列化时性能并不是非常理想，为了解决这个问题，可以使用三方库<code>ujson</code>来替换<code>json</code>。所谓三方库，是指非公司内部开发和使用的，也不是来自于官方标准库的Python模块，这些模块通常由其他公司、组织或个人开发，所以被称为三方库。虽然Python语言的标准库虽然已经提供了诸多模块来方便我们的开发，但是对于一个强大的语言来说，它的生态圈一定也是非常繁荣的。</p><p>之前安装Python解释器时，默认情况下已经勾选了安装pip，大家可以在命令提示符或终端中通过<code>pip --version</code>来确定是否已经拥有了pip。pip是Python的包管理工具，通过pip可以查找、安装、卸载、更新Python的三方库或工具，macOS和Linux系统应该使用pip3。例如要安装替代<code>json</code>模块的<code>ujson</code>，可以使用下面的命令。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install ujson<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在默认情况下，pip会访问<code>https://pypi.org/simple/</code>来获得三方库相关的数据，但是国内访问这个网站的速度并不是十分理想，因此国内用户可以使用豆瓣网提供的镜像来替代这个默认的下载源，操作如下所示。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install ujson<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以通过<code>pip search</code>命令根据名字查找需要的三方库，可以通过<code>pip list</code>命令来查看已经安装过的三方库。如果想更新某个三方库，可以使用<code>pip install -U</code>或<code>pip install --upgrade</code>；如果要删除某个三方库，可以使用<code>pip uninstall</code>命令。</p><p>搜索<code>ujson</code>三方库。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip search ujsonmicropython-cpython-ujson (0.2)  - MicroPython module ujson ported to CPythonpycopy-cpython-ujson (0.2)       - Pycopy module ujson ported to CPythonujson (3.0.0)                    - Ultra fast JSON encoder and decoder for Pythonujson-bedframe (1.33.0)          - Ultra fast JSON encoder and decoder for Pythonujson-segfault (2.1.57)          - Ultra fast JSON encoder and decoder for Python. Continuing                                    development.ujson-ia (2.1.1)                 - Ultra fast JSON encoder and decoder for Python (Internet                                    Archive fork)ujson-x (1.37)                   - Ultra fast JSON encoder and decoder for Pythonujson-x-legacy (1.35.1)          - Ultra fast JSON encoder and decoder for Pythondrf_ujson (1.2)                  - Django Rest Framework UJSON Rendererdrf-ujson2 (1.6.1)               - Django Rest Framework UJSON RendererujsonDB (0.1.0)                  - A lightweight and simple database using ujson.fast-json (0.3.2)                - Combines best parts of json and ujson for fast serializationdecimal-monkeypatch (0.4.3)      - Python 2 performance patches: decimal to cdecimal, json to                                    ujson for psycopg2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看已经安装的三方库。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip listPackage                       Version----------------------------- ----------aiohttp                       3.5.4alipay                        0.7.4altgraph                      0.16.1amqp                          2.4.2...  ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新<code>ujson</code>三方库。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install -U ujson<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除<code>ujson</code>三方库。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip uninstall -y ujson<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>提示</strong>：如果要更新<code>pip</code>自身，对于macOS系统来说，可以使用命令<code>pip install -U pip</code>。在Windows系统上，可以将命令替换为<code>python -m pip install -U --user pip</code>。</p></blockquote><h3 id="使用网络API获取数据"><a href="#使用网络API获取数据" class="headerlink" title="使用网络API获取数据"></a>使用网络API获取数据</h3><p>如果想在我们自己的程序中显示天气、路况、航班等信息，这些信息我们自己没有能力提供，所以必须使用网络数据服务。目前绝大多数的网络数据服务（或称之为网络API）都是基于<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP</a>或HTTPS提供JSON格式的数据，我们可以通过Python程序发送HTTP请求给指定的URL（统一资源定位符），这个URL就是所谓的网络API，如果请求成功，它会返回HTTP响应，而HTTP响应的消息体中就有我们需要的JSON格式的数据。关于HTTP的相关知识，可以看看阮一峰的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP协议入门》</a>一文。</p><p>国内有很多提供网络API接口的网站，例如<a href="https://www.juhe.cn/">聚合数据</a>、<a href="http://www.avatardata.cn/">阿凡达数据</a>等，这些网站上有免费的和付费的数据接口，国外的<a href="http://apis.io/">{API}Search</a>网站也提供了类似的功能，有兴趣的可以自行研究。下面的例子演示了如何使用<a href="http://docs.python-requests.org/zh_CN/latest/"><code>requests</code></a>库（基于HTTP进行网络资源访问的三方库）访问网络API获取国内新闻并显示新闻标题和链接。在这个例子中，我们使用了名为<a href="https://www.tianapi.com/">天行数据</a>的网站提供的国内新闻数据接口，其中的APIKey需要自己到网站上注册申请。在天行数据网站注册账号后会自动分配APIKey，但是要访问接口获取数据，需要绑定验证邮箱或手机，然后还要申请需要使用的接口，如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210820151134.png" alt="image-20210820151134034" width="100%"><p>Python通过URL接入网络，我们推荐大家使用<code>requests</code>三方库，它简单且强大，但需要自行安装。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install requests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取国内新闻并显示新闻标题和链接。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import requestsresp = requests.get('http://api.tianapi.com/guonei/?key=APIKey&amp;num=10')if resp.status_code == 200:    data_model = resp.json()    for news in data_model['newslist']:        print(news['title'])        print(news['url'])        print('-' * 60)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码通过<code>requests</code>模块的<code>get</code>函数向天行数据的国内新闻接口发起了一次请求，如果请求过程没有出现问题，<code>get</code>函数会返回一个<code>Response</code>对象，通过该对象的<code>status_code</code>属性表示HTTP响应状态码，如果不理解没关系，你只需要关注它的值，如果值等于<code>200</code>或者其他<code>2</code>字头的值，那么我们的请求是成功的。通过<code>Response</code>对象的<code>json()</code>方法可以将返回的JSON格式的数据直接处理成Python字典，非常方便。天行数据国内新闻接口返回的JSON格式的数据（部分）如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210820154455.png" width="100%"><blockquote><p><strong>提示</strong>：上面代码中的APIKey需要换成自己在天行数据网站申请的APIKey。天行数据网站上还有提供了很多非常有意思的API接口，例如：垃圾分类、周公解梦等，大家可以仿照上面的代码来调用这些接口。每个接口都有对应的接口文档，文档中有关于如何使用接口的详细说明。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python中实现序列化和反序列化除了使用<code>json</code>模块之外，还可以使用<code>pickle</code>和<code>shelve</code>模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别，关于这两个模块的相关知识，有兴趣的读者可以自己查找网络上的资料。处理JSON格式的数据很显然是程序员必须掌握的一项技能，因为不管是访问网络API接口还是提供网络API接口给他人使用，都需要具备处理JSON格式数据的相关知识。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第23课：用Python读写CSV文件</title>
      <link href="/blog/eeywesdi.html"/>
      <url>/blog/eeywesdi.html</url>
      
        <content type="html"><![CDATA[<h2 id="第23课：用Python读写CSV文件"><a href="#第23课：用Python读写CSV文件" class="headerlink" title="第23课：用Python读写CSV文件"></a>第23课：用Python读写CSV文件</h2><h3 id="CSV文件介绍"><a href="#CSV文件介绍" class="headerlink" title="CSV文件介绍"></a>CSV文件介绍</h3><p>CSV（Comma Separated Values）全称逗号分隔值文件是一种简单、通用的文件格式，被广泛的应用于应用程序（数据库、电子表格等）数据的导入和导出以及异构系统之间的数据交换。因为CSV是纯文本文件，不管是什么操作系统和编程语言都是可以处理纯文本的，而且很多编程语言中都提供了对读写CSV文件的支持，因此CSV格式在数据处理和数据科学中被广泛应用。</p><p>CSV文件有以下特点：</p><ol><li>纯文本，使用某种字符集（如<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a>、<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>、<a href="https://zh.wikipedia.org/wiki/GB2312">GB2312</a>）等）；</li><li>由一条条的记录组成（典型的是每行一条记录）；</li><li>每条记录被分隔符（如逗号、分号、制表符等）分隔为字段（列）；</li><li>每条记录都有同样的字段序列。</li></ol><p>CSV文件可以使用文本编辑器或类似于Excel电子表格这类工具打开和编辑，当使用Excel这类电子表格打开CSV文件时，你甚至感觉不到CSV和Excel文件的区别。很多数据库系统都支持将数据导出到CSV文件中，当然也支持从CSV文件中读入数据保存到数据库中，这些内容并不是现在要讨论的重点。</p><h3 id="将数据写入CSV文件"><a href="#将数据写入CSV文件" class="headerlink" title="将数据写入CSV文件"></a>将数据写入CSV文件</h3><p>现有五个学生三门课程的考试成绩需要保存到一个CSV文件中，要达成这个目标，可以使用Python标准库中的<code>csv</code>模块，该模块的<code>writer</code>函数会返回一个<code>csvwriter</code>对象，通过该对象的<code>writerow</code>或<code>writerows</code>方法就可以将数据写入到CSV文件中，具体的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import csvimport randomwith open('scores.csv', 'w') as file:    writer = csv.writer(file)    writer.writerow(['姓名', '语文', '数学', '英语'])    names = ['关羽', '张飞', '赵云', '马超', '黄忠']    for name in names:        scores = [random.randrange(50, 101) for _ in range(3)]        scores.insert(0, name)        writer.writerow(scores)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的CSV文件的内容。</p><pre class="line-numbers language-none"><code class="language-none">姓名,语文,数学,英语关羽,98,86,61张飞,86,58,80赵云,95,73,70马超,83,97,55黄忠,61,54,87<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的是上面的<code>writer</code>函数，除了传入要写入数据的文件对象外，还可以<code>dialect</code>参数，它表示CSV文件的方言，默认值是<code>excel</code>。除此之外，还可以通过<code>delimiter</code>、<code>quotechar</code>、<code>quoting</code>参数来指定分隔符（默认是逗号）、包围值的字符（默认是双引号）以及包围的方式。其中，包围值的字符主要用于当字段中有特殊符号时，通过添加包围值的字符可以避免二义性。大家可以尝试将上面第5行代码修改为下面的代码，然后查看生成的CSV文件。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">writer = csv.writer(file, delimiter='|', quoting=csv.QUOTE_ALL)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的CSV文件的内容。</p><pre class="line-numbers language-none"><code class="language-none">"姓名"|"语文"|"数学"|"英语""关羽"|"88"|"64"|"65""张飞"|"76"|"93"|"79""赵云"|"78"|"55"|"76""马超"|"72"|"77"|"68""黄忠"|"70"|"72"|"51"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从CSV文件读取数据"><a href="#从CSV文件读取数据" class="headerlink" title="从CSV文件读取数据"></a>从CSV文件读取数据</h3><p>如果要读取刚才创建的CSV文件，可以使用下面的代码，通过<code>csv</code>模块的<code>reader</code>函数可以创建出<code>csvreader</code>对象，该对象是一个迭代器，可以通过<code>next</code>函数或<code>for-in</code>循环读取到文件中的数据。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import csvwith open('scores.csv', 'r') as file:    reader = csv.reader(file, delimiter='|')    for data_list in reader:        print(reader.line_num, end='\t')        for elem in data_list:            print(elem, end='\t')        print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：上面的代码对<code>csvreader</code>对象做<code>for</code>循环时，每次会取出一个列表对象，该列表对象包含了一行中所有的字段。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>将来如果大家使用Python做数据分析，很有可能会用到名为<code>pandas</code>的三方库，它是Python数据分析的神器之一。<code>pandas</code>中封装了名为<code>read_csv</code>和<code>to_csv</code>的函数用来读写CSV文件，其中<code>read_CSV</code>会将读取到的数据变成一个<code>DataFrame</code>对象，而<code>DataFrame</code>就是<code>pandas</code>库中最重要的类型，它封装了一系列用于数据处理的方法（清洗、转换、聚合等）；而<code>to_csv</code>会将<code>DataFrame</code>对象中的数据写入CSV文件，完成数据的持久化。<code>read_csv</code>函数和<code>to_csv</code>函数远远比原生的<code>csvreader</code>和<code>csvwriter</code>强大。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第24课：用Python读写Excel文件-1</title>
      <link href="/blog/midafssw.html"/>
      <url>/blog/midafssw.html</url>
      
        <content type="html"><![CDATA[<h2 id="第24课：用Python读写Excel文件-1"><a href="#第24课：用Python读写Excel文件-1" class="headerlink" title="第24课：用Python读写Excel文件-1"></a>第24课：用Python读写Excel文件-1</h2><h3 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h3><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p><p>Python操作Excel需要三方库的支持，如果要兼容Excel 2007以前的版本，也就是<code>xls</code>格式的Excel文件，可以使用三方库<code>xlrd</code>和<code>xlwt</code>，前者用于读Excel文件，后者用于写Excel文件。如果使用较新版本的Excel，即操作<code>xlsx</code>格式的Excel文件，可以使用<code>openpyxl</code>库，当然这个库不仅仅可以操作Excel，还可以操作其他基于Office Open XML的电子表格文件。</p><p>本章我们先讲解基于<code>xlwt</code>和<code>xlrd</code>操作Excel文件，大家可以先使用下面的命令安装这两个三方库以及配合使用的工具模块<code>xlutils</code>。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install xlwt xlrd xlutils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="读Excel文件"><a href="#读Excel文件" class="headerlink" title="读Excel文件"></a>读Excel文件</h3><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xls”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import xlrd# 使用xlrd模块的open_workbook函数打开指定Excel文件并获得Book对象（工作簿）wb = xlrd.open_workbook('阿里巴巴2020年股票数据.xls')# 通过Book对象的sheet_names方法可以获取所有表单名称sheetnames = wb.sheet_names()print(sheetnames)# 通过指定的表单名称获取Sheet对象（工作表）sheet = wb.sheet_by_name(sheetnames[0])# 通过Sheet对象的nrows和ncols属性获取表单的行数和列数print(sheet.nrows, sheet.ncols)for row in range(sheet.nrows):    for col in range(sheet.ncols):        # 通过Sheet对象的cell方法获取指定Cell对象（单元格）        # 通过Cell对象的value属性获取单元格中的值        value = sheet.cell(row, col).value        # 对除首行外的其他行进行数据格式化处理        if row &gt; 0:            # 第1列的xldate类型先转成元组再格式化为“年月日”的格式            if col == 0:                # xldate_as_tuple函数的第二个参数只有0和1两个取值                # 其中0代表以1900-01-01为基准的日期，1代表以1904-01-01为基准的日期                value = xlrd.xldate_as_tuple(value, 0)                value = f'{value[0]}年{value[1]:&gt;02d}月{value[2]:&gt;02d}日'            # 其他列的number类型处理成小数点后保留两位有效数字的浮点数            else:                value = f'{value:.2f}'        print(value, end='\t')    print()# 获取最后一个单元格的数据类型# 0 - 空值，1 - 字符串，2 - 数字，3 - 日期，4 - 布尔，5 - 错误last_cell_type = sheet.cell_type(sheet.nrows - 1, sheet.ncols - 1)print(last_cell_type)# 获取第一行的值（列表）print(sheet.row_values(0))# 获取指定行指定列范围的数据（列表）# 第一个参数代表行索引，第二个和第三个参数代表列的开始（含）和结束（不含）索引print(sheet.row_slice(3, 0, 5))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xls”可以通过后面的百度云盘地址进行获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p></blockquote><p>相信通过上面的代码，大家已经了解到了如何读取一个Excel文件，如果想知道更多关于<code>xlrd</code>模块的知识，可以阅读它的<a href="https://xlrd.readthedocs.io/en/latest/">官方文档</a>。</p><h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>写入Excel文件可以通过<code>xlwt</code> 模块的<code>Workbook</code>类创建工作簿对象，通过工作簿对象的<code>add_sheet</code>方法可以添加工作表，通过工作表对象的<code>write</code>方法可以向指定单元格中写入数据，最后通过工作簿对象的<code>save</code>方法将工作簿写入到指定的文件或内存中。下面的代码实现了将<code>5</code>个学生<code>3</code>门课程的考试成绩写入Excel文件的操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport xlwtstudent_names = ['关羽', '张飞', '赵云', '马超', '黄忠']scores = [[random.randrange(50, 101) for _ in range(3)] for _ in range(5)]# 创建工作簿对象（Workbook）wb = xlwt.Workbook()# 创建工作表对象（Worksheet）sheet = wb.add_sheet('一年级二班')# 添加表头数据titles = ('姓名', '语文', '数学', '英语')for index, title in enumerate(titles):    sheet.write(0, index, title)# 将学生姓名和考试成绩写入单元格for row in range(len(scores)):    sheet.write(row + 1, 0, student_names[row])    for col in range(len(scores[row])):        sheet.write(row + 1, col + 1, scores[row][col])# 保存Excel工作簿wb.save('考试成绩表.xls')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调整单元格样式"><a href="#调整单元格样式" class="headerlink" title="调整单元格样式"></a>调整单元格样式</h4><p>在写Excel文件时，我们还可以为单元格设置样式，主要包括字体（Font）、对齐方式（Alignment）、边框（Border）和背景（Background）的设置，<code>xlwt</code>对这几项设置都封装了对应的类来支持。要设置单元格样式需要首先创建一个<code>XFStyle</code>对象，再通过该对象的属性对字体、对齐方式、边框等进行设定，例如在上面的例子中，如果希望将表头单元格的背景色修改为黄色，可以按照如下的方式进行操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">header_style = xlwt.XFStyle()pattern = xlwt.Pattern()pattern.pattern = xlwt.Pattern.SOLID_PATTERN# 0 - 黑色、1 - 白色、2 - 红色、3 - 绿色、4 - 蓝色、5 - 黄色、6 - 粉色、7 - 青色pattern.pattern_fore_colour = 5header_style.pattern = patterntitles = ('姓名', '语文', '数学', '英语')for index, title in enumerate(titles):    sheet.write(0, index, title, header_style)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果希望为表头设置指定的字体，可以使用<code>Font</code>类并添加如下所示的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">font = xlwt.Font()# 字体名称font.name = '华文楷体'# 字体大小（20是基准单位，18表示18px）font.height = 20 * 18# 是否使用粗体font.bold = True# 是否使用斜体font.italic = False# 字体颜色font.colour_index = 1header_style.font = font<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：上面代码中指定的字体名（<code>font.name</code>）应当是本地系统有的字体，例如在我的电脑上有名为“华文楷体”的字体。</p></blockquote><p>如果希望表头垂直居中对齐，可以使用下面的代码进行设置。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">align = xlwt.Alignment()# 垂直方向的对齐方式align.vert = xlwt.Alignment.VERT_CENTER# 水平方向的对齐方式align.horz = xlwt.Alignment.HORZ_CENTERheader_style.alignment = align<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果希望给表头加上黄色的虚线边框，可以使用下面的代码来设置。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">borders = xlwt.Borders()props = (    ('top', 'top_colour'), ('right', 'right_colour'),    ('bottom', 'bottom_colour'), ('left', 'left_colour'))# 通过循环对四个方向的边框样式及颜色进行设定for position, color in props:    # 使用setattr内置函数动态给对象指定的属性赋值    setattr(borders, position, xlwt.Borders.DASHED)    setattr(borders, color, 5)header_style.borders = borders<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要调整单元格的宽度（列宽）和表头的高度（行高），可以按照下面的代码进行操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 设置行高为40pxsheet.row(0).set_style(xlwt.easyxf(f'font:height {20 * 40}'))titles = ('姓名', '语文', '数学', '英语')for index, title in enumerate(titles):    # 设置列宽为200px    sheet.col(index).width = 20 * 200    # 设置单元格的数据和样式    sheet.write(0, index, title, header_style)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="公式计算"><a href="#公式计算" class="headerlink" title="公式计算"></a>公式计算</h4><p>对于前面打开的“阿里巴巴2020年股票数据.xls”文件，如果要统计全年收盘价（Close字段）的平均值以及全年交易量（Volume字段）的总和，可以使用Excel的公式计算即可。我们可以先使用<code>xlrd</code>读取Excel文件夹，然后通过<code>xlutils</code>三方库提供的<code>copy</code>函数将读取到的Excel文件转成<code>Workbook</code>对象进行写操作，在调用<code>write</code>方法时，可以将一个<code>Formula</code>对象写入单元格。</p><p>实现公式计算的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import xlrdimport xlwtfrom xlutils.copy import copywb_for_read = xlrd.open_workbook('阿里巴巴2020年股票数据.xls')sheet1 = wb_for_read.sheet_by_index(0)nrows, ncols = sheet1.nrows, sheet1.ncolswb_for_write = copy(wb_for_read)sheet2 = wb_for_write.get_sheet(0)sheet2.write(nrows, 4, xlwt.Formula(f'average(E2:E{nrows})'))sheet2.write(nrows, 6, xlwt.Formula(f'sum(G2:G{nrows})'))wb_for_write.save('阿里巴巴2020年股票数据汇总.xls')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面的代码有一些小瑕疵，有兴趣的读者可以自行探索并思考如何解决。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。当然，如果要对表格数据进行处理，使用Python数据分析神器之一的<code>pandas</code>库可能更为方便。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第25课：用Python读写Excel文件-2</title>
      <link href="/blog/oysqc5xj.html"/>
      <url>/blog/oysqc5xj.html</url>
      
        <content type="html"><![CDATA[<h2 id="第25课：用Python读写Excel文件-2"><a href="#第25课：用Python读写Excel文件-2" class="headerlink" title="第25课：用Python读写Excel文件-2"></a>第25课：用Python读写Excel文件-2</h2><h3 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h3><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p><p>本章我们继续讲解基于另一个三方库<code>openpyxl</code>如何进行Excel文件操作，首先需要先安装它。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install openpyxl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>openpyxl</code>的优点在于，当我们打开一个Excel文件后，既可以对它进行读操作，又可以对它进行写操作，而且在操作的便捷性上是优于<code>xlwt</code>和<code>xlrd</code>的。此外，如果要进行样式编辑和公式计算，使用<code>openpyxl</code>也远比上一个章节我们讲解的方式更为简单，而且<code>openpyxl</code>还支持数据透视和插入图表等操作，功能非常强大。有一点需要再次强调，<code>openpyxl</code>并不支持操作Office 2007以前版本的Excel文件。</p><h3 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h3><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xlsx”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import datetimeimport openpyxl# 加载一个工作簿 ---&gt; Workbookwb = openpyxl.load_workbook('阿里巴巴2020年股票数据.xlsx')# 获取工作表的名字print(wb.sheetnames)# 获取工作表 ---&gt; Worksheetsheet = wb.worksheets[0]# 获得单元格的范围print(sheet.dimensions)# 获得行数和列数print(sheet.max_row, sheet.max_column)# 获取指定单元格的值print(sheet.cell(3, 3).value)print(sheet['C3'].value)print(sheet['G255'].value)# 获取多个单元格（嵌套元组）print(sheet['A2:C5'])# 读取所有单元格的数据for row_ch in range(2, sheet.max_row + 1):    for col_ch in 'ABCDEFG':        value = sheet[f'{col_ch}{row_ch}'].value        if type(value) == datetime.datetime:            print(value.strftime('%Y年%m月%d日'), end='\t')        elif type(value) == int:            print(f'{value:&lt;10d}', end='\t')        elif type(value) == float:            print(f'{value:.4f}', end='\t')        else:            print(value, end='\t')    print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xlsx”可以通过后面的百度云盘地址进行获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p></blockquote><p>需要提醒大家一点，<code>openpyxl</code>获取指定的单元格有两种方式，一种是通过<code>cell</code>方法，需要注意，该方法的行索引和列索引都是从<code>1</code>开始的，这是为了照顾用惯了Excel的人的习惯；另一种是通过索引运算，通过指定单元格的坐标，例如<code>C3</code>、<code>G255</code>，也可以取得对应的单元格，再通过单元格对象的<code>value</code>属性，就可以获取到单元格的值。通过上面的代码，相信大家还注意到了，可以通过类似<code>sheet['A2:C5']</code>或<code>sheet['A2':'C5']</code>这样的切片操作获取多个单元格，该操作将返回嵌套的元组，相当于获取到了多行多列。</p><h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>下面我们使用<code>openpyxl</code>来进行写Excel操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport openpyxl# 第一步：创建工作簿（Workbook）wb = openpyxl.Workbook()# 第二步：添加工作表（Worksheet）sheet = wb.activesheet.title = '期末成绩'titles = ('姓名', '语文', '数学', '英语')for col_index, title in enumerate(titles):    sheet.cell(1, col_index + 1, title)names = ('关羽', '张飞', '赵云', '马超', '黄忠')for row_index, name in enumerate(names):    sheet.cell(row_index + 2, 1, name)    for col_index in range(2, 5):        sheet.cell(row_index + 2, col_index, random.randrange(50, 101))# 第四步：保存工作簿wb.save('考试成绩表.xlsx')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调整样式和公式计算"><a href="#调整样式和公式计算" class="headerlink" title="调整样式和公式计算"></a>调整样式和公式计算</h4><p>在使用<code>openpyxl</code>操作Excel时，如果要调整单元格的样式，可以直接通过单元格对象（<code>Cell</code>对象）的属性进行操作。单元格对象的属性包括字体（<code>font</code>）、对齐（<code>alignment</code>）、边框（<code>border</code>）等，具体的可以参考<code>openpyxl</code>的<a href="https://openpyxl.readthedocs.io/en/stable/index.html">官方文档</a>。在使用<code>openpyxl</code>时，如果需要做公式计算，可以完全按照Excel中的操作方式来进行，具体的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import openpyxlfrom openpyxl.styles import Font, Alignment, Border, Side# 对齐方式alignment = Alignment(horizontal='center', vertical='center')# 边框线条side = Side(color='ff7f50', style='mediumDashed')wb = openpyxl.load_workbook('考试成绩表.xlsx')sheet = wb.worksheets[0]# 调整行高和列宽sheet.row_dimensions[1].height = 30sheet.column_dimensions['E'].width = 120sheet['E1'] = '平均分'# 设置字体sheet.cell(1, 5).font = Font(size=18, bold=True, color='ff1493', name='华文楷体')# 设置对齐方式sheet.cell(1, 5).alignment = alignment# 设置单元格边框sheet.cell(1, 5).border = Border(left=side, top=side, right=side, bottom=side)for i in range(2, 7):    # 公式计算每个学生的平均分    sheet[f'E{i}'] = f'=average(B{i}:D{i})'    sheet.cell(i, 5).font = Font(size=12, color='4169e1', italic=True)    sheet.cell(i, 5).alignment = alignmentwb.save('考试成绩表.xlsx')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="生成统计图表"><a href="#生成统计图表" class="headerlink" title="生成统计图表"></a>生成统计图表</h3><p>通过<code>openpyxl</code>库，可以直接向Excel中插入统计图表，具体的做法跟在Excel中插入图表大体一致。我们可以创建指定类型的图表对象，然后通过该对象的属性对图表进行设置。当然，最为重要的是为图表绑定数据，即横轴代表什么，纵轴代表什么，具体的数值是多少。最后，可以将图表对象添加到表单中，具体的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from openpyxl import Workbookfrom openpyxl.chart import BarChart, Referencewb = Workbook(write_only=True)sheet = wb.create_sheet()rows = [    ('类别', '销售A组', '销售B组'),    ('手机', 40, 30),    ('平板', 50, 60),    ('笔记本', 80, 70),    ('外围设备', 20, 10),]# 向表单中添加行for row in rows:    sheet.append(row)# 创建图表对象chart = BarChart()chart.type = 'col'chart.style = 10# 设置图表的标题chart.title = '销售统计图'# 设置图表纵轴的标题chart.y_axis.title = '销量'# 设置图表横轴的标题chart.x_axis.title = '商品类别'# 设置数据的范围data = Reference(sheet, min_col=2, min_row=1, max_row=5, max_col=3)# 设置分类的范围cats = Reference(sheet, min_col=1, min_row=2, max_row=5)# 给图表添加数据chart.add_data(data, titles_from_data=True)# 给图表设置分类chart.set_categories(cats)chart.shape = 4# 将图表添加到表单指定的单元格中sheet.add_chart(chart, 'A10')wb.save('demo.xlsx')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上面的代码，打开生成的Excel文件，效果如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210819235009.png" alt="image-20210819235009026" width="75%"><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。如果数据体量较大或者处理数据的方式比较复杂，我们还是推荐大家使用Python数据分析神器之一的<code>pandas</code>库。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第26课：用Python操作Word文件和PowerPoint</title>
      <link href="/blog/rjdpbb1b.html"/>
      <url>/blog/rjdpbb1b.html</url>
      
        <content type="html"><![CDATA[<h2 id="第26课：用Python操作Word和PowerPoint"><a href="#第26课：用Python操作Word和PowerPoint" class="headerlink" title="第26课：用Python操作Word和PowerPoint"></a>第26课：用Python操作Word和PowerPoint</h2><p>在日常工作中，有很多简单重复的劳动其实完全可以交给Python程序，比如根据样板文件（模板文件）批量的生成很多个Word文件或PowerPoint文件。Word是微软公司开发的文字处理程序，相信大家都不陌生，日常办公中很多正式的文档都是用Word进行撰写和编辑的，目前使用的Word文件后缀名一般为<code>.docx</code>。PowerPoint是微软公司开发的演示文稿程序，是微软的Office系列软件中的一员，被商业人士、教师、学生等群体广泛使用，通常也将其称之为“幻灯片”。在Python中，可以使用名为<code>python-docx</code> 的三方库来操作Word，可以使用名为<code>python-pptx</code>的三方库来生成PowerPoint。</p><h3 id="操作Word文档"><a href="#操作Word文档" class="headerlink" title="操作Word文档"></a>操作Word文档</h3><p>我们可以先通过下面的命令来安装<code>python-docx</code>三方库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> python-docx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照<a href="https://python-docx.readthedocs.io/en/latest/">官方文档</a>的介绍，我们可以使用如下所示的代码来生成一个简单的Word文档。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from docx import Documentfrom docx.shared import Cm, Ptfrom docx.document import Document as Doc# 创建代表Word文档的Doc对象document = Document()  # type: Doc# 添加大标题document.add_heading('快快乐乐学Python', 0)# 添加段落p = document.add_paragraph('Python是一门非常流行的编程语言，它')run = p.add_run('简单')run.bold = Truerun.font.size = Pt(18)p.add_run('而且')run = p.add_run('优雅')run.font.size = Pt(18)run.underline = Truep.add_run('。')# 添加一级标题document.add_heading('Heading, level 1', level=1)# 添加带样式的段落document.add_paragraph('Intense quote', style='Intense Quote')# 添加无序列表document.add_paragraph(    'first item in unordered list', style='List Bullet')document.add_paragraph(    'second item in ordered list', style='List Bullet')# 添加有序列表document.add_paragraph(    'first item in ordered list', style='List Number')document.add_paragraph(    'second item in ordered list', style='List Number')# 添加图片（注意路径和图片必须要存在）document.add_picture('resources/guido.jpg', width=Cm(5.2))# 添加分节符document.add_section()records = (    ('骆昊', '男', '1995-5-5'),    ('孙美丽', '女', '1992-2-2'))# 添加表格table = document.add_table(rows=1, cols=3)table.style = 'Dark List'hdr_cells = table.rows[0].cellshdr_cells[0].text = '姓名'hdr_cells[1].text = '性别'hdr_cells[2].text = '出生日期'# 为表格添加行for name, sex, birthday in records:    row_cells = table.add_row().cells    row_cells[0].text = name    row_cells[1].text = sex    row_cells[2].text = birthday# 添加分页符document.add_page_break()# 保存文档document.save('demo.docx')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：上面代码第7行中的注释<code># type: Doc</code>是为了在PyCharm中获得代码补全提示，因为如果不清楚对象具体的数据类型，PyCharm无法在后续代码中给出<code>Doc</code>对象的代码补全提示。</p></blockquote><p>执行上面的代码，打开生成的Word文档，效果如下图所示。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210820002742.png" alt="image-20210820002742341" width="40%">&amp;nbsp;&amp;nbsp;<img src="https://github.com/jackfrued/mypic/raw/master/20210820002843.png" alt="image-20210820002843696" width="40%"></p><p>对于一个已经存在的Word文件，我们可以通过下面的代码去遍历它所有的段落并获取对应的内容。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from docx import Documentfrom docx.document import Document as Docdoc = Document('resources/离职证明.docx')  # type: Docfor no, p in enumerate(doc.paragraphs):    print(no, p.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：如果需要上面代码中的Word文件，可以通过下面的百度云盘地址进行获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p></blockquote><p>读取到的内容如下所示。</p><pre class="line-numbers language-none"><code class="language-none">0 1 离 职 证 明2 3 兹证明 王大锤 ，身份证号码： 100200199512120001 ，于 2018 年 8 月 7 日至 2020 年 6 月 28 日在我单位  开发部 部门担任 Java开发工程师 职务，在职期间无不良表现。因 个人 原因，于 2020 年 6 月 28 日起终止解除劳动合同。现已结清财务相关费用，办理完解除劳动关系相关手续，双方不存在任何劳动争议。4 5 特此证明！6 7 8 公司名称（盖章）:成都风车车科技有限公司9    2020 年 6 月 28 日<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>讲到这里，相信很多读者已经想到了，我们可以把上面的离职证明制作成一个模板文件，把姓名、身份证号、入职和离职日期等信息用占位符代替，这样通过对占位符的替换，就可以根据实际需要写入对应的信息，这样就可以批量的生成Word文档。</p><p>按照上面的思路，我们首先编辑一个离职证明的模板文件，如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210820004223.png" alt="image-20210820004223731" width="75%" style="border:1px solid black"><p>接下来我们读取该文件，将占位符替换为真实信息，就可以生成一个新的Word文档，如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from docx import Documentfrom docx.document import Document as Doc# 将真实信息用字典的方式保存在列表中employees = [    {        'name': '骆昊',        'id': '100200198011280001',        'sdate': '2008年3月1日',        'edate': '2012年2月29日',        'department': '产品研发',        'position': '架构师',        'company': '成都华为技术有限公司'    },    {        'name': '王大锤',        'id': '510210199012125566',        'sdate': '2019年1月1日',        'edate': '2021年4月30日',        'department': '产品研发',        'position': 'Python开发工程师',        'company': '成都谷道科技有限公司'    },    {        'name': '李元芳',        'id': '2102101995103221599',        'sdate': '2020年5月10日',        'edate': '2021年3月5日',        'department': '产品研发',        'position': 'Java开发工程师',        'company': '同城企业管理集团有限公司'    },]# 对列表进行循环遍历，批量生成Word文档 for emp_dict in employees:    # 读取离职证明模板文件    doc = Document('resources/离职证明模板.docx')  # type: Doc    # 循环遍历所有段落寻找占位符    for p in doc.paragraphs:        if '{' not in p.text:            continue        # 不能直接修改段落内容，否则会丢失样式        # 所以需要对段落中的元素进行遍历并进行查找替换        for run in p.runs:            if '{' not in run.text:                continue            # 将占位符换成实际内容            start, end = run.text.find('{'), run.text.find('}')            key, place_holder = run.text[start + 1:end], run.text[start:end + 1]            run.text = run.text.replace(place_holder, emp_dict[key])    # 每个人对应保存一个Word文档    doc.save(f'{emp_dict["name"]}离职证明.docx')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上面的代码，会在当前路径下生成三个Word文档，如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210820004825.png" alt="image-20210820004825183" width="50%"><h3 id="生成PowerPoint"><a href="#生成PowerPoint" class="headerlink" title="生成PowerPoint"></a>生成PowerPoint</h3><p>首先我们需要安装名为<code>python-pptx</code>的三方库，命令如下所示。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install python-pptx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用Python操作PowerPoint的内容，因为实际应用场景不算很多，我不打算在这里进行赘述，有兴趣的读者可以自行阅读<code>python-pptx</code>的<a href="https://python-pptx.readthedocs.io/en/latest/">官方文档</a>，下面仅展示一段来自于官方文档的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from pptx import Presentation# 创建幻灯片对象pres = Presentation()# 选择母版添加一页title_slide_layout = pres.slide_layouts[0]slide = pres.slides.add_slide(title_slide_layout)# 获取标题栏和副标题栏title = slide.shapes.titlesubtitle = slide.placeholders[1]# 编辑标题和副标题title.text = "Welcome to Python"subtitle.text = "Life is short, I use Python"# 选择母版添加一页bullet_slide_layout = pres.slide_layouts[1]slide = pres.slides.add_slide(bullet_slide_layout)# 获取页面上所有形状shapes = slide.shapes# 获取标题和主体title_shape = shapes.titlebody_shape = shapes.placeholders[1]# 编辑标题title_shape.text = 'Introduction'# 编辑主体内容tf = body_shape.text_frametf.text = 'History of Python'# 添加一个一级段落p = tf.add_paragraph()p.text = 'X\'max 1989'p.level = 1# 添加一个二级段落p = tf.add_paragraph()p.text = 'Guido began to write interpreter for Python.'p.level = 2# 保存幻灯片pres.save('test.pptx')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上面的代码，生成的PowerPoint文件如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210820010306.png" alt="image-20210820010306008" width="75%"><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>用Python程序解决办公自动化的问题真的非常酷，它可以将我们从繁琐乏味的劳动中解放出来。写这类代码就是去做一件一劳永逸的事情，写代码的过程即便不怎么愉快，使用这些代码的时候应该是非常开心的。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第27课：用Python操作PDF文件</title>
      <link href="/blog/shu7spay.html"/>
      <url>/blog/shu7spay.html</url>
      
        <content type="html"><![CDATA[<h2 id="第27课：用Python操作PDF文件"><a href="#第27课：用Python操作PDF文件" class="headerlink" title="第27课：用Python操作PDF文件"></a>第27课：用Python操作PDF文件</h2><p>PDF是Portable Document Format的缩写，这类文件通常使用<code>.pdf</code>作为其扩展名。在日常开发工作中，最容易遇到的就是从PDF中读取文本内容以及用已有的内容生成PDF文档这两个任务。</p><h3 id="从PDF中提取文本"><a href="#从PDF中提取文本" class="headerlink" title="从PDF中提取文本"></a>从PDF中提取文本</h3><p>在Python中，可以使用名为<code>PyPDF2</code>的三方库来读取PDF文件，可以使用下面的命令来安装它。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install PyPDF2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>PyPDF2</code>没有办法从PDF文档中提取图像、图表或其他媒体，但它可以提取文本，并将其返回为Python字符串。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import PyPDF2reader = PyPDF2.PdfReader('test.pdf')for page in reader.pages:    print(page.extract_text())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：上面代码中使用的PDF文件“test.pdf”以及下面的代码中需要用到的PDF文件，也可以通过下面的百度云盘地址进行获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p></blockquote><p>当然，<code>PyPDF2</code>并不是什么样的PDF文档都能提取出文字来，这个问题就我所知并没有什么特别好的解决方法，尤其是在提取中文的时候。网上也有很多讲解从PDF中提取文字的文章，推荐大家自行阅读<a href="https://cloud.tencent.com/developer/article/1395339">《三大神器助力Python提取pdf文档信息》</a>一文进行了解。</p><p>要从PDF文件中提取文本也可以直接使用三方的命令行工具，具体的做法如下所示。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install pdfminer.sixpdf2text.py test.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="旋转和叠加页面"><a href="#旋转和叠加页面" class="headerlink" title="旋转和叠加页面"></a>旋转和叠加页面</h3><p>上面的代码中通过创建<code>PdfFileReader</code>对象的方式来读取PDF文档，该对象的<code>getPage</code>方法可以获得PDF文档的指定页并得到一个<code>PageObject</code>对象，通过<code>PageObject</code>对象的<code>rotateClockwise</code>和<code>rotateCounterClockwise</code>方法可以实现页面的顺时针和逆时针方向旋转，通过<code>PageObject</code>对象的<code>addBlankPage</code>方法可以添加一个新的空白页，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">reader = PyPDF2.PdfReader('XGBoost.pdf')writer = PyPDF2.PdfWriter()for no, page in enumerate(reader.pages):    if no % 2 == 0:        new_page = page.rotate(-90)    else:        new_page = page.rotate(90)    writer.add_page(new_page)with open('temp.pdf', 'wb') as file_obj:    writer.write(file_obj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加密PDF文件"><a href="#加密PDF文件" class="headerlink" title="加密PDF文件"></a>加密PDF文件</h3><p>使用<code>PyPDF2</code>中的<code>PdfFileWrite</code>对象可以为PDF文档加密，如果需要给一系列的PDF文档设置统一的访问口令，使用Python程序来处理就会非常的方便。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import PyPDF2reader = PyPDF2.PdfReader('XGBoost.pdf')writer = PyPDF2.PdfWriter()for page in reader.pages:    writer.add_page(page)    writer.encrypt('foobared')with open('temp.pdf', 'wb') as file_obj:    writer.write(file_obj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="批量添加水印"><a href="#批量添加水印" class="headerlink" title="批量添加水印"></a>批量添加水印</h3><p>上面提到的<code>PageObject</code>对象还有一个名为<code>mergePage</code>的方法，可以两个PDF页面进行叠加，通过这个操作，我们很容易实现给PDF文件添加水印的功能。例如要给上面的“XGBoost.pdf”文件添加一个水印，我们可以先准备好一个提供水印页面的PDF文件，然后将包含水印的<code>PageObject</code>读取出来，然后再循环遍历“XGBoost.pdf”文件的每个页，获取到<code>PageObject</code>对象，然后通过<code>mergePage</code>方法实现水印页和原始页的合并，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">reader1 = PyPDF2.PdfReader('XGBoost.pdf')reader2 = PyPDF2.PdfReader('watermark.pdf')writer = PyPDF2.PdfWriter()watermark_page = reader2.pages[0]for page in reader1.pages:    page.merge_page(watermark_page)    writer.add_page(page)with open('temp.pdf', 'wb') as file_obj:    writer.write(file_obj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果愿意，还可以让奇数页和偶数页使用不同的水印，大家可以自己思考下应该怎么做。</p><h3 id="创建PDF文件"><a href="#创建PDF文件" class="headerlink" title="创建PDF文件"></a>创建PDF文件</h3><p>创建PDF文档需要三方库<code>reportlab</code>的支持，安装的方法如下所示。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install reportlab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面通过一个例子为大家展示<code>reportlab</code>的用法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from reportlab.lib.pagesizes import A4from reportlab.pdfbase import pdfmetricsfrom reportlab.pdfbase.ttfonts import TTFontfrom reportlab.pdfgen import canvaspdf_canvas = canvas.Canvas('resources/demo.pdf', pagesize=A4)width, height = A4# 绘图image = canvas.ImageReader('resources/guido.jpg')pdf_canvas.drawImage(image, 20, height - 395, 250, 375)# 显示当前页pdf_canvas.showPage()# 注册字体文件pdfmetrics.registerFont(TTFont('Font1', 'resources/fonts/Vera.ttf'))pdfmetrics.registerFont(TTFont('Font2', 'resources/fonts/青呱石头体.ttf'))# 写字pdf_canvas.setFont('Font2', 40)pdf_canvas.setFillColorRGB(0.9, 0.5, 0.3, 1)pdf_canvas.drawString(width // 2 - 120, height // 2, '你好，世界！')pdf_canvas.setFont('Font1', 40)pdf_canvas.setFillColorRGB(0, 1, 0, 0.5)pdf_canvas.rotate(18)pdf_canvas.drawString(250, 250, 'hello, world!')# 保存pdf_canvas.save()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码如果不太理解也没有关系，等真正需要用Python创建PDF文档的时候，再好好研读一下<code>reportlab</code>的<a href="https://www.reportlab.com/docs/reportlab-userguide.pdf">官方文档</a>就可以了。</p><blockquote><p><strong>提示</strong>：上面代码中用到的图片和字体，也可以通过下面的百度云盘链接获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>在学习完上面的内容之后，相信大家已经知道像合并多个PDF文件这样的工作应该如何用Python代码来处理了，赶紧自己动手试一试吧。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第28课：用Python处理图像</title>
      <link href="/blog/rimnpudj.html"/>
      <url>/blog/rimnpudj.html</url>
      
        <content type="html"><![CDATA[<h2 id="第28课：用Python处理图像"><a href="#第28课：用Python处理图像" class="headerlink" title="第28课：用Python处理图像"></a>第28课：用Python处理图像</h2><h3 id="入门知识"><a href="#入门知识" class="headerlink" title="入门知识"></a>入门知识</h3><ol><li><p>颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是美术中的三原色，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色。在计算机系统中，我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。</p><table><thead><tr><th align="center">名称</th><th align="center">RGB值</th><th align="center">名称</th><th align="center">RGB值</th></tr></thead><tbody><tr><td align="center">White（白）</td><td align="center">(255, 255, 255)</td><td align="center">Red（红）</td><td align="center">(255, 0, 0)</td></tr><tr><td align="center">Green（绿）</td><td align="center">(0, 255, 0)</td><td align="center">Blue（蓝）</td><td align="center">(0, 0, 255)</td></tr><tr><td align="center">Gray（灰）</td><td align="center">(128, 128, 128)</td><td align="center">Yellow（黄）</td><td align="center">(255, 255, 0)</td></tr><tr><td align="center">Black（黑）</td><td align="center">(0, 0, 0)</td><td align="center">Purple（紫）</td><td align="center">(128, 0, 128)</td></tr></tbody></table></li><li><p>像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小，大家如果爱好拍照或者自拍，对像素这个词就不会陌生。</p></li></ol><h3 id="用Pillow处理图像"><a href="#用Pillow处理图像" class="headerlink" title="用Pillow处理图像"></a>用Pillow处理图像</h3><p>Pillow是由从著名的Python图像处理库PIL发展出来的一个分支，通过Pillow可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装Pillow。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">pip install pillow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Pillow中最为重要的是<code>Image</code>类，可以通过<code>Image</code>模块的<code>open</code>函数来读取图像并获得<code>Image</code>类型的对象。</p><ol><li><p>读取和显示图像</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from PIL import Image# 读取图像获得Image对象image = Image.open('guido.jpg')# 通过Image对象的format属性获得图像的格式print(image.format) # JPEG# 通过Image对象的size属性获得图像的尺寸print(image.size)   # (500, 750)# 通过Image对象的mode属性获取图像的模式print(image.mode)   # RGB# 通过Image对象的show方法显示图像image.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://github.com/jackfrued/mypic/raw/master/20210803202628.png" width="80%"></li><li><p>剪裁图像</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 通过Image对象的crop方法指定剪裁区域剪裁图像image.crop((80, 20, 310, 360)).show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="https://github.com/jackfrued/mypic/raw/master/20210803202701.png" width="80%"></li><li><p>生成缩略图</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 通过Image对象的thumbnail方法生成指定尺寸的缩略图image.thumbnail((128, 128))image.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="https://github.com/jackfrued/mypic/raw/master/20210803202722.png" width="100%"></li><li><p>缩放和黏贴图像</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 读取骆昊的照片获得Image对象luohao_image = Image.open('luohao.png')# 读取吉多的照片获得Image对象guido_image = Image.open('guido.jpg')# 从吉多的照片上剪裁出吉多的头guido_head = guido_image.crop((80, 20, 310, 360))width, height = guido_head.size# 使用Image对象的resize方法修改图像的尺寸# 使用Image对象的paste方法将吉多的头粘贴到骆昊的照片上luohao_image.paste(guido_head.resize((int(width / 1.5), int(height / 1.5))), (172, 40))luohao_image.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://github.com/jackfrued/mypic/raw/master/20210803202749.png" width="80%"></li><li><p>旋转和翻转</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">image = Image.open('guido.jpg')# 使用Image对象的rotate方法实现图像的旋转image.rotate(45).show()# 使用Image对象的transpose方法实现图像翻转# Image.FLIP_LEFT_RIGHT - 水平翻转# Image.FLIP_TOP_BOTTOM - 垂直翻转image.transpose(Image.FLIP_TOP_BOTTOM).show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://github.com/jackfrued/mypic/raw/master/20210803202829.png" width="80%"></li><li><p>操作像素</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">for x in range(80, 310):    for y in range(20, 360):        # 通过Image对象的putpixel方法修改图像指定像素点        image.putpixel((x, y), (128, 128, 128))image.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://github.com/jackfrued/mypic/raw/master/20210803202932.png" width="80%"></li><li><p>滤镜效果</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from PIL import ImageFilter# 使用Image对象的filter方法对图像进行滤镜处理# ImageFilter模块包含了诸多预设的滤镜也可以自定义滤镜image.filter(ImageFilter.CONTOUR).show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://github.com/jackfrued/mypic/raw/master/20210803202953.png" width="80%"></li></ol><h3 id="使用Pillow绘图"><a href="#使用Pillow绘图" class="headerlink" title="使用Pillow绘图"></a>使用Pillow绘图</h3><p>Pillow中有一个名为<code>ImageDraw</code>的模块，该模块的<code>Draw</code>函数会返回一个<code>ImageDraw</code>对象，通过<code>ImageDraw</code>对象的<code>arc</code>、<code>line</code>、<code>rectangle</code>、<code>ellipse</code>、<code>polygon</code>等方法，可以在图像上绘制出圆弧、线条、矩形、椭圆、多边形等形状，也可以通过该对象的<code>text</code>方法在图像上添加文字。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210803203016.png" width="80%"><p>要绘制如上图所示的图像，完整的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomfrom PIL import Image, ImageDraw, ImageFontdef random_color():    """生成随机颜色"""    red = random.randint(0, 255)    green = random.randint(0, 255)    blue = random.randint(0, 255)    return red, green, bluewidth, height = 800, 600# 创建一个800*600的图像，背景色为白色image = Image.new(mode='RGB', size=(width, height), color=(255, 255, 255))# 创建一个ImageDraw对象drawer = ImageDraw.Draw(image)# 通过指定字体和大小获得ImageFont对象font = ImageFont.truetype('Kongxin.ttf', 32)# 通过ImageDraw对象的text方法绘制文字drawer.text((300, 50), 'Hello, world!', fill=(255, 0, 0), font=font)# 通过ImageDraw对象的line方法绘制两条对角直线drawer.line((0, 0, width, height), fill=(0, 0, 255), width=2)drawer.line((width, 0, 0, height), fill=(0, 0, 255), width=2)xy = width // 2 - 60, height // 2 - 60, width // 2 + 60, height // 2 + 60# 通过ImageDraw对象的rectangle方法绘制矩形drawer.rectangle(xy, outline=(255, 0, 0), width=2)# 通过ImageDraw对象的ellipse方法绘制椭圆for i in range(4):    left, top, right, bottom = 150 + i * 120, 220, 310 + i * 120, 380    drawer.ellipse((left, top, right, bottom), outline=random_color(), width=8)# 显示图像image.show()# 保存图像image.save('result.png')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：上面代码中使用的字体文件需要根据自己准备，可以选择自己喜欢的字体文件并放置在代码目录下。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>使用Python语言做开发，除了可以用Pillow来处理图像外，还可以使用更为强大的OpenCV库来完成图形图像的处理，OpenCV（<strong>Open</strong> Source <strong>C</strong>omputer <strong>V</strong>ision Library）是一个跨平台的计算机视觉库，可以用来开发实时图像处理、计算机视觉和模式识别程序。在我们的日常工作中，有很多繁琐乏味的任务其实都可以通过Python程序来处理，编程的目的就是让计算机帮助我们解决问题，减少重复乏味的劳动。通过本章节的学习，相信大家已经感受到了使用Python程序绘图P图的乐趣，其实Python能做的事情还远不止这些，继续你的学习吧。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第29课：用Python发送邮件和短信</title>
      <link href="/blog/frsrpt1u.html"/>
      <url>/blog/frsrpt1u.html</url>
      
        <content type="html"><![CDATA[<h2 id="第29课：用Python发送邮件和短信"><a href="#第29课：用Python发送邮件和短信" class="headerlink" title="第29课：用Python发送邮件和短信"></a>第29课：用Python发送邮件和短信</h2><p>在前面的课程中，我们已经教会大家如何用Python程序自动的生成Excel、Word、PDF文档，接下来我们还可以更进一步，就是通过邮件将生成好的文档发送给指定的收件人，然后用短信告知对方我们发出了邮件。这些事情利用Python程序也可以轻松愉快的解决。</p><h3 id="发送电子邮件"><a href="#发送电子邮件" class="headerlink" title="发送电子邮件"></a>发送电子邮件</h3><p>在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。</p><p>我们可以用HTTP（超文本传输协议）来访问网站资源，HTTP是一个应用级协议，它建立在TCP（传输控制协议）之上，TCP为很多应用级协议提供了可靠的数据传输服务。如果要发送电子邮件，需要使用SMTP（简单邮件传输协议），它也是建立在TCP之上的应用级协议，规定了邮件的发送者如何跟邮件服务器进行通信的细节。Python通过名为<code>smtplib</code>的模块将这些操作简化成了<code>SMTP_SSL</code>对象，通过该对象的<code>login</code>和<code>send_mail</code>方法，就能够完成发送邮件的操作。</p><p>我们先尝试一下发送一封极为简单的邮件，该邮件不包含附件、图片以及其他超文本内容。发送邮件首先需要接入邮件服务器，我们可以自己架设邮件服务器，这件事情对新手并不友好，但是我们可以选择使用第三方提供的邮件服务。例如，我在&lt;<a href="http://www.126.com>已经注册了账号，登录成功之后，就可以在设置中开启SMTP服务，这样就相当于获得了邮件服务器，具体的操作如下所示。">www.126.com&gt;已经注册了账号，登录成功之后，就可以在设置中开启SMTP服务，这样就相当于获得了邮件服务器，具体的操作如下所示。</a></p><img src="https://github.com/jackfrued/mypic/raw/master/20210820190307.png" alt="image-20210820190306861" width="95%"><p><img src="https://github.com/jackfrued/mypic/raw/master/20210820190816.png" alt="image-20210820190816557"></p><p>用手机扫码上面的二维码可以通过发送短信的方式来获取授权码，短信发送成功后，点击“我已发送”就可以获得授权码。授权码需要妥善保管，因为一旦泄露就会被其他人冒用你的身份来发送邮件。接下来，我们就可以编写发送邮件的代码了，如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import smtplibfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMEText# 创建邮件主体对象email = MIMEMultipart()# 设置发件人、收件人和主题email['From'] = 'xxxxxxxxx@126.com'email['To'] = 'yyyyyy@qq.com;zzzzzz@1000phone.com'email['Subject'] = Header('上半年工作情况汇报', 'utf-8')# 添加邮件正文内容content = """据德国媒体报道，当地时间9日，德国火车司机工会成员进行了投票，定于当地时间10日起进行全国性罢工，货运交通方面的罢工已于当地时间10日19时开始。此后，从11日凌晨2时到13日凌晨2时，德国全国范围内的客运和铁路基础设施将进行48小时的罢工。"""email.attach(MIMEText(content, 'plain', 'utf-8'))# 创建SMTP_SSL对象（连接邮件服务器）smtp_obj = smtplib.SMTP_SSL('smtp.126.com', 465)# 通过用户名和授权码进行登录smtp_obj.login('xxxxxxxxx@126.com', '邮件服务器的授权码')# 发送邮件（发件人、收件人、邮件内容（字符串））smtp_obj.sendmail(    'xxxxxxxxx@126.com',    ['yyyyyy@qq.com', 'zzzzzz@1000phone.com'],    email.as_string())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要发送带有附件的邮件，只需要将附件的内容处理成BASE64编码，那么它就和普通的文本内容几乎没有什么区别。BASE64是一种基于64个可打印字符来表示二进制数据的表示方法，常用于某些需要表示、传输、存储二进制数据的场合，电子邮件就是其中之一。对这种编码方式不理解的同学，推荐阅读<a href="http://www.ruanyifeng.com/blog/2008/06/base64.html">《Base64笔记》</a>一文。在之前的内容中，我们也提到过，Python标准库的<code>base64</code>模块提供了对BASE64编解码的支持。</p><p>下面的代码演示了如何发送带附件的邮件。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import smtplibfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom urllib.parse import quote# 创建邮件主体对象email = MIMEMultipart()# 设置发件人、收件人和主题email['From'] = 'xxxxxxxxx@126.com'email['To'] = 'zzzzzzzz@1000phone.com'email['Subject'] = Header('请查收离职证明文件', 'utf-8')# 添加邮件正文内容（带HTML标签排版的内容）content = """&lt;p&gt;亲爱的前同事：&lt;/p&gt;&lt;p&gt;你需要的离职证明在附件中，请查收！&lt;/p&gt;&lt;br&gt;&lt;p&gt;祝，好！&lt;/p&gt;&lt;hr&gt;&lt;p&gt;孙美丽 即日&lt;/p&gt;"""email.attach(MIMEText(content, 'html', 'utf-8'))# 读取作为附件的文件with open(f'resources/王大锤离职证明.docx', 'rb') as file:    attachment = MIMEText(file.read(), 'base64', 'utf-8')    # 指定内容类型    attachment['content-type'] = 'application/octet-stream'    # 将中文文件名处理成百分号编码    filename = quote('王大锤离职证明.docx')    # 指定如何处置内容    attachment['content-disposition'] = f'attachment; filename="{filename}"'# 创建SMTP_SSL对象（连接邮件服务器）smtp_obj = smtplib.SMTP_SSL('smtp.126.com', 465)# 通过用户名和授权码进行登录smtp_obj.login('xxxxxxxxx@126.com', '邮件服务器的授权码')# 发送邮件（发件人、收件人、邮件内容（字符串））smtp_obj.sendmail(    'xxxxxxxxx@126.com',    'zzzzzzzz@1000phone.com',    email.as_string())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了方便大家用Python实现邮件发送，我将上面的代码封装成了函数，使用的时候大家只需要调整邮件服务器域名、端口、用户名和授权码就可以了。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import smtplibfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom urllib.parse import quote# 邮件服务器域名（自行修改）EMAIL_HOST = 'smtp.126.com'# 邮件服务端口（通常是465）EMAIL_PORT = 465# 登录邮件服务器的账号（自行修改）EMAIL_USER = 'xxxxxxxxx@126.com'# 开通SMTP服务的授权码（自行修改）EMAIL_AUTH = '邮件服务器的授权码'def send_email(*, from_user, to_users, subject='', content='', filenames=[]):    """发送邮件        :param from_user: 发件人    :param to_users: 收件人，多个收件人用英文分号进行分隔    :param subject: 邮件的主题    :param content: 邮件正文内容    :param filenames: 附件要发送的文件路径    """    email = MIMEMultipart()    email['From'] = from_user    email['To'] = to_users    email['Subject'] = subject    message = MIMEText(content, 'plain', 'utf-8')    email.attach(message)    for filename in filenames:        with open(filename, 'rb') as file:            pos = filename.rfind('/')            display_filename = filename[pos + 1:] if pos &gt;= 0 else filename            display_filename = quote(display_filename)            attachment = MIMEText(file.read(), 'base64', 'utf-8')            attachment['content-type'] = 'application/octet-stream'            attachment['content-disposition'] = f'attachment; filename="{display_filename}"'            email.attach(attachment)    smtp = smtplib.SMTP_SSL(EMAIL_HOST, EMAIL_PORT)    smtp.login(EMAIL_USER, EMAIL_AUTH)    smtp.sendmail(from_user, to_users.split(';'), email.as_string())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发送短信"><a href="#发送短信" class="headerlink" title="发送短信"></a>发送短信</h3><p>发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。发送短信需要三方平台的支持，下面我们以<a href="https://luosimao.com/">螺丝帽平台</a>为例，为大家介绍如何用Python程序发送短信。注册账号和购买短信服务的细节我们不在这里进行赘述，大家可以咨询平台的客服。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210820194421.png" alt="image-20210820194420911"></p><p>接下来，我们可以通过<code>requests</code>库向平台提供的短信网关发起一个HTTP请求，通过将接收短信的手机号和短信内容作为参数，就可以发送短信，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport requestsdef send_message_by_luosimao(tel, message):    """发送短信（调用螺丝帽短信网关）"""    resp = requests.post(        url='http://sms-api.luosimao.com/v1/send.json',        auth=('api', 'key-注册成功后平台分配的KEY'),        data={            'mobile': tel,            'message': message        },        timeout=10,        verify=False    )    return resp.json()def gen_mobile_code(length=6):    """生成指定长度的手机验证码"""    return ''.join(random.choices('0123456789', k=length))def main():    code = gen_mobile_code()    message = f'您的短信验证码是{code}，打死也不能告诉别人哟！【Python小课】'    print(send_message_by_luosimao('13500112233', message))if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面请求螺丝帽的短信网关<code>http://sms-api.luosimao.com/v1/send.json</code>会返回JSON格式的数据，如果返回<code>{'error': 0, 'msg': 'OK'}</code>就说明短信已经发送成功了，如果<code>error</code>的值不是<code>0</code>，可以通过查看官方的<a href="https://luosimao.com/docs/api/">开发文档</a>了解到底哪个环节出了问题。螺丝帽平台常见的错误类型如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210820195505.png" alt="image-20210820195505761" style="zoom:50%;"><p>目前，大多数短信平台都会要求短信内容必须附上签名，下图是我在螺丝帽平台配置的短信签名“【Python小课】”。有些涉及到敏感内容的短信，还需要提前配置短信模板，有兴趣的读者可以自行研究。一般情况下，平台为了防范短信被盗用，还会要求设置“IP白名单”，不清楚如何配置的可以咨询平台客服。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210820194653.png" alt="image-20210820194653785"></p><p>当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>其实，发送邮件和发送短信一样，也可以通过调用三方服务来完成，在实际的商业项目中，建议自己架设邮件服务器或购买三方服务来发送邮件，这个才是比较靠谱的选择。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第30课：正则表达式的应用</title>
      <link href="/blog/7qt7ys13.html"/>
      <url>/blog/7qt7ys13.html</url>
      
        <content type="html"><![CDATA[<h2 id="第30课：正则表达式的应用"><a href="#第30课：正则表达式的应用" class="headerlink" title="第30课：正则表达式的应用"></a>第30课：正则表达式的应用</h2><h3 id="正则表达式相关知识"><a href="#正则表达式相关知识" class="headerlink" title="正则表达式相关知识"></a>正则表达式相关知识</h3><p>在编写处理字符串的程时，经常会遇到在一段文本中查找符合某些规则的字符串的需求，正则表达式就是用于描述这些规则的工具，换句话说，我们可以使用正则表达式来定义字符串的匹配模式，即如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉。</p><p>举一个简单的例子，如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（<code>*</code>和<code>?</code>），那么正则表达式也是与之类似的用 来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求，当然你付出的代价是书写一个正则表达式比使用通配符要复杂得多，因为任何给你带来好处的东西都需要你付出对应的代价。</p><p>再举一个例子，我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号），而座机号则是类似于“区号-号码”这样的模式，如果不使用正则表达式要完成这个任务就会比较麻烦。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息很多都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的<code>re</code>模块来支持正则表达式操作。</p><p>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博文叫<a href="https://deerchao.net/tutorials/regex/regex.htm">《正则表达式30分钟入门教程》</a>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p><table><thead><tr><th>符号</th><th>解释</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意字符</td><td><code>b.t</code></td><td>可以匹配bat / but / b#t / b1t等</td></tr><tr><td><code>\w</code></td><td>匹配字母/数字/下划线</td><td><code>b\wt</code></td><td>可以匹配bat / b1t / b_t等<br>但不能匹配b#t</td></tr><tr><td><code>\s</code></td><td>匹配空白字符（包括\r、\n、\t等）</td><td><code>love\syou</code></td><td>可以匹配love you</td></tr><tr><td><code>\d</code></td><td>匹配数字</td><td><code>\d\d</code></td><td>可以匹配01 / 23 / 99等</td></tr><tr><td><code>\b</code></td><td>匹配单词的边界</td><td><code>\bThe\b</code></td><td></td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td><td><code>^The</code></td><td>可以匹配The开头的字符串</td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td><td><code>.exe$</code></td><td>可以匹配.exe结尾的字符串</td></tr><tr><td><code>\W</code></td><td>匹配非字母/数字/下划线</td><td><code>b\Wt</code></td><td>可以匹配b#t / b@t等<br>但不能匹配but / b1t / b_t等</td></tr><tr><td><code>\S</code></td><td>匹配非空白字符</td><td><code>love\Syou</code></td><td>可以匹配love#you等<br>但不能匹配love you</td></tr><tr><td><code>\D</code></td><td>匹配非数字</td><td><code>\d\D</code></td><td>可以匹配9a / 3# / 0F等</td></tr><tr><td><code>\B</code></td><td>匹配非单词边界</td><td><code>\Bio\B</code></td><td></td></tr><tr><td><code>[]</code></td><td>匹配来自字符集的任意单一字符</td><td><code>[aeiou]</code></td><td>可以匹配任一元音字母字符</td></tr><tr><td><code>[^]</code></td><td>匹配不在字符集中的任意单一字符</td><td><code>[^aeiou]</code></td><td>可以匹配任一非元音字母字符</td></tr><tr><td><code>*</code></td><td>匹配0次或多次</td><td><code>\w*</code></td><td></td></tr><tr><td><code>+</code></td><td>匹配1次或多次</td><td><code>\w+</code></td><td></td></tr><tr><td><code>?</code></td><td>匹配0次或1次</td><td><code>\w?</code></td><td></td></tr><tr><td><code>{N}</code></td><td>匹配N次</td><td><code>\w{3}</code></td><td></td></tr><tr><td><code>{M,}</code></td><td>匹配至少M次</td><td><code>\w{3,}</code></td><td></td></tr><tr><td><code>{M,N}</code></td><td>匹配至少M次至多N次</td><td><code>\w{3,6}</code></td><td></td></tr><tr><td>`</td><td>`</td><td>分支</td><td>`foo</td></tr><tr><td><code>(?#)</code></td><td>注释</td><td></td><td></td></tr><tr><td><code>(exp)</code></td><td>匹配exp并捕获到自动命名的组中</td><td></td><td></td></tr><tr><td><code>(?&lt;name&gt;exp)</code></td><td>匹配exp并捕获到名为name的组中</td><td></td><td></td></tr><tr><td><code>(?:exp)</code></td><td>匹配exp但是不捕获匹配的文本</td><td></td><td></td></tr><tr><td><code>(?=exp)</code></td><td>匹配exp前面的位置</td><td><code>\b\w+(?=ing)</code></td><td>可以匹配I’m dancing中的danc</td></tr><tr><td><code>(?&lt;=exp)</code></td><td>匹配exp后面的位置</td><td><code>(?&lt;=\bdanc)\w+\b</code></td><td>可以匹配I love dancing and reading中的第一个ing</td></tr><tr><td><code>(?!exp)</code></td><td>匹配后面不是exp的位置</td><td></td><td></td></tr><tr><td><code>(?&lt;!exp)</code></td><td>匹配前面不是exp的位置</td><td></td><td></td></tr><tr><td><code>*?</code></td><td>重复任意次，但尽可能少重复</td><td><code>a.*b</code><br><code>a.*?b</code></td><td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td></tr><tr><td><code>+?</code></td><td>重复1次或多次，但尽可能少重复</td><td></td><td></td></tr><tr><td><code>??</code></td><td>重复0次或1次，但尽可能少重复</td><td></td><td></td></tr><tr><td><code>{M,N}?</code></td><td>重复M到N次，但尽可能少重复</td><td></td><td></td></tr><tr><td><code>{M,}?</code></td><td>重复M次以上，但尽可能少重复</td><td></td><td></td></tr></tbody></table><blockquote><p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用<code>\</code>进行转义处理，例如想匹配小数点可以写成<code>\.</code>就可以了，因为直接写<code>.</code>会匹配任意字符；同理，想匹配圆括号必须写成<code>\(</code>和<code>\)</code>，否则圆括号被视为正则表达式中的分组。</p></blockquote><h3 id="Python对正则表达式的支持"><a href="#Python对正则表达式的支持" class="headerlink" title="Python对正则表达式的支持"></a>Python对正则表达式的支持</h3><p>Python提供了<code>re</code>模块来支持正则表达式相关操作，下面是<code>re</code>模块中的核心函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>compile(pattern, flags=0)</code></td><td>编译正则表达式返回正则表达式对象</td></tr><tr><td><code>match(pattern, string, flags=0)</code></td><td>用正则表达式匹配字符串 成功返回匹配对象 否则返回<code>None</code></td></tr><tr><td><code>search(pattern, string, flags=0)</code></td><td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回<code>None</code></td></tr><tr><td><code>split(pattern, string, maxsplit=0, flags=0)</code></td><td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td></tr><tr><td><code>sub(pattern, repl, string, count=0, flags=0)</code></td><td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用<code>count</code>指定替换的次数</td></tr><tr><td><code>fullmatch(pattern, string, flags=0)</code></td><td><code>match</code>函数的完全匹配（从字符串开头到结尾）版本</td></tr><tr><td><code>findall(pattern, string, flags=0)</code></td><td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td></tr><tr><td><code>finditer(pattern, string, flags=0)</code></td><td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td></tr><tr><td><code>purge()</code></td><td>清除隐式编译的正则表达式的缓存</td></tr><tr><td><code>re.I</code> / <code>re.IGNORECASE</code></td><td>忽略大小写匹配标记</td></tr><tr><td><code>re.M</code> / <code>re.MULTILINE</code></td><td>多行匹配标记</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 上面提到的<code>re</code>模块中的这些函数，实际开发中也可以用正则表达式对象（<code>Pattern</code>对象）的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过<code>compile</code>函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p></blockquote><p>下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。</p><h4 id="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"><a href="#例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。" class="headerlink" title="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"></a>例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0"""import reusername = input('请输入用户名: ')qq = input('请输入QQ号: ')# match函数的第一个参数是正则表达式字符串或正则表达式对象# match函数的第二个参数是要跟正则表达式做匹配的字符串对象m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username)if not m1:    print('请输入有效的用户名.')# fullmatch函数要求字符串和正则表达式完全匹配# 所以正则表达式没有写起始符和结束符m2 = re.fullmatch(r'[1-9]\d{4,11}', qq)if not m2:    print('请输入有效的QQ号.')if m1 and m2:    print('你输入的信息是有效的!')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示：</strong> 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了<code>r</code>），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作<code>\\</code>，例如表示数字的<code>\d</code>得书写成<code>\\d</code>，这样不仅写起来不方便，阅读的时候也会很吃力。</p></blockquote><h4 id="例子2：从一段文字中提取出国内手机号码。"><a href="#例子2：从一段文字中提取出国内手机号码。" class="headerlink" title="例子2：从一段文字中提取出国内手机号码。"></a>例子2：从一段文字中提取出国内手机号码。</h4><p>下面这张图是截止到2017年底，国内三家运营商推出的手机号段。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210803203134.png"><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import re# 创建正则表达式对象，使用了前瞻和回顾来保证手机号前后不应该再出现数字pattern = re.compile(r'(?&lt;=\D)1[34578]\d{9}(?=\D)')sentence = '''重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，不是15600998765，也是110或119，王大锤的手机号才是15600998765。'''# 方法一：查找所有匹配并保存到一个列表中tels_list = re.findall(pattern, sentence)for tel in tels_list:    print(tel)print('--------华丽的分隔线--------')# 方法二：通过迭代器取出匹配对象并获得匹配的内容for temp in pattern.finditer(sentence):    print(temp.group())print('--------华丽的分隔线--------')# 方法三：通过search函数指定搜索位置找出所有匹配m = pattern.search(sentence)while m:    print(m.group())    m = pattern.search(sentence, m.end())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明：</strong> 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：<code>(?&lt;=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)</code>，国内好像已经有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p></blockquote><h4 id="例子3：替换字符串中的不良内容"><a href="#例子3：替换字符串中的不良内容" class="headerlink" title="例子3：替换字符串中的不良内容"></a>例子3：替换字符串中的不良内容</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import resentence = 'Oh, shit! 你是傻逼吗? Fuck you.'purified = re.sub('fuck|shit|[傻煞沙][比笔逼叉缺吊碉雕]',                  '*', sentence, flags=re.IGNORECASE)print(purified)  # Oh, *! 你是*吗? * you.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明：</strong><code> re</code>模块的正则表达式相关函数中都有一个<code>flags</code>参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用<a href="http://www.runoob.com/python/python-operators.html#ysf5">按位或运算符</a>进行叠加，如<code>flags=re.I | re.M</code>。</p></blockquote><h4 id="例子4：拆分长字符串"><a href="#例子4：拆分长字符串" class="headerlink" title="例子4：拆分长字符串"></a>例子4：拆分长字符串</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import repoem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。'sentences_list = re.split(r'[，。]', poem)sentences_list = [sentence for sentence in sentences_list if sentence]for sentence in sentences_list:    print(sentence)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>正则表达式在字符串的处理和匹配上真的非常强大，通过上面的例子相信大家已经感受到了正则表达式的魅力，当然写一个正则表达式对新手来说并不是那么容易，但是很多事情都是熟能生巧，大胆的去尝试就行了，有一个在线的<a href="https://c.runoob.com/front-end/854">正则表达式测试工具</a>相信能够在一定程度上帮到大家。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第31课：网络数据采集概述</title>
      <link href="/blog/yeo0swpi.html"/>
      <url>/blog/yeo0swpi.html</url>
      
        <content type="html"><![CDATA[<h2 id="第31课：网络数据采集概述"><a href="#第31课：网络数据采集概述" class="headerlink" title="第31课：网络数据采集概述"></a>第31课：网络数据采集概述</h2><p>爬虫（crawler）也经常被称为网络蜘蛛（spider），是按照一定的规则自动浏览网站并获取所需信息的机器人程序（自动化脚本代码），被广泛的应用于互联网搜索引擎和数据采集。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接，网络爬虫正是通过网页中的超链接信息，不断获得网络上其它页面的地址，然后持续的进行数据采集。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为爬虫或者网络蜘蛛。</p><h3 id="爬虫的应用领域"><a href="#爬虫的应用领域" class="headerlink" title="爬虫的应用领域"></a>爬虫的应用领域</h3><p>在理想的状态下，所有 ICP（Internet Content Provider）都应该为自己的网站提供 API 接口来共享它们允许其他程序获取的数据，在这种情况下就根本不需要爬虫程序。国内比较有名的电商平台（如淘宝、京东等）、社交平台（如微博、微信等）等都提供了自己的 API 接口，但是这类 API 接口通常会对可以抓取的数据以及抓取数据的频率进行限制。对于大多数的公司而言，及时的获取行业数据和竞对数据是企业生存的重要环节之一，然而对大部分企业来说，数据都是其与生俱来的短板。在这种情况下，合理的利用爬虫来获取数据并从中提取出有商业价值的信息对这些企业来说就显得至关重要的。</p><p>爬虫的应用领域其实非常广泛，下面我们列举了其中的一部分，有兴趣的读者可以自行探索相关内容。</p><ol><li>搜索引擎</li><li>新闻聚合</li><li>社交应用</li><li>舆情监控</li><li>行业数据</li></ol><h3 id="爬虫合法性探讨"><a href="#爬虫合法性探讨" class="headerlink" title="爬虫合法性探讨"></a>爬虫合法性探讨</h3><p>经常听人说起“爬虫写得好，牢饭吃到饱”，那么编程爬虫程序是否违法呢？关于这个问题，我们可以从以下几个角度进行解读。</p><ol><li>网络爬虫这个领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起了一定的道德规范，即 Robots 协议（全称是“网络爬虫排除标准”），但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。</li><li>“法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。</li><li>在爬取网站的时候，需要限制自己的爬虫遵守 Robots 协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。</li><li>适当的隐匿自己的身份在编写爬虫程序时必要的，而且最好不要被对方举证你的爬虫有破坏别人动产（例如服务器）的行为。</li><li>不要在公网（如代码托管平台）上去开源或者展示你的爬虫代码，这些行为通常会给自己带来不必要的麻烦。</li></ol><h4 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h4><p>大多数网站都会定义<code>robots.txt</code>文件，这是一个君子协议，并不是所有爬虫都必须遵守的游戏规则。下面以淘宝的<a href="http://www.taobao.com/robots.txt"><code>robots.txt</code></a>文件为例，看看淘宝网对爬虫有哪些限制。</p><pre class="line-numbers language-none"><code class="language-none">User-agent: BaiduspiderDisallow: /User-agent: baiduspiderDisallow: /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的文件可以看出，淘宝禁止百度爬虫爬取它任何资源，因此当你在百度搜索“淘宝”的时候，搜索结果下方会出现：“由于该网站的<code>robots.txt</code>文件存在限制指令（限制搜索引擎抓取），系统无法提供该页面的内容描述”。百度作为一个搜索引擎，至少在表面上遵守了淘宝网的<code>robots.txt</code>协议，所以用户不能从百度上搜索到淘宝内部的产品信息。</p><p>图1. 百度搜索淘宝的结果</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210824004320.png"></p><p>下面是豆瓣网的<a href="https://www.douban.com/robots.txt"><code>robots.txt</code></a>文件，大家可以自行解读，看看它做出了什么样的限制。</p><pre class="line-numbers language-none"><code class="language-none">User-agent: *Disallow: /subject_searchDisallow: /amazon_searchDisallow: /searchDisallow: /group/searchDisallow: /event/searchDisallow: /celebrities/searchDisallow: /location/drama/searchDisallow: /forum/Disallow: /new_subjectDisallow: /service/iframeDisallow: /j/Disallow: /link2/Disallow: /recommend/Disallow: /doubanapp/cardDisallow: /update/topic/Disallow: /share/Allow: /ads.txtSitemap: https://www.douban.com/sitemap_index.xmlSitemap: https://www.douban.com/sitemap_updated_index.xml# Crawl-delay: 5User-agent: Wandoujia SpiderDisallow: /User-agent: Mediapartners-GoogleDisallow: /subject_searchDisallow: /amazon_searchDisallow: /searchDisallow: /group/searchDisallow: /event/searchDisallow: /celebrities/searchDisallow: /location/drama/searchDisallow: /j/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h3><p>在开始讲解爬虫之前，我们稍微对超文本传输协议（HTTP）做一些回顾，因为我们在网页上看到的内容通常是浏览器执行 HTML （超文本标记语言）得到的结果，而 HTTP 就是传输 HTML 数据的协议。HTTP 和其他很多应用级协议一样是构建在 TCP（传输控制协议）之上的，它利用了 TCP 提供的可靠的传输服务实现了 Web 应用中的数据交换。按照维基百科上的介绍，设计 HTTP 最初的目的是为了提供一种发布和接收 <a href="https://zh.wikipedia.org/wiki/HTML">HTML</a> 页面的方法，也就是说，这个协议是浏览器和 Web 服务器之间传输的数据的载体。关于 HTTP 的详细信息以及目前的发展状况，大家可以阅读<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a>、<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门》</a>、<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解 HTTPS 协议》</a>等文章进行了解。</p><p>下图是我在四川省网络通信技术重点实验室工作期间用开源协议分析工具 Ethereal（WireShark 的前身）截取的访问百度首页时的 HTTP 请求和响应的报文（协议数据），由于 Ethereal 截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。</p><p>图2. HTTP请求</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210824003915.png" alt="http-request"></p><p>HTTP 请求通常是由请求行、请求头、空行、消息体四个部分构成，如果没有数据发给服务器，消息体就不是必须的部分。请求行中包含了请求方法（GET、POST 等，如下表所示）、资源路径和协议版本；请求头由若干键值对构成，包含了浏览器、编码方式、首选语言、缓存策略等信息；请求头的后面是空行和消息体。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210825002720.PNG" width="65%"><p>图3. HTTP响应</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210824234158.png" alt="http-response"></p><p>HTTP 响应通常是由响应行、响应头、空行、消息体四个部分构成，其中消息体是服务响应的数据，可能是 HTML 页面，也有可能是JSON或二进制数据等。响应行中包含了协议版本和响应状态码，响应状态码有很多种，常见的如下表所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210825002802.PNG" width="65%"><h4 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h4><p>下面我们先介绍一些开发爬虫程序的辅助工具，这些工具相信能帮助你事半功倍。</p><ol><li><p>Chrome Developer Tools：谷歌浏览器内置的开发者工具。该工具最常用的几个功能模块是：</p><ul><li>元素（ELements）：用于查看或修改 HTML 元素的属性、CSS 属性、监听事件等。CSS 可以即时修改，即时显示，大大方便了开发者调试页面。</li><li>控制台（Console）：用于执行一次性代码，查看 JavaScript 对象，查看调试日志信息或异常信息。控制台其实就是一个执行 JavaScript 代码的交互式环境。</li><li>源代码（Sources）：用于查看页面的 HTML 文件源代码、JavaScript 源代码、CSS 源代码，此外最重要的是可以调试 JavaScript 源代码，可以给代码添加断点和单步执行。</li><li>网络（Network）：用于 HTTP 请求、HTTP 响应以及与网络连接相关的信息。</li><li>应用（Application）：用于查看浏览器本地存储、后台任务等内容，本地存储主要包括Cookie、Local Storage、Session Storage等。</li></ul><p><img src="https://github.com/jackfrued/mypic/raw/master/20210824004034.png" alt="chrome-developer-tools"></p></li><li><p>Postman：功能强大的网页调试与 RESTful 请求工具。Postman可以帮助我们模拟请求，非常方便的定制我们的请求以及查看服务器的响应。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210824004048.png" alt="postman"></p></li><li><p>HTTPie：命令行HTTP客户端。</p><p>安装。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install httpie<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">http --header http --header https://movie.douban.com/HTTP/1.1 200 OKConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html; charset=utf-8Date: Tue, 24 Aug 2021 16:48:00 GMTKeep-Alive: timeout=30Server: daeSet-Cookie: bid=58h4BdKC9lM; Expires=Wed, 24-Aug-22 16:48:00 GMT; Domain=.douban.com; Path=/Strict-Transport-Security: max-age=15552000Transfer-Encoding: chunkedX-Content-Type-Options: nosniffX-DOUBAN-NEWBID: 58h4BdKC9lM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>builtwith</code>库：识别网站所用技术的工具。</p><p>安装。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install builtwith<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import sslimport builtwithssl._create_default_https_context = ssl._create_unverified_contextprint(builtwith.parse('http://www.bootcss.com/'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>python-whois</code>库：查询网站所有者的工具。</p><p>安装。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip3 install python-whois<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import whoisprint(whois.whois('https://www.bootcss.com'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="爬虫的基本工作流程"><a href="#爬虫的基本工作流程" class="headerlink" title="爬虫的基本工作流程"></a>爬虫的基本工作流程</h3><p>一个基本的爬虫通常分为数据采集（网页下载）、数据处理（网页解析）和数据存储（将有用的信息持久化）三个部分的内容，当然更为高级的爬虫在数据采集和处理时会使用并发编程或分布式技术，这就需要有调度器（安排线程或进程执行对应的任务）、后台管理程序（监控爬虫的工作状态以及检查数据抓取的结果）等的参与。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210824004107.png" alt="crawler-workflow"></p><p>一般来说，爬虫的工作流程包括以下几个步骤：</p><ol><li>设定抓取目标（种子页面/起始页面）并获取网页。</li><li>当服务器无法访问时，按照指定的重试次数尝试重新下载页面。</li><li>在需要的时候设置用户代理或隐藏真实IP，否则可能无法访问页面。</li><li>对获取的页面进行必要的解码操作然后抓取出需要的信息。</li><li>在获取的页面中通过某种方式（如正则表达式）抽取出页面中的链接信息。</li><li>对链接进行进一步的处理（获取页面并重复上面的动作）。</li><li>将有用的信息进行持久化以备后续的处理。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第32课：用Python获取网络资源</title>
      <link href="/blog/lcvud8cx.html"/>
      <url>/blog/lcvud8cx.html</url>
      
        <content type="html"><![CDATA[<h2 id="第32课：用Python获取网络数据"><a href="#第32课：用Python获取网络数据" class="headerlink" title="第32课：用Python获取网络数据"></a>第32课：用Python获取网络数据</h2><p>网络数据采集是 Python 语言非常擅长的领域，上节课我们讲到，实现网络数据采集的程序通常称之为网络爬虫或蜘蛛程序。即便是在大数据时代，数据对于中小企业来说仍然是硬伤和短板，有些数据需要通过开放或付费的数据接口来获得，其他的行业数据和竞对数据则必须要通过网络数据采集的方式来获得。不管使用哪种方式获取网络数据资源，Python 语言都是非常好的选择，因为 Python 的标准库和三方库都对网络数据采集提供了良好的支持。</p><h3 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h3><p>要使用 Python 获取网络数据，我们推荐大家使用名为<code>requests</code> 的三方库，这个库我们在之前的课程中其实已经使用过了。按照官方网站的解释，<code>requests</code>是基于 Python 标准库进行了封装，简化了通过 HTTP 或 HTTPS 访问网络资源的操作。上课我们提到过，HTTP 是一个请求响应式的协议，当我们在浏览器中输入正确的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_URL">URL</a>（通常也称为网址）并按下 Enter 键时，我们就向网络上的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_web_server">Web 服务器</a>发送了一个 HTTP 请求，服务器在收到请求后会给我们一个 HTTP 响应。在 Chrome 浏览器中的菜单中打开“开发者工具”切换到“Network”选项卡就能够查看 HTTP 请求和响应到底是什么样子的，如下图所示。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210822093434.png"></p><p>通过<code>requests</code>库，我们可以让 Python 程序向浏览器一样向 Web 服务器发起请求，并接收服务器返回的响应，从响应中我们就可以提取出想要的数据。浏览器呈现给我们的网页是用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML</a> 编写的，浏览器相当于是 HTML 的解释器环境，我们看到的网页中的内容都包含在 HTML 的标签中。在获取到 HTML 代码后，就可以从标签的属性或标签体中提取内容。下面例子演示了如何获取网页 HTML 代码，我们通过<code>requests</code>库的<code>get</code>函数，获取了搜狐首页的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import requestsresp = requests.get('https://www.sohu.com/')if resp.status_code == 200:    print(resp.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面代码中的变量<code>resp</code>是一个<code>Response</code>对象（<code>requests</code>库封装的类型），通过该对象的<code>status_code</code>属性可以获取响应状态码，而该对象的<code>text</code>属性可以帮我们获取到页面的 HTML 代码。</p></blockquote><p>由于<code>Response</code>对象的<code>text</code>是一个字符串，所以我们可以利用之前讲过的正则表达式的知识，从页面的 HTML 代码中提取新闻的标题和链接，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import reimport requestspattern = re.compile(r'&lt;a.*?href="(.*?)".*?title="(.*?)".*?&gt;')resp = requests.get('https://www.sohu.com/')if resp.status_code == 200:    all_matches = pattern.findall(resp.text)    for href, title in all_matches:        print(href)        print(title)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了文本内容，我们也可以使用<code>requests</code>库通过 URL 获取二进制资源。下面的例子演示了如何获取百度 Logo 并保存到名为<code>baidu.png</code>的本地文件中。可以在百度的首页上右键点击百度Logo，并通过“复制图片地址”菜单项获取图片的 URL。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import requestsresp = requests.get('https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png')with open('baidu.png', 'wb') as file:    file.write(resp.content)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：<code>Response</code>对象的<code>content</code>属性可以获得服务器响应的二进制数据。</p></blockquote><p><code>requests</code>库非常好用而且功能上也比较强大和完整，具体的内容我们在使用的过程中为大家一点点剖析。想解锁关于<code>requests</code>库更多的知识，可以阅读它的<a href="https://docs.python-requests.org/zh_CN/latest/">官方文档</a>。</p><h3 id="编写爬虫代码"><a href="#编写爬虫代码" class="headerlink" title="编写爬虫代码"></a>编写爬虫代码</h3><p>接下来，我们以“豆瓣电影”为例，为大家讲解如何编写爬虫代码。按照上面提供的方法，我们先使用<code>requests</code>获取到网页的HTML代码，然后将整个代码看成一个长字符串，这样我们就可以使用正则表达式的捕获组从字符串提取我们需要的内容。下面的代码演示了如何从<a href="https://movie.douban.com/">豆瓣电影</a>获取排前250名的电影的名称。<a href="https://movie.douban.com/top250">豆瓣电影Top250</a>的页面结构和对应代码如下图所示，可以看出，每页共展示了25部电影，如果要获取到 Top250 数据，我们共需要访问10个页面，对应的地址是<a href="https://movie.douban.com/top250?start=xxx">https://movie.douban.com/top250?start=xxx</a>，这里的<code>xxx</code>如果为<code>0</code>就是第一页，如果<code>xxx</code>的值是<code>100</code>，那么我们可以访问到第五页。为了代码简单易读，我们只获取电影的标题和评分。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210822093447.png"></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport reimport timeimport requestsfor page in range(1, 11):    resp = requests.get(        url=f'https://movie.douban.com/top250?start={(page - 1) * 25}',        # 如果不设置HTTP请求头中的User-Agent，豆瓣会检测出不是浏览器而阻止我们的请求。        # 通过get函数的headers参数设置User-Agent的值，具体的值可以在浏览器的开发者工具查看到。        # 用爬虫访问大部分网站时，将爬虫伪装成来自浏览器的请求都是非常重要的一步。        headers={'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'}    )    # 通过正则表达式获取class属性为title且标签体不以&amp;开头的span标签并用捕获组提取标签内容    pattern1 = re.compile(r'&lt;span class="title"&gt;([^&amp;]*?)&lt;/span&gt;')    titles = pattern1.findall(resp.text)    # 通过正则表达式获取class属性为rating_num的span标签并用捕获组提取标签内容    pattern2 = re.compile(r'&lt;span class="rating_num".*?&gt;(.*?)&lt;/span&gt;')    ranks = pattern2.findall(resp.text)    # 使用zip压缩两个列表，循环遍历所有的电影标题和评分    for title, rank in zip(titles, ranks):        print(title, rank)    # 随机休眠1-5秒，避免爬取页面过于频繁    time.sleep(random.random() * 4 + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：通过分析豆瓣网的robots协议，我们发现豆瓣网并不拒绝百度爬虫获取它的数据，因此我们也可以将爬虫伪装成百度的爬虫，将<code>get</code>函数的<code>headers</code>参数修改为：<code>headers={'User-Agent': 'BaiduSpider'}</code>。</p></blockquote><h3 id="使用-IP-代理"><a href="#使用-IP-代理" class="headerlink" title="使用 IP 代理"></a>使用 IP 代理</h3><p>让爬虫程序隐匿自己的身份对编写爬虫程序来说是比较重要的，很多网站对爬虫都比较反感的，因为爬虫会耗费掉它们很多的网络带宽并制造很多无效的流量。要隐匿身份通常需要使用<strong>商业 IP 代理</strong>（如蘑菇代理、芝麻代理、快代理等），让被爬取的网站无法获取爬虫程序来源的真实 IP 地址，也就无法简单的通过 IP 地址对爬虫程序进行封禁。</p><p>下面以<a href="http://www.moguproxy.com/">蘑菇代理</a>为例，为大家讲解商业 IP 代理的使用方法。首先需要在该网站注册一个账号，注册账号后就可以<a href="http://www.moguproxy.com/buy">购买</a>相应的套餐来获得商业 IP 代理。作为商业用途，建议大家购买不限量套餐，这样可以根据实际需要获取足够多的代理 IP 地址；作为学习用途，可以购买包时套餐或根据自己的需求来决定。蘑菇代理提供了两种接入代理的方式，分别是 API 私密代理和 HTTP 隧道代理，前者是通过请求蘑菇代理的 API 接口获取代理服务器地址，后者是直接使用统一的入口（蘑菇代理提供的域名）进行接入。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210829080647.png" width="75%"><p>下面，我们以HTTP隧道代理为例，为大家讲解接入 IP 代理的方式，大家也可以直接参考蘑菇代理官网提供的代码来为爬虫设置代理。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import requestsAPP_KEY = 'Wnp******************************XFx'PROXY_HOST = 'secondtransfer.moguproxy.com:9001'for page in range(1, 11):    resp = requests.get(        url=f'https://movie.douban.com/top250?start={(page - 1) * 25}',        # 需要在HTTP请求头设置代理的身份认证方式        headers={            'Proxy-Authorization': f'Basic {APP_KEY}',            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36',            'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4'        },        # 设置代理服务器        proxies={            'http': f'http://{PROXY_HOST}',            'https': f'https://{PROXY_HOST}'        },        verify=False    )    pattern1 = re.compile(r'&lt;span class="title"&gt;([^&amp;]*?)&lt;/span&gt;')    titles = pattern1.findall(resp.text)    pattern2 = re.compile(r'&lt;span class="rating_num".*?&gt;(.*?)&lt;/span&gt;')    ranks = pattern2.findall(resp.text)    for title, rank in zip(titles, ranks):        print(title, rank)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面的代码需要修改<code>APP_KEY</code>为自己创建的订单对应的<code>Appkey</code>值，这个值可以在用户中心用户订单中查看到。蘑菇代理提供了免费的 API 代理和 HTTP 隧道代理试用，但是试用的代理接通率不能保证，建议大家还是直接购买一个在自己支付能力范围内的代理服务来体验。</p><p><strong>另注</strong>：蘑菇代理目前已经停止服务了，大家可以按照上面讲解的方式使用其他商业代理即可。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python 语言能做的事情真的很多，就网络数据采集这一项而言，Python 几乎是一枝独秀的，大量的企业和个人都在使用 Python 从网络上获取自己需要的数据，这可能也是你将来日常工作的一部分。另外，用编写正则表达式的方式从网页中提取内容虽然可行，但是写出一个能够满足需求的正则表达式本身也不是件容易的事情，这一点对于新手来说尤为明显。在下一节课中，我们将会为大家介绍另外两种从页面中提取数据的方法，虽然从性能上来讲，它们可能不如正则表达式，但是却降低了编码的复杂性，相信大家会喜欢上它们的。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第33课：用Python解析HTML页面</title>
      <link href="/blog/ukknbld6.html"/>
      <url>/blog/ukknbld6.html</url>
      
        <content type="html"><![CDATA[<h2 id="第33课：用Python解析HTML页面"><a href="#第33课：用Python解析HTML页面" class="headerlink" title="第33课：用Python解析HTML页面"></a>第33课：用Python解析HTML页面</h2><p>在前面的课程中，我们讲到了使用<code>request</code>三方库获取网络资源，还介绍了一些前端的基础知识。接下来，我们继续探索如何解析 HTML 代码，从页面中提取出有用的信息。之前，我们尝试过用正则表达式的捕获组操作提取页面内容，但是写出一个正确的正则表达式也是一件让人头疼的事情。为了解决这个问题，我们得先深入的了解一下 HTML 页面的结构，并在此基础上研究另外的解析页面的方法。</p><h3 id="HTML-页面的结构"><a href="#HTML-页面的结构" class="headerlink" title="HTML 页面的结构"></a>HTML 页面的结构</h3><p>我们在浏览器中打开任意一个网站，然后通过鼠标右键菜单，选择“显示网页源代码”菜单项，就可以看到网页对应的 HTML 代码。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210822094218.png"></p><p>代码的第<code>1</code>行是文档类型声明，第<code>2</code>行的<code>&lt;html&gt;</code>标签是整个页面根标签的开始标签，最后一行是根标签的结束标签<code>&lt;/html&gt;</code>。<code>&lt;html&gt;</code>标签下面有两个子标签<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>，放在<code>&lt;body&gt;</code>标签下的内容会显示在浏览器窗口中，这部分内容是网页的主体；放在<code>&lt;head&gt;</code>标签下的内容不会显示在浏览器窗口中，但是却包含了页面重要的元信息，通常称之为网页的头部。HTML 页面大致的代码结构如下所示。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!doctype html&gt;&lt;html&gt;    &lt;head&gt;        &lt;!-- 页面的元信息，如字符编码、标题、关键字、媒体查询等 --&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 页面的主体，显示在浏览器窗口中的内容 --&gt;    &lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标签、层叠样式表（CSS）、JavaScript 是构成 HTML 页面的三要素，其中标签用来承载页面要显示的内容，CSS 负责对页面的渲染，而 JavaScript 用来控制页面的交互式行为。要实现 HTML 页面的解析，可以使用 XPath 的语法，它原本是 XML 的一种查询语法，可以根据 HTML 标签的层次结构提取标签中的内容或标签属性；此外，也可以使用 CSS 选择器来定位页面元素，就跟用 CSS 渲染页面元素是同样的道理。</p><h3 id="XPath-解析"><a href="#XPath-解析" class="headerlink" title="XPath 解析"></a>XPath 解析</h3><p>XPath 是在 XML（eXtensible Markup Language）文档中查找信息的一种语法，XML 跟 HTML 类似也是一种用标签承载数据的标签语言，不同之处在于 XML 的标签是可扩展的，可以自定义的，而且 XML 对语法有更严格的要求。XPath 使用路径表达式来选取 XML 文档中的节点或者节点集，这里所说的节点包括元素、属性、文本、命名空间、处理指令、注释、根节点等。下面我们通过一个例子来说明如何使用 XPath 对页面进行解析。</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bookstore&gt;    &lt;book&gt;      &lt;title lang="eng"&gt;Harry Potter&lt;/title&gt;      &lt;price&gt;29.99&lt;/price&gt;    &lt;/book&gt;    &lt;book&gt;      &lt;title lang="zh"&gt;Learning XML&lt;/title&gt;      &lt;price&gt;39.95&lt;/price&gt;    &lt;/book&gt;&lt;/bookstore&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上面的 XML 文件，我们可以用如下所示的 XPath 语法获取文档中的节点。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>/bookstore</code></td><td>选取根元素 bookstore。<strong>注意</strong>：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td></tr><tr><td><code>//book</code></td><td>选取所有 book 子元素，而不管它们在文档中的位置。</td></tr><tr><td><code>//@lang</code></td><td>选取名为 lang 的所有属性。</td></tr><tr><td><code>/bookstore/book[1]</code></td><td>选取属于 bookstore 子元素的第一个 book 元素。</td></tr><tr><td><code>/bookstore/book[last()]</code></td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td><code>/bookstore/book[last()-1]</code></td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td><code>/bookstore/book[position()&lt;3]</code></td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td><code>//title[@lang]</code></td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td><code>//title[@lang='eng']</code></td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td><code>/bookstore/book[price&gt;35.00]</code></td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td></tr><tr><td><code>/bookstore/book[price&gt;35.00]/title</code></td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td></tr></tbody></table><p>XPath还支持通配符用法，如下所示。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>/bookstore/*</code></td><td>选取 bookstore 元素的所有子元素。</td></tr><tr><td><code>//*</code></td><td>选取文档中的所有元素。</td></tr><tr><td><code>//title[@*]</code></td><td>选取所有带有属性的 title 元素。</td></tr></tbody></table><p>如果要选取多个节点，可以使用如下所示的方法。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>//book/title | //book/price</code></td><td>选取 book 元素的所有 title 和 price 元素。</td></tr><tr><td><code>//title | //price</code></td><td>选取文档中的所有 title 和 price 元素。</td></tr><tr><td><code>/bookstore/book/title | //price</code></td><td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td></tr></tbody></table><blockquote><p><strong>说明</strong>：上面的例子来自于“菜鸟教程”网站上的 <a href="https://www.runoob.com/xpath/xpath-tutorial.html">XPath 教程</a>，有兴趣的读者可以自行阅读原文。</p></blockquote><p>当然，如果不理解或不熟悉 XPath 语法，可以在浏览器的开发者工具中按照如下所示的方法查看元素的 XPath 语法，下图是在 Chrome 浏览器的开发者工具中查看豆瓣网电影详情信息中影片标题的 XPath 语法。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210822093707.png"></p><p>实现 XPath 解析需要三方库<code>lxml</code> 的支持，可以使用下面的命令安装<code>lxml</code>。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install lxml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面我们用 XPath 解析方式改写之前获取豆瓣电影 Top250的代码，如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from lxml import etreeimport requestsfor page in range(1, 11):    resp = requests.get(        url=f'https://movie.douban.com/top250?start={(page - 1) * 25}',        headers={'User-Agent': 'BaiduSpider'}    )    tree = etree.HTML(resp.text)    # 通过XPath语法从页面中提取电影标题    title_spans = tree.xpath('//*[@id="content"]/div/div[1]/ol/li/div/div[2]/div[1]/a/span[1]')    # 通过XPath语法从页面中提取电影评分    rank_spans = tree.xpath('//*[@id="content"]/div/div[1]/ol/li[1]/div/div[2]/div[2]/div/span[2]')    for title_span, rank_span in zip(title_spans, rank_spans):        print(title_span.text, rank_span.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CSS-选择器解析"><a href="#CSS-选择器解析" class="headerlink" title="CSS 选择器解析"></a>CSS 选择器解析</h3><p>对于熟悉 CSS 选择器和 JavaScript 的开发者来说，通过 CSS 选择器获取页面元素可能是更为简单的选择，因为浏览器中运行的 JavaScript 本身就可以<code>document</code>对象的<code>querySelector()</code>和<code>querySelectorAll()</code>方法基于 CSS 选择器获取页面元素。在 Python 中，我们可以利用三方库<code>beautifulsoup4</code>或<code>pyquery</code>来做同样的事情。Beautiful Soup 可以用来解析 HTML 和 XML 文档，修复含有未闭合标签等错误的文档，通过为待解析的页面在内存中创建一棵树结构，实现对从页面中提取数据操作的封装。可以用下面的命令来安装 Beautiful Soup。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">pip install beautifulsoup4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面是使用<code>bs4</code>改写的获取豆瓣电影Top250电影名称的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import bs4import requestsfor page in range(1, 11):    resp = requests.get(        url=f'https://movie.douban.com/top250?start={(page - 1) * 25}',        headers={'User-Agent': 'BaiduSpider'}    )    # 创建BeautifulSoup对象    soup = bs4.BeautifulSoup(resp.text, 'lxml')    # 通过CSS选择器从页面中提取包含电影标题的span标签    title_spans = soup.select('div.info &gt; div.hd &gt; a &gt; span:nth-child(1)')    # 通过CSS选择器从页面中提取包含电影评分的span标签    rank_spans = soup.select('div.info &gt; div.bd &gt; div &gt; span.rating_num')    for title_span, rank_span in zip(title_spans, rank_spans):        print(title_span.text, rank_span.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 BeautifulSoup 更多的知识，可以参考它的<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">官方文档</a>。</p><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>下面我们对三种解析方式做一个简单比较。</p><table><thead><tr><th>解析方式</th><th>对应的模块</th><th>速度</th><th>使用难度</th></tr></thead><tbody><tr><td>正则表达式解析</td><td><code>re</code></td><td>快</td><td>困难</td></tr><tr><td>XPath 解析</td><td><code>lxml</code></td><td>快</td><td>一般</td></tr><tr><td>CSS 选择器解析</td><td><code>bs4</code>或<code>pyquery</code></td><td>不确定</td><td>简单</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第34课：Python中的并发编程-1</title>
      <link href="/blog/r1leme7c.html"/>
      <url>/blog/r1leme7c.html</url>
      
        <content type="html"><![CDATA[<h2 id="第34课：Python中的并发编程-1"><a href="#第34课：Python中的并发编程-1" class="headerlink" title="第34课：Python中的并发编程-1"></a>第34课：Python中的并发编程-1</h2><p>现如今，我们使用的计算机早已是多 CPU 或多核的计算机，而我们使用的操作系统基本都支持“多任务”，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务“并行”或“并发”的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此当下，不管用什么编程语言进行开发，实现“并行”或“并发”编程已经成为了程序员的标配技能。为了讲述如何在 Python 程序中实现“并行”或“并发”，我们需要先了解两个重要的概念：进程和线程。</p><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>我们通过操作系统运行一个程序会创建出一个或多个进程，进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。简单的说，进程是操作系统分配存储空间的基本单位，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据；操作系统管理所有进程的执行，为它们合理的分配资源。一个进程可以通过 fork 或 spawn 的方式创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此两个进程如果要共享数据，必须通过进程间通信机制来实现，具体的方式包括管道、信号、套接字等。</p><p>一个进程还可以拥有多个执行线索，简单的说就是拥有多个可以获得 CPU 调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核 CPU 系统中，多个线程不可能同时执行，因为在某个时刻只有一个线程能够获得 CPU，多个线程通过共享 CPU 执行时间的方式来达到并发的效果。</p><p>在程序中使用多线程技术通常都会带来不言而喻的好处，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如 macOS 中的“活动监视器”、Windows 中的“任务管理器”）来证实，如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210822094243.png" width="80%"><p>这里，我们还需要跟大家再次强调两个概念：<strong>并发</strong>（concurrency）和<strong>并行</strong>（parallel）。<strong>并发</strong>通常是指同一时刻只能有一条指令执行，但是多个线程对应的指令被快速轮换地执行。比如一个处理器，它先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。由于处理器执行指令的速度和切换的速度极快，人们完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行，但微观上其实只有一个线程在执行。<strong>并行</strong>是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器，不论是从宏观上还是微观上，多个线程可以在同一时刻一起执行的。很多时候，我们并不用严格区分并发和并行两个词，所以我们有时候也把 Python 中的多线程、多进程以及异步 I/O 都视为实现并发编程的手段，但实际上前面两者也可以实现并行编程，当然这里还有一个全局解释器锁（GIL）的问题，我们稍后讨论。</p><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><p>Python 标准库中<code>threading</code>模块的<code>Thread</code>类可以帮助我们非常轻松的实现多线程编程。我们用一个联网下载文件的例子来对比使用多线程和不使用多线程到底有什么区别，代码如下所示。</p><p>不使用多线程的下载。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport timedef download(*, filename):    start = time.time()    print(f'开始下载 {filename}.')    time.sleep(random.randint(3, 6))    print(f'{filename} 下载完成.')    end = time.time()    print(f'下载耗时: {end - start:.3f}秒.')def main():    start = time.time()    download(filename='Python从入门到住院.pdf')    download(filename='MySQL从删库到跑路.avi')    download(filename='Linux从精通到放弃.mp4')    end = time.time()    print(f'总耗时: {end - start:.3f}秒.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面的代码并没有真正实现联网下载的功能，而是通过<code>time.sleep()</code>休眠一段时间来模拟下载文件需要一些时间上的开销，跟实际下载的状况比较类似。</p></blockquote><p>运行上面的代码，可以得到如下所示的运行结果。可以看出，当我们的程序只有一个工作线程时，每个下载任务都需要等待上一个下载任务执行结束才能开始，所以程序执行的总耗时是三个下载任务各自执行时间的总和。</p><pre class="line-numbers language-none"><code class="language-none">开始下载Python从入门到住院.pdf.Python从入门到住院.pdf下载完成.下载耗时: 3.005秒.开始下载MySQL从删库到跑路.avi.MySQL从删库到跑路.avi下载完成.下载耗时: 5.006秒.开始下载Linux从精通到放弃.mp4.Linux从精通到放弃.mp3下载完成.下载耗时: 6.007秒.总耗时: 14.018秒.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，上面的三个下载任务之间并没有逻辑上的因果关系，三者是可以“并发”的，下一个下载任务没有必要等待上一个下载任务结束，为此，我们可以使用多线程编程来改写上面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport timefrom threading import Threaddef download(*, filename):    start = time.time()    print(f'开始下载 {filename}.')    time.sleep(random.randint(3, 6))    print(f'{filename} 下载完成.')    end = time.time()    print(f'下载耗时: {end - start:.3f}秒.')def main():    threads = [        Thread(target=download, kwargs={'filename': 'Python从入门到住院.pdf'}),        Thread(target=download, kwargs={'filename': 'MySQL从删库到跑路.avi'}),        Thread(target=download, kwargs={'filename': 'Linux从精通到放弃.mp4'})    ]    start = time.time()    # 启动三个线程    for thread in threads:        thread.start()    # 等待线程结束    for thread in threads:        thread.join()    end = time.time()    print(f'总耗时: {end - start:.3f}秒.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>某次的运行结果如下所示。</p><pre class="line-numbers language-none"><code class="language-none">开始下载 Python从入门到住院.pdf.开始下载 MySQL从删库到跑路.avi.开始下载 Linux从精通到放弃.mp4.MySQL从删库到跑路.avi 下载完成.下载耗时: 3.005秒.Python从入门到住院.pdf 下载完成.下载耗时: 5.006秒.Linux从精通到放弃.mp4 下载完成.下载耗时: 6.003秒.总耗时: 6.004秒.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的运行结果可以发现，整个程序的执行时间几乎等于耗时最长的一个下载任务的执行时间，这也就意味着，三个下载任务是并发执行的，不存在一个等待另一个的情况，这样做很显然提高了程序的执行效率。简单的说，如果程序中有非常耗时的执行单元，而这些耗时的执行单元之间又没有逻辑上的因果关系，即 B 单元的执行不依赖于 A 单元的执行结果，那么 A 和 B 两个单元就可以放到两个不同的线程中，让他们并发的执行。这样做的好处除了减少程序执行的等待时间，还可以带来更好的用户体验，因为一个单元的阻塞不会造成程序的“假死”，因为程序中还有其他的单元是可以运转的。</p><h4 id="使用-Thread-类创建线程对象"><a href="#使用-Thread-类创建线程对象" class="headerlink" title="使用 Thread 类创建线程对象"></a>使用 Thread 类创建线程对象</h4><p>通过上面的代码可以看出，直接使用<code>Thread</code>类的构造器就可以创建线程对象，而线程对象的<code>start()</code>方法可以启动一个线程。线程启动后会执行<code>target</code>参数指定的函数，当然前提是获得 CPU 的调度；如果<code>target</code>指定的线程要执行的目标函数有参数，需要通过<code>args</code>参数为其进行指定，对于关键字参数，可以通过<code>kwargs</code>参数进行传入。<code>Thread</code>类的构造器还有很多其他的参数，我们遇到的时候再为大家进行讲解，目前需要大家掌握的，就是<code>target</code>、<code>args</code>和<code>kwargs</code>。</p><h4 id="继承-Thread-类自定义线程"><a href="#继承-Thread-类自定义线程" class="headerlink" title="继承 Thread 类自定义线程"></a>继承 Thread 类自定义线程</h4><p>除了上面的代码展示的创建线程的方式外，还可以通过继承<code>Thread</code>类并重写<code>run()</code>方法的方式来自定义线程，具体的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport timefrom threading import Threadclass DownloadThread(Thread):    def __init__(self, filename):        self.filename = filename        super().__init__()    def run(self):        start = time.time()        print(f'开始下载 {self.filename}.')        time.sleep(random.randint(3, 6))        print(f'{self.filename} 下载完成.')        end = time.time()        print(f'下载耗时: {end - start:.3f}秒.')def main():    threads = [        DownloadThread('Python从入门到住院.pdf'),        DownloadThread('MySQL从删库到跑路.avi'),        DownloadThread('Linux从精通到放弃.mp4')    ]    start = time.time()    # 启动三个线程    for thread in threads:        thread.start()    # 等待线程结束    for thread in threads:        thread.join()    end = time.time()    print(f'总耗时: {end - start:.3f}秒.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h4><p>我们还可以通过线程池的方式将任务放到多个线程中去执行，通过线程池来使用线程应该是多线程编程最理想的选择。事实上，线程的创建和释放都会带来较大的开销，频繁的创建和释放线程通常都不是很好的选择。利用线程池，可以提前准备好若干个线程，在使用的过程中不需要再通过自定义的代码创建和释放线程，而是直接复用线程池中的线程。Python 内置的<code>concurrent.futures</code>模块提供了对线程池的支持，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomimport timefrom concurrent.futures import ThreadPoolExecutorfrom threading import Threaddef download(*, filename):    start = time.time()    print(f'开始下载 {filename}.')    time.sleep(random.randint(3, 6))    print(f'{filename} 下载完成.')    end = time.time()    print(f'下载耗时: {end - start:.3f}秒.')def main():    with ThreadPoolExecutor(max_workers=4) as pool:        filenames = ['Python从入门到住院.pdf', 'MySQL从删库到跑路.avi', 'Linux从精通到放弃.mp4']        start = time.time()        for filename in filenames:            pool.submit(download, filename=filename)    end = time.time()    print(f'总耗时: {end - start:.3f}秒.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>所谓“守护线程”就是在主线程结束的时候，不值得再保留的执行线程。这里的不值得保留指的是守护线程会在其他非守护线程全部运行结束之后被销毁，它守护的是当前进程内所有的非守护线程。简单的说，守护线程会跟随主线程一起挂掉，而主线程的生命周期就是一个进程的生命周期。如果不理解，我们可以看一段简单的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timefrom threading import Threaddef display(content):    while True:        print(content, end='', flush=True)        time.sleep(0.1)def main():    Thread(target=display, args=('Ping', )).start()    Thread(target=display, args=('Pong', )).start()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面的代码中，我们将<code>print</code>函数的参数<code>flush</code>设置为<code>True</code>，这是因为<code>flush</code>参数的值如果为<code>False</code>，而<code>print</code>又没有做换行处理，就会导致每次<code>print</code>输出的内容被放到操作系统的输出缓冲区，直到缓冲区被输出的内容塞满，才会清空缓冲区产生一次输出。上述现象是操作系统为了减少 I/O 中断，提升 CPU 利用率做出的设定，为了让代码产生直观交互，我们才将<code>flush</code>参数设置为<code>True</code>，强制每次输出都清空输出缓冲区。</p></blockquote><p>上面的代码运行起来之后是不会停止的，因为两个子线程中都有死循环，除非你手动中断代码的执行。但是，如果在创建线程对象时，将名为<code>daemon</code>的参数设置为<code>True</code>，这两个线程就会变成守护线程，那么在其他线程结束时，即便有死循环，两个守护线程也会挂掉，不会再继续执行下去，代码如下所示。</p> <pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timefrom threading import Threaddef display(content):    while True:        print(content, end='', flush=True)        time.sleep(0.1)def main():    Thread(target=display, args=('Ping', ), daemon=True).start()    Thread(target=display, args=('Pong', ), daemon=True).start()    time.sleep(5)if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码，我们在主线程中添加了一行<code>time.sleep(5)</code>让主线程休眠5秒，在这个过程中，输出<code>Ping</code>和<code>Pong</code>的守护线程会持续运转，直到主线程在5秒后结束，这两个守护线程也被销毁，不再继续运行。</p><blockquote><p><strong>思考</strong>：如果将上面代码第12行的<code>daemon=True</code>去掉，代码会怎样执行？有兴趣的读者可以尝试一下，并看看实际执行的结果跟你想象的是否一致。</p></blockquote><h3 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h3><p>在编写多线程代码时，不可避免的会遇到多个线程竞争同一个资源（对象）的情况。在这种情况下，如果没有合理的机制来保护被竞争的资源，那么就有可能出现非预期的状况。下面的代码创建了<code>100</code>个线程向同一个银行账户（初始余额为<code>0</code>元）转账，每个线程转账金额为<code>1</code>元。在正常的情况下，我们的银行账户最终的余额应该是<code>100</code>元，但是运行下面的代码我们并不能得到<code>100</code>元这个结果。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timefrom concurrent.futures import ThreadPoolExecutorclass Account(object):    """银行账户"""    def __init__(self):        self.balance = 0.0    def deposit(self, money):        """存钱"""        new_balance = self.balance + money        time.sleep(0.01)        self.balance = new_balancedef main():    """主函数"""    account = Account()    with ThreadPoolExecutor(max_workers=16) as pool:        for _ in range(100):            pool.submit(account.deposit, 1)    print(account.balance)if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中的<code>Account</code>类代表了银行账户，它的<code>deposit</code>方法代表存款行为，参数<code>money</code>代表存入的金额，该方法通过<code>time.sleep</code>函数模拟受理存款需要一段时间。我们通过线程池的方式启动了<code>100</code>个线程向一个账户转账，但是上面的代码并不能运行出<code>100</code>这个我们期望的结果，这就是在多个线程竞争一个资源的时候，可能会遇到的数据不一致的问题。注意上面代码的第<code>14</code>行，当多个线程都执行到这行代码时，它们会在相同的余额上执行加上存入金额的操作，这就会造成“丢失更新”现象，即之前修改数据的成果被后续的修改给覆盖掉了，所以才得不到正确的结果。</p><p>要解决上面的问题，可以使用锁机制，通过锁对操作数据的关键代码加以保护。Python 标准库的<code>threading</code>模块提供了<code>Lock</code>和<code>RLock</code>类来支持锁机制，这里我们不去深究二者的区别，建议大家直接使用<code>RLock</code>。接下来，我们给银行账户添加一个锁对象，通过锁对象来解决刚才存款时发生“丢失更新”的问题，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timefrom concurrent.futures import ThreadPoolExecutorfrom threading import RLockclass Account(object):    """银行账户"""    def __init__(self):        self.balance = 0.0        self.lock = RLock()    def deposit(self, money):        # 获得锁        self.lock.acquire()        try:            new_balance = self.balance + money            time.sleep(0.01)            self.balance = new_balance        finally:            # 释放锁            self.lock.release()def main():    """主函数"""    account = Account()    with ThreadPoolExecutor(max_workers=16) as pool:        for _ in range(100):            pool.submit(account.deposit, 1)    print(account.balance)if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，获得锁和释放锁的操作也可以通过上下文语法来实现，使用上下文语法会让代码更加简单优雅，这也是我们推荐大家使用的方式。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timefrom concurrent.futures import ThreadPoolExecutorfrom threading import RLockclass Account(object):    """银行账户"""    def __init__(self):        self.balance = 0.0        self.lock = RLock()    def deposit(self, money):        # 通过上下文语法获得锁和释放锁        with self.lock:            new_balance = self.balance + money            time.sleep(0.01)            self.balance = new_balancedef main():    """主函数"""    account = Account()    with ThreadPoolExecutor(max_workers=16) as pool:        for _ in range(100):            pool.submit(account.deposit, 1)    print(account.balance)if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>思考</strong>：将上面的代码修改为5个线程向银行账户存钱，5个线程从银行账户取钱，取钱的线程在银行账户余额不足时，需要停下来等待存钱的线程将钱存入后再尝试取钱。这里需要用到线程调度的知识，大家可以自行研究下<code>threading</code>模块中的<code>Condition</code>类，看看是否能够完成这个任务。</p></blockquote><h3 id="GIL问题"><a href="#GIL问题" class="headerlink" title="GIL问题"></a>GIL问题</h3><p>如果使用官方的 Python 解释器（通常称之为 CPython）运行 Python 程序，我们并不能通过使用多线程的方式将 CPU 的利用率提升到逼近400%（对于4核 CPU）或逼近800%（对于8核 CPU）这样的水平，因为 CPython 在执行代码时，会受到 GIL（全局解释器锁）的限制。具体的说，CPython 在执行任何代码时，都需要对应的线程先获得 GIL，然后每执行100条（字节码）指令，CPython 就会让获得 GIL 的线程主动释放 GIL，这样别的线程才有机会执行。因为 GIL 的存在，无论你的 CPU 有多少个核，我们编写的 Python 代码也没有机会真正并行的执行。</p><p>GIL 是官方 Python 解释器在设计上的历史遗留问题，要解决这个问题，让多线程能够发挥 CPU 的多核优势，需要重新实现一个不带 GIL 的 Python 解释器。这个问题按照官方的说法，在 Python 发布4.0版本时会得到解决，就让我们拭目以待吧。当下，对于 CPython 而言，如果希望充分发挥 CPU 的多核优势，可以考虑使用多进程，因为每个进程都对应一个 Python 解释器，因此每个进程都有自己独立的 GIL，这样就可以突破 GIL 的限制。在下一个章节中，我们会为大家介绍关于多进程的相关知识，并对多线程和多进程的代码及其执行效果进行比较。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第35课：Python中的并发编程-2</title>
      <link href="/blog/bepijpbh.html"/>
      <url>/blog/bepijpbh.html</url>
      
        <content type="html"><![CDATA[<h2 id="第35课：Python中的并发编程-2"><a href="#第35课：Python中的并发编程-2" class="headerlink" title="第35课：Python中的并发编程-2"></a>第35课：Python中的并发编程-2</h2><p>在上一课中我们说过，由于 GIL 的存在，CPython 中的多线程并不能发挥 CPU 的多核优势，如果希望突破 GIL 的限制，可以考虑使用多进程。对于多进程的程序，每个进程都有一个属于自己的 GIL，所以多进程不会受到 GIL 的影响。那么，我们应该如何在 Python 程序中创建和使用多进程呢？</p><p>###创建进程</p><p>在 Python 中可以基于<code>Process</code>类来创建进程，虽然进程和线程有着本质的差别，但是<code>Process</code>类和<code>Thread</code>类的用法却非常类似。在使用<code>Process</code>类的构造器创建对象时，也是通过<code>target</code>参数传入一个函数来指定进程要执行的代码，而<code>args</code>和<code>kwargs</code>参数可以指定该函数使用的参数值。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from multiprocessing import Process, current_processfrom time import sleepdef sub_task(content, nums):    # 通过current_process函数获取当前进程对象    # 通过进程对象的pid和name属性获取进程的ID号和名字    print(f'PID: {current_process().pid}')    print(f'Name: {current_process().name}')    # 通过下面的输出不难发现，每个进程都有自己的nums列表，进程之间本就不共享内存    # 在创建子进程时复制了父进程的数据结构，三个进程从列表中pop(0)得到的值都是20    counter, total = 0, nums.pop(0)    print(f'Loop count: {total}')    sleep(0.5)    while counter &lt; total:        counter += 1        print(f'{counter}: {content}')        sleep(0.01)def main():    nums = [20, 30, 40]    # 创建并启动进程来执行指定的函数    Process(target=sub_task, args=('Ping', nums)).start()    Process(target=sub_task, args=('Pong', nums)).start()    # 在主进程中执行sub_task函数    sub_task('Good', nums)if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面的代码通过<code>current_process</code>函数获取当前进程对象，再通过进程对象的<code>pid</code>属性获取进程ID。在 Python 中，使用<code>os</code>模块的<code>getpid</code>函数也可以达到同样的效果。</p></blockquote><p>如果愿意，也可以使用<code>os</code>模块的<code>fork</code>函数来创建进程，调用该函数时，操作系统自动把当前进程（父进程）复制一份（子进程），父进程的<code>fork</code>函数会返回子进程的ID，而子进程中的<code>fork</code>函数会返回<code>0</code>，也就是说这个函数调用一次会在父进程和子进程中得到两个不同的返回值。需要注意的是，Windows 系统并不支持<code>fork</code>函数，如果你使用的是 Linux 或 macOS 系统，可以试试下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import osprint(f'PID: {os.getpid()}')pid = os.fork()if pid == 0:    print(f'子进程 - PID: {os.getpid()}')    print('Todo: 在子进程中执行的代码')else:    print(f'父进程 - PID: {os.getpid()}')    print('Todo: 在父进程中执行的代码')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，我们还是推荐大家通过直接使用<code>Process</code>类、继承<code>Process</code>类和使用进程池（<code>ProcessPoolExecutor</code>）这三种方式来创建和使用多进程，这三种方式不同于上面的<code>fork</code>函数，能够保证代码的兼容性和可移植性。具体的做法跟之前讲过的创建和使用多线程的方式比较接近，此处不再进行赘述。</p><h3 id="多进程和多线程的比较"><a href="#多进程和多线程的比较" class="headerlink" title="多进程和多线程的比较"></a>多进程和多线程的比较</h3><p>对于爬虫这类 I/O 密集型任务来说，使用多进程并没有什么优势；但是对于计算密集型任务来说，多进程相比多线程，在效率上会有显著的提升，我们可以通过下面的代码来加以证明。下面的代码会通过多线程和多进程两种方式来判断一组大整数是不是质数，很显然这是一个计算密集型任务，我们将任务分别放到多个线程和多个进程中来加速代码的执行，让我们看看多线程和多进程的代码具体表现有何不同。</p><p>我们先实现一个多线程的版本，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import concurrent.futuresPRIMES = [    1116281,    1297337,    104395303,    472882027,    533000389,    817504243,    982451653,    112272535095293,    112582705942171,    112272535095293,    115280095190773,    115797848077099,    1099726899285419] * 5def is_prime(n):    """判断素数"""    for i in range(2, int(n ** 0.5) + 1):        if n % i == 0:            return False    return n != 1def main():    """主函数"""    with concurrent.futures.ThreadPoolExecutor(max_workers=16) as executor:        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):            print('%d is prime: %s' % (number, prime))if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设上面的代码保存在名为<code>example.py</code>的文件中，在 Linux 或 macOS 系统上，可以使用<code>time python example.py</code>命令执行程序并获得操作系统关于执行时间的统计，在我的 macOS 上，某次的运行结果的最后一行输出如下所示。</p><pre class="line-numbers language-none"><code class="language-none">python example09.py  38.69s user 1.01s system 101% cpu 39.213 total<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从运行结果可以看出，多线程的代码只能让 CPU 利用率达到100%，这其实已经证明了多线程的代码无法利用 CPU 多核特性来加速代码的执行，我们再看看多进程的版本，我们将上面代码中的线程池（<code>ThreadPoolExecutor</code>）更换为进程池（<code>ProcessPoolExecutor</code>）。</p><p>多进程的版本。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import concurrent.futuresPRIMES = [    1116281,    1297337,    104395303,    472882027,    533000389,    817504243,    982451653,    112272535095293,    112582705942171,    112272535095293,    115280095190773,    115797848077099,    1099726899285419] * 5def is_prime(n):    """判断素数"""    for i in range(2, int(n ** 0.5) + 1):        if n % i == 0:            return False    return n != 1def main():    """主函数"""    with concurrent.futures.ProcessPoolExecutor(max_workers=16) as executor:        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):            print('%d is prime: %s' % (number, prime))if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：运行上面的代码时，可以通过操作系统的任务管理器（资源监视器）来查看是否启动了多个 Python  解释器进程。</p></blockquote><p>我们仍然通过<code>time python example.py</code>的方式来执行上述代码，运行结果的最后一行如下所示。</p><pre class="line-numbers language-none"><code class="language-none">python example09.py 106.63s user 0.57s system 389% cpu 27.497 total<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出，多进程的版本在我使用的这台电脑上，让 CPU 的利用率达到了将近400%，而运行代码时用户态耗费的 CPU 的时间（106.63秒）几乎是代码运行总时间（27.497秒）的4倍，从这两点都可以看出，我的电脑使用了一款4核的 CPU。当然，要知道自己的电脑有几个 CPU 或几个核，可以直接使用下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import osprint(os.cpu_count())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>综上所述，多进程可以突破 GIL 的限制，充分利用 CPU 多核特性，对于计算密集型任务，这一点是相当重要的。常见的计算密集型任务包括科学计算、图像处理、音视频编解码等，如果这些计算密集型任务本身是可以并行的，那么使用多进程应该是更好的选择。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>在讲解进程间通信之前，先给大家一个任务：启动两个进程，一个输出“Ping”，一个输出“Pong”，两个进程输出的“Ping”和“Pong”加起来一共有50个时，就结束程序。听起来是不是非常简单，但是实际编写代码时，由于多个进程之间不能够像多个线程之间直接通过共享内存的方式交换数据，所以下面的代码是达不到我们想要的结果的。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from multiprocessing import Processfrom time import sleepcounter = 0def sub_task(string):    global counter    while counter &lt; 50:        print(string, end='', flush=True)        counter += 1        sleep(0.01)        def main():    Process(target=sub_task, args=('Ping', )).start()    Process(target=sub_task, args=('Pong', )).start()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码看起来没毛病，但是最后的结果是“Ping”和“Pong”各输出了50个。再次提醒大家，当我们在程序中创建进程的时候，子进程会复制父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个<code>counter</code>变量，它们都会从<code>0</code>加到<code>50</code>，所以结果就可想而知了。要解决这个问题比较简单的办法是使用<code>multiprocessing</code>模块中的<code>Queue</code>类，它是可以被多个进程共享的队列，底层是通过操作系统底层的管道和信号量（semaphore）机制来实现的，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timefrom multiprocessing import Process, Queuedef sub_task(content, queue):    counter = queue.get()    while counter &lt; 50:        print(content, end='', flush=True)        counter += 1        queue.put(counter)        time.sleep(0.01)        counter = queue.get()def main():    queue = Queue()    queue.put(0)    p1 = Process(target=sub_task, args=('Ping', queue))    p1.start()    p2 = Process(target=sub_task, args=('Pong', queue))    p2.start()    while p1.is_alive() and p2.is_alive():        pass    queue.put(50)if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：<code>multiprocessing.Queue</code>对象的<code>get</code>方法默认在队列为空时是会阻塞的，直到获取到数据才会返回。如果不希望该方法阻塞以及需要指定阻塞的超时时间，可以通过指定<code>block</code>和<code>timeout</code>参数进行设定。</p></blockquote><p>上面的代码通过<code>Queue</code>类的<code>get</code>和<code>put</code>方法让三个进程（<code>p1</code>、<code>p2</code>和主进程）实现了数据的共享，这就是所谓的进程间的通信，通过这种方式，当<code>Queue</code>中取出的值已经大于等于<code>50</code>时，<code>p1</code>和<code>p2</code>就会跳出<code>while</code>循环，从而终止进程的执行。代码第22行的循环是为了等待<code>p1</code>和<code>p2</code>两个进程中的一个结束，这时候主进程还需要向<code>Queue</code>中放置一个大于等于<code>50</code>的值，这样另一个尚未结束的进程也会因为读到这个大于等于<code>50</code>的值而终止。</p><p>进程间通信的方式还有很多，比如使用套接字也可以实现两个进程的通信，甚至于这两个进程并不在同一台主机上，有兴趣的读者可以自行了解。</p><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>在 Python 中，我们还可以通过<code>subprocess</code>模块的<code>call</code>函数执行其他的命令来创建子进程，相当于就是在我们的程序中调用其他程序，这里我们暂不探讨这些知识，有兴趣的读者可以自行研究。</p><p>对于Python开发者来说，以下情况需要考虑使用多线程：</p><ol><li>程序需要维护许多共享的状态（尤其是可变状态），Python 中的列表、字典、集合都是线程安全的（多个线程同时操作同一个列表、字典或集合，不会引发错误和数据问题），所以使用线程而不是进程维护共享状态的代价相对较小。</li><li>程序会花费大量时间在 I/O 操作上，没有太多并行计算的需求且不需占用太多的内存。</li></ol><p>那么在遇到下列情况时，应该考虑使用多进程：</p><ol><li>程序执行计算密集型任务（如：音视频编解码、数据压缩、科学计算等）。</li><li>程序的输入可以并行的分成块，并且可以将运算结果合并。</li><li>程序在内存使用方面没有任何限制且不强依赖于 I/O 操作（如读写文件、套接字等）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第36课：Python中的并发编程-3</title>
      <link href="/blog/p6i0btxq.html"/>
      <url>/blog/p6i0btxq.html</url>
      
        <content type="html"><![CDATA[<h2 id="第36课：Python中的并发编程-3"><a href="#第36课：Python中的并发编程-3" class="headerlink" title="第36课：Python中的并发编程-3"></a>第36课：Python中的并发编程-3</h2><p>爬虫是典型的 I/O 密集型任务，I/O 密集型任务的特点就是程序会经常性的因为 I/O 操作而进入阻塞状态，比如我们之前使用<code>requests</code>获取页面代码或二进制内容，发出一个请求之后，程序必须要等待网站返回响应之后才能继续运行，如果目标网站不是很给力或者网络状况不是很理想，那么等待响应的时间可能会很久，而在这个过程中整个程序是一直阻塞在那里，没有做任何的事情。通过前面的课程，我们已经知道了可以通过多线程的方式为爬虫提速，使用多线程的本质就是，当一个线程阻塞的时候，程序还有其他的线程可以继续运转，因此整个程序就不会在阻塞和等待中浪费了大量的时间。</p><p>事实上，还有一种非常适合 I/O 密集型任务的并发编程方式，我们称之为异步编程，你也可以将它称为异步 I/O。这种方式并不需要启动多个线程或多个进程来实现并发，它是通过多个子程序相互协作的方式来提升 CPU 的利用率，解决了 I/O 密集型任务 CPU  利用率很低的问题，我一般将这种方式称为“协作式并发”。这里，我不打算探讨操作系统的各种 I/O 模式，因为这对很多读者来说都太过抽象；但是我们得先抛出两组概念给大家，一组叫做“阻塞”和“非阻塞”，一组叫做“同步”和“异步”。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续处理其他的事情，则称该程序在该操作上是阻塞的。阻塞随时都可能发生，最典型的就是 I/O 中断（包括网络 I/O 、磁盘 I/O 、用户输入等）、休眠操作、等待某个线程执行结束，甚至包括在 CPU 切换上下文时，程序都无法真正的执行，这就是所谓的阻塞。</p><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>程序在等待某操作过程中，自身不被阻塞，可以继续处理其他的事情，则称该程序在该操作上是非阻塞的。非阻塞并不是在任何程序级别、任何情况下都可以存在的。仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。显然，某个操作的阻塞可能会导程序耗时以及效率低下，所以我们会希望把它变成非阻塞的。</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，我们称这些程序单元是同步执行的。例如前面讲过的给银行账户存钱的操作，我们在代码中使用了“锁”作为通信信号，让多个存钱操作强制排队顺序执行，这就是所谓的同步。</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>不同程序单元在执行过程中无需通信协调，也能够完成一个任务，这种方式我们就称之为异步。例如，使用爬虫下载页面时，调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是不相关的，也无需相互通知协调。很显然，异步操作的完成时刻和先后顺序并不能确定。</p><p>很多人都不太能准确的把握这几个概念，这里我们简单的总结一下，同步与异步的关注点是<strong>消息通信机制</strong>，最终表现出来的是“有序”和“无序”的区别；阻塞和非阻塞的关注点是<strong>程序在等待消息时状态</strong>，最终表现出来的是程序在等待时能不能做点别的。如果想深入理解这些内容，推荐大家阅读经典著作<a href="https://item.jd.com/11880047.html">《UNIX网络编程》</a>，这本书非常的赞。</p><h3 id="生成器和协程"><a href="#生成器和协程" class="headerlink" title="生成器和协程"></a>生成器和协程</h3><p>前面我们说过，异步编程是一种“协作式并发”，即通过多个子程序相互协作的方式提升 CPU 的利用率，从而减少程序在阻塞和等待中浪费的时间，最终达到并发的效果。我们可以将多个相互协作的子程序称为“协程”，它是实现异步编程的关键。在介绍协程之前，我们先通过下面的代码，看看什么是生成器。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def fib(max_count):    a, b = 0, 1    for _ in range(max_count):        a, b = b, a + b        yield a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们编写了一个生成斐波那契数列的生成器，调用上面的<code>fib</code>函数并不是执行该函数获得返回值，因为<code>fib</code>函数中有一个特殊的关键字<code>yield</code>。这个关键字使得<code>fib</code>函数跟普通的函数有些区别，调用该函数会得到一个生成器对象，我们可以通过下面的代码来验证这一点。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">gen_obj = fib(20)print(gen_obj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">&lt;generator object fib at 0x106daee40&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以使用内置函数<code>next</code>从生成器对象中获取斐波那契数列的值，也可以通过<code>for-in</code>循环对生成器能够提供的值进行遍历，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">for value in gen_obj:    print(value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成器经过预激活，就是一个协程，它可以跟其他子程序协作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def calc_average():    total, counter = 0, 0    avg_value = None    while True:        curr_value = yield avg_value        total += curr_value        counter += 1        avg_value = total / counterdef main():    obj = calc_average()    # 生成器预激活    obj.send(None)    for _ in range(5):        print(obj.send(float(input())))if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>main</code>函数首先通过生成器对象的<code>send</code>方法发送一个<code>None</code>值来将其激活为协程，也可以通过<code>next(obj)</code>达到同样的效果。接下来，协程对象会接收<code>main</code>函数发送的数据并产出（<code>yield</code>）数据的平均值。通过上面的例子，不知道大家是否看出两段子程序是怎么“协作”的。</p><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>Python 3.5版本中，引入了两个非常有意思的元素，一个叫<code>async</code>，一个叫<code>await</code>，它们在Python 3.7版本中成为了正式的关键字。通过这两个关键字，可以简化协程代码的编写，可以用更为简单的方式让多个子程序很好的协作起来。我们通过一个例子来加以说明，请大家先看看下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timedef display(num):    time.sleep(1)    print(num)def main():    start = time.time()    for i in range(1, 10):        display(i)    end = time.time()    print(f'{end - start:.3f}秒')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码每次执行都会依次输出<code>1</code>到<code>9</code>的数字，每个间隔<code>1</code>秒钟，整个代码需要执行大概需要<code>9</code>秒多的时间，这一点我相信大家都能看懂。不知道大家是否意识到，这段代码就是以同步和阻塞的方式执行的，同步可以从代码的输出看出来，而阻塞是指在调用<code>display</code>函数发生休眠时，整个代码的其他部分都不能继续执行，必须等待休眠结束。</p><p>接下来，我们尝试用异步的方式改写上面的代码，让<code>display</code>函数以异步的方式运转。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import asyncioimport timeasync def display(num):    await asyncio.sleep(1)    print(num)def main():    start = time.time()    objs = [display(i) for i in range(1, 10)]    loop = asyncio.get_event_loop()    loop.run_until_complete(asyncio.wait(objs))    loop.close()    end = time.time()    print(f'{end - start:.3f}秒')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 中的<code>asyncio</code>模块提供了对异步 I/O 的支持。上面的代码中，我们首先在<code>display</code>函数前面加上了<code>async</code>关键字使其变成一个异步函数，调用异步函数不会执行函数体而是获得一个协程对象。我们将<code>display</code>函数中的<code>time.sleep(1)</code>修改为<code>await asyncio.sleep(1)</code>，二者的区别在于，后者不会让整个代码陷入阻塞，因为<code>await</code>操作会让其他协作的子程序有获得 CPU 资源而得以运转的机会。为了让这些子程序可以协作起来，我们需要将他们放到一个事件循环（实现消息分派传递的系统）上，因为<strong>当协程遭遇 I/O 操作阻塞时，就会到事件循环中监听 I/O 操作是否完成，并注册自身的上下文以及自身的唤醒函数（以便恢复执行），之后该协程就变为阻塞状态</strong>。上面的第12行代码创建了<code>9</code>个协程对象并放到一个列表中，第13行代码通过<code>asyncio</code>模块的<code>get_event_loop</code>函数获得了系统的事件循环，第14行通过<code>asyncio</code>模块的<code>run_until_complete</code>函数将协程对象挂载到事件循环上。执行上面的代码会发现，<code>9</code>个分别会阻塞<code>1</code>秒钟的协程总共只阻塞了约<code>1</code>秒种的时间，因为<strong>阻塞的协程对象会放弃对 CPU 的占有而不是让 CPU 处于闲置状态，这种方式大大的提升了 CPU 的利用率</strong>。而且我们还会注意到，数字并不是按照从<code>1</code>到<code>9</code>的顺序打印输出的，这正是我们想要的结果，说明它们是<strong>异步执行</strong>的。对于爬虫这样的 I/O 密集型任务来说，这种协作式并发在很多场景下是比使用多线程更好的选择，因为这种做法减少了管理和维护多个线程以及多个线程切换所带来的开销。</p><h3 id="aiohttp库"><a href="#aiohttp库" class="headerlink" title="aiohttp库"></a>aiohttp库</h3><p>我们之前使用的<code>requests</code>三方库并不支持异步 I/O，如果希望使用异步 I/O 的方式来加速爬虫代码的执行，我们可以安装和使用名为<code>aiohttp</code>的三方库。</p><p>安装<code>aiohttp</code>。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install aiohttp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面的代码使用<code>aiohttp</code>抓取了<code>10</code>个网站的首页并解析出它们的标题。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import asyncioimport reimport aiohttpfrom aiohttp import ClientSessionTITLE_PATTERN = re.compile(r'&lt;title.*?&gt;(.*?)&lt;/title&gt;', re.DOTALL)async def fetch_page_title(url):    async with aiohttp.ClientSession(headers={        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36',    }) as session:  # type: ClientSession        async with session.get(url, ssl=False) as resp:            if resp.status == 200:                html_code = await resp.text()                matcher = TITLE_PATTERN.search(html_code)                title = matcher.group(1).strip()                print(title)def main():    urls = [        'https://www.python.org/',        'https://www.jd.com/',        'https://www.baidu.com/',        'https://www.taobao.com/',        'https://git-scm.com/',        'https://www.sohu.com/',        'https://gitee.com/',        'https://www.amazon.com/',        'https://www.usa.gov/',        'https://www.nasa.gov/'    ]    objs = [fetch_page_title(url) for url in urls]    loop = asyncio.get_event_loop()    loop.run_until_complete(asyncio.wait(objs))    loop.close()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！搜狐淘宝网 - 淘！我喜欢百度一下，你就知道Gitee - 基于 Git 的代码托管和研发协作平台GitNASAOfficial Guide to Government Information and Services   &amp;#124; USAGovAmazon.com. Spend less. Smile more.Welcome to Python.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的输出可以看出，网站首页标题的输出顺序跟它们的 URL 在列表中的顺序没有关系。代码的第11行到第13行创建了<code>ClientSession</code>对象，通过它的<code>get</code>方法可以向指定的 URL 发起请求，如第14行所示，跟<code>requests</code>中的<code>Session</code>对象并没有本质区别，唯一的区别是这里使用了异步上下文。代码第16行的<code>await</code>会让因为 I/O 操作阻塞的子程序放弃对 CPU 的占用，这使得其他的子程序可以运转起来去抓取页面。代码的第17行和第18行使用了正则表达式捕获组操作解析网页标题。<code>fetch_page_title</code>是一个被<code>async</code>关键字修饰的异步函数，调用该函数会获得协程对象，如代码第35行所示。后面的代码跟之前的例子没有什么区别，相信大家能够理解。</p><p>大家可以尝试将<code>aiohttp</code>换回到<code>requests</code>，看看不使用异步 I/O 也不使用多线程，到底和上面的代码有什么区别，相信通过这样的对比，大家能够更深刻的理解我们之前强调的几个概念：同步和异步，阻塞和非阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第37课：并发编程在爬虫中的应用</title>
      <link href="/blog/2tebbyrg.html"/>
      <url>/blog/2tebbyrg.html</url>
      
        <content type="html"><![CDATA[<h2 id="第37课：并发编程在爬虫中的应用"><a href="#第37课：并发编程在爬虫中的应用" class="headerlink" title="第37课：并发编程在爬虫中的应用"></a>第37课：并发编程在爬虫中的应用</h2><p>之前的课程，我们已经为大家介绍了 Python 中的多线程、多进程和异步编程，通过这三种手段，我们可以实现并发或并行编程，这一方面可以加速代码的执行，另一方面也可以带来更好的用户体验。爬虫程序是典型的 I/O 密集型任务，对于 I/O 密集型任务来说，多线程和异步 I/O 都是很好的选择，因为当程序的某个部分因 I/O 操作阻塞时，程序的其他部分仍然可以运转，这样我们不用在等待和阻塞中浪费大量的时间。下面我们以爬取“<a href="https://image.so.com/">360图片</a>”网站的图片并保存到本地为例，为大家分别展示使用单线程、多线程和异步 I/O 编程的爬虫程序有什么区别，同时也对它们的执行效率进行简单的对比。</p><p>“360图片”网站的页面使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX">Ajax</a> 技术，这是很多网站都会使用的一种异步加载数据和局部刷新页面的技术。简单的说，页面上的图片都是通过 JavaScript 代码异步获取 JSON 数据并动态渲染生成的，而且整个页面还使用了瀑布式加载（一边向下滚动，一边加载更多的图片）。我们在浏览器的“开发者工具”中可以找到提供动态内容的数据接口，如下图所示，我们需要的图片信息就在服务器返回的 JSON 数据中。</p><img src="https://github.com/jackfrued/mypic/raw/master/20211205221352.png" style="zoom:50%;"><p>例如，要获取“美女”频道的图片，我们可以请求如下所示的URL，其中参数<code>ch</code>表示请求的频道，<code>=</code>后面的参数值<code>beauty</code>就代表了“美女”频道，参数<code>sn</code>相当于是页码，<code>0</code>表示第一页（共<code>30</code>张图片），<code>30</code>表示第二页，<code>60</code>表示第三页，以此类推。</p><pre class="line-numbers language-none"><code class="language-none">https://image.so.com/zjl?ch=beauty&amp;sn=0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="单线程版本"><a href="#单线程版本" class="headerlink" title="单线程版本"></a>单线程版本</h3><p>通过上面的 URL 下载“美女”频道共<code>90</code>张图片。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""example04.py - 单线程版本爬虫"""import osimport requestsdef download_picture(url):    filename = url[url.rfind('/') + 1:]    resp = requests.get(url)    if resp.status_code == 200:        with open(f'images/beauty/{filename}', 'wb') as file:            file.write(resp.content)def main():    if not os.path.exists('images/beauty'):        os.makedirs('images/beauty')    for page in range(3):        resp = requests.get(f'https://image.so.com/zjl?ch=beauty&amp;sn={page * 30}')        if resp.status_code == 200:            pic_dict_list = resp.json()['list']            for pic_dict in pic_dict_list:                download_picture(pic_dict['qhimg_url'])if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 macOS 或 Linux 系统上，我们可以使用<code>time</code>命令来了解上面代码的执行时间以及 CPU 的利用率，如下所示。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">time python3 example04.py <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面是单线程爬虫代码在我的电脑上执行的结果。</p><pre class="line-numbers language-none"><code class="language-none">python3 example04.py  2.36s user 0.39s system 12% cpu 21.578 total<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里我们只需要关注代码的总耗时为<code>21.578</code>秒，CPU 利用率为<code>12%</code>。</p><h3 id="多线程版本"><a href="#多线程版本" class="headerlink" title="多线程版本"></a>多线程版本</h3><p>我们使用之前讲到过的线程池技术，将上面的代码修改为多线程版本。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""example05.py - 多线程版本爬虫"""import osfrom concurrent.futures import ThreadPoolExecutorimport requestsdef download_picture(url):    filename = url[url.rfind('/') + 1:]    resp = requests.get(url)    if resp.status_code == 200:        with open(f'images/beauty/{filename}', 'wb') as file:            file.write(resp.content)def main():    if not os.path.exists('images/beauty'):        os.makedirs('images/beauty')    with ThreadPoolExecutor(max_workers=16) as pool:        for page in range(3):            resp = requests.get(f'https://image.so.com/zjl?ch=beauty&amp;sn={page * 30}')            if resp.status_code == 200:                pic_dict_list = resp.json()['list']                for pic_dict in pic_dict_list:                    pool.submit(download_picture, pic_dict['qhimg_url'])if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行如下所示的命令。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">time python3 example05.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码的执行结果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">python3 example05.py  2.65s user 0.40s system 95% cpu 3.193 total<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="异步I-x2F-O版本"><a href="#异步I-x2F-O版本" class="headerlink" title="异步I/O版本"></a>异步I/O版本</h3><p>我们使用<code>aiohttp</code>将上面的代码修改为异步 I/O 的版本。为了以异步 I/O 的方式实现网络资源的获取和写文件操作，我们首先得安装三方库<code>aiohttp</code>和<code>aiofile</code>，命令如下所示。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install aiohttp aiofile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>aiohttp</code> 的用法在之前的课程中已经做过简要介绍，<code>aiofile</code>模块中的<code>async_open</code>函数跟 Python 内置函数<code>open</code>的用法大致相同，只不过它支持异步操作。下面是异步 I/O 版本的爬虫代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""example06.py - 异步I/O版本爬虫"""import asyncioimport jsonimport osimport aiofileimport aiohttpasync def download_picture(session, url):    filename = url[url.rfind('/') + 1:]    async with session.get(url, ssl=False) as resp:        if resp.status == 200:            data = await resp.read()            async with aiofile.async_open(f'images/beauty/{filename}', 'wb') as file:                await file.write(data)async def fetch_json():    async with aiohttp.ClientSession() as session:        for page in range(3):            async with session.get(                url=f'https://image.so.com/zjl?ch=beauty&amp;sn={page * 30}',                ssl=False            ) as resp:                if resp.status == 200:                    json_str = await resp.text()                    result = json.loads(json_str)                    for pic_dict in result['list']:                        await download_picture(session, pic_dict['qhimg_url'])def main():    if not os.path.exists('images/beauty'):        os.makedirs('images/beauty')    loop = asyncio.get_event_loop()    loop.run_until_complete(fetch_json())    loop.close()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行如下所示的命令。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">time python3 example06.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码的执行结果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">python3 example06.py  0.82s user 0.21s system 27% cpu 3.782 total<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面三段代码执行结果的比较，我们可以得出一个结论，使用多线程和异步 I/O 都可以改善爬虫程序的性能，因为我们不用将时间浪费在因 I/O 操作造成的等待和阻塞上，而<code>time</code>命令的执行结果也告诉我们，单线程的代码 CPU 利用率仅仅只有<code>12%</code>，而多线程版本的 CPU 利用率则高达<code>95%</code>；单线程版本的爬虫执行时间约<code>21</code>秒，而多线程和异步 I/O 的版本仅执行了<code>3</code>秒钟。另外，在运行时间差别不大的情况下，多线程的代码比异步 I/O 的代码耗费了更多的 CPU 资源，这是因为多线程的调度和切换也需要花费 CPU 时间。至此，三种方式在 I/O 密集型任务上的优劣已经一目了然，当然这只是在我的电脑上跑出来的结果。如果网络状况不是很理想或者目标网站响应很慢，那么使用多线程和异步 I/O 的优势将更为明显，有兴趣的读者可以自行试验。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第38课：抓取网页动态内容</title>
      <link href="/blog/qwiu2tin.html"/>
      <url>/blog/qwiu2tin.html</url>
      
        <content type="html"><![CDATA[<h2 id="第38课：抓取网页动态内容"><a href="#第38课：抓取网页动态内容" class="headerlink" title="第38课：抓取网页动态内容"></a>第38课：抓取网页动态内容</h2><p>根据权威机构发布的全球互联网可访问性审计报告，全球约有四分之三的网站其内容或部分内容是通过JavaScript动态生成的，这就意味着在浏览器窗口中“查看网页源代码”时无法在HTML代码中找到这些内容，也就是说我们之前用的抓取数据的方式无法正常运转了。解决这样的问题基本上有两种方案，一是获取提供动态内容的数据接口，这种方式也适用于抓取手机 App 的数据；另一种是通过自动化测试工具 Selenium 运行浏览器获取渲染后的动态内容。对于第一种方案，我们可以使用浏览器的“开发者工具”或者更为专业的抓包工具（如：Charles、Fiddler、Wireshark等）来获取到数据接口，后续的操作跟上一个章节中讲解的获取“360图片”网站的数据是一样的，这里我们不再进行赘述。这一章我们重点讲解如何使用自动化测试工具 Selenium 来获取网站的动态内容。</p><h3 id="Selenium-介绍"><a href="#Selenium-介绍" class="headerlink" title="Selenium 介绍"></a>Selenium 介绍</h3><p>Selenium 是一个自动化测试工具，利用它可以驱动浏览器执行特定的行为，最终帮助爬虫开发者获取到网页的动态内容。简单的说，只要我们在浏览器窗口中能够看到的内容，都可以使用 Selenium 获取到，对于那些使用了 JavaScript 动态渲染技术的网站，Selenium 会是一个重要的选择。下面，我们还是以 Chrome 浏览器为例，来讲解 Selenium 的用法，大家需要先安装 Chrome 浏览器并下载它的驱动。Chrome 浏览器的驱动程序可以在<a href="https://chromedriver.chromium.org/downloads">ChromeDriver官网</a>进行下载，驱动的版本要跟浏览器的版本对应，如果没有完全对应的版本，就选择版本代号最为接近的版本。</p><img src="https://github.com/jackfrued/mypic/raw/master/20220310134558.png" style="zoom: 35%"><h3 id="使用Selenium"><a href="#使用Selenium" class="headerlink" title="使用Selenium"></a>使用Selenium</h3><p>我们可以先通过<code>pip</code>来安装 Selenium，命令如下所示。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">pip install selenium<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="加载页面"><a href="#加载页面" class="headerlink" title="加载页面"></a>加载页面</h4><p>接下来，我们通过下面的代码驱动 Chrome 浏览器打开百度。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from selenium import webdriver# 创建Chrome浏览器对象browser = webdriver.Chrome()# 加载指定的页面browser.get('https://www.baidu.com/')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不愿意使用 Chrome 浏览器，也可以修改上面的代码操控其他浏览器，只需创建对应的浏览器对象（如 Firefox、Safari 等）即可。运行上面的程序，如果看到如下所示的错误提示，那是说明我们还没有将 Chrome 浏览器的驱动添加到 PATH 环境变量中，也没有在程序中指定 Chrome 浏览器驱动所在的位置。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决这个问题的办法有三种：</p><ol><li><p>将下载的 ChromeDriver 放到已有的 PATH 环境变量下，建议直接跟 Python 解释器放在同一个目录，因为之前安装 Python 的时候我们已经将 Python 解释器的路径放到 PATH 环境变量中了。</p></li><li><p>将 ChromeDriver 放到项目虚拟环境下的 <code>bin</code> 文件夹中（Windows 系统对应的目录是 <code>Scripts</code>），这样 ChromeDriver 就跟虚拟环境下的 Python 解释器在同一个位置，肯定是能够找到的。</p></li><li><p>修改上面的代码，在创建 Chrome 对象时，通过<code>service</code>参数配置<code>Service</code>对象，并通过创建<code>Service</code>对象的<code>executable_path</code>参数指定 ChromeDriver 所在的位置，如下所示：</p> <pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from selenium import webdriverfrom selenium.webdriver.chrome.service import Servicebrowser = webdriver.Chrome(service=Service(executable_path='venv/bin/chromedriver'))browser.get('https://www.baidu.com/')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="查找元素和模拟用户行为"><a href="#查找元素和模拟用户行为" class="headerlink" title="查找元素和模拟用户行为"></a>查找元素和模拟用户行为</h4><p>接下来，我们可以尝试模拟用户在百度首页的文本框输入搜索关键字并点击“百度一下”按钮。在完成页面加载后，可以通过<code>Chrome</code>对象的<code>find_element</code>和<code>find_elements</code>方法来获取页面元素，Selenium 支持多种获取元素的方式，包括：CSS 选择器、XPath、元素名字（标签名）、元素 ID、类名等，前者可以获取单个页面元素（<code>WebElement</code>对象），后者可以获取多个页面元素构成的列表。获取到<code>WebElement</code>对象以后，可以通过<code>send_keys</code>来模拟用户输入行为，可以通过<code>click</code>来模拟用户点击操作，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.baidu.com/')# 通过元素ID获取元素kw_input = browser.find_element(By.ID, 'kw')# 模拟用户输入行为kw_input.send_keys('Python')# 通过CSS选择器获取元素su_button = browser.find_element(By.CSS_SELECTOR, '#su')# 模拟用户点击行为su_button.click()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要执行一个系列动作，例如模拟拖拽操作，可以创建<code>ActionChains</code>对象，有兴趣的读者可以自行研究。</p><h4 id="隐式等待和显式等待"><a href="#隐式等待和显式等待" class="headerlink" title="隐式等待和显式等待"></a>隐式等待和显式等待</h4><p>这里还有一个细节需要大家知道，网页上的元素可能是动态生成的，在我们使用<code>find_element</code>或<code>find_elements</code>方法获取的时候，可能还没有完成渲染，这时会引发<code>NoSuchElementException</code>错误。为了解决这个问题，我们可以使用隐式等待的方式，通过设置等待时间让浏览器完成对页面元素的渲染。除此之外，我们还可以使用显示等待，通过创建<code>WebDriverWait</code>对象，并设置等待时间和条件，当条件没有满足时，我们可以先等待再尝试进行后续的操作，具体的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditionsfrom selenium.webdriver.support.wait import WebDriverWaitbrowser = webdriver.Chrome()# 设置浏览器窗口大小browser.set_window_size(1200, 800)browser.get('https://www.baidu.com/')# 设置隐式等待时间为10秒browser.implicitly_wait(10)kw_input = browser.find_element(By.ID, 'kw')kw_input.send_keys('Python')su_button = browser.find_element(By.CSS_SELECTOR, '#su')su_button.click()# 创建显示等待对象wait_obj = WebDriverWait(browser, 10)# 设置等待条件（等搜索结果的div出现）wait_obj.until(    expected_conditions.presence_of_element_located(        (By.CSS_SELECTOR, '#content_left')    ))# 截屏browser.get_screenshot_as_file('python_result.png')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面设置的等待条件<code>presence_of_element_located</code>表示等待指定元素出现，下面的表格列出了常用的等待条件及其含义。</p><table><thead><tr><th>等待条件</th><th>具体含义</th></tr></thead><tbody><tr><td><code>title_is / title_contains</code></td><td>标题是指定的内容 / 标题包含指定的内容</td></tr><tr><td><code>visibility_of</code></td><td>元素可见</td></tr><tr><td><code>presence_of_element_located</code></td><td>定位的元素加载完成</td></tr><tr><td><code>visibility_of_element_located</code></td><td>定位的元素变得可见</td></tr><tr><td><code>invisibility_of_element_located</code></td><td>定位的元素变得不可见</td></tr><tr><td><code>presence_of_all_elements_located</code></td><td>定位的所有元素加载完成</td></tr><tr><td><code>text_to_be_present_in_element</code></td><td>元素包含指定的内容</td></tr><tr><td><code>text_to_be_present_in_element_value</code></td><td>元素的<code>value</code>属性包含指定的内容</td></tr><tr><td><code>frame_to_be_available_and_switch_to_it</code></td><td>载入并切换到指定的内部窗口</td></tr><tr><td><code>element_to_be_clickable</code></td><td>元素可点击</td></tr><tr><td><code>element_to_be_selected</code></td><td>元素被选中</td></tr><tr><td><code>element_located_to_be_selected</code></td><td>定位的元素被选中</td></tr><tr><td><code>alert_is_present</code></td><td>出现 Alert 弹窗</td></tr></tbody></table><h4 id="执行JavaScript代码"><a href="#执行JavaScript代码" class="headerlink" title="执行JavaScript代码"></a>执行JavaScript代码</h4><p>对于使用瀑布式加载的页面，如果希望在浏览器窗口中加载更多的内容，可以通过浏览器对象的<code>execute_scripts</code>方法执行 JavaScript 代码来实现。对于一些高级的爬取操作，也很有可能会用到类似的操作，如果你的爬虫代码需要 JavaScript 的支持，建议先对 JavaScript 进行适当的了解，尤其是 JavaScript 中的 BOM 和 DOM 操作。我们在上面的代码中截屏之前加入下面的代码，这样就可以利用 JavaScript 将网页滚到最下方。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 执行JavaScript代码browser.execute_script('document.documentElement.scrollTop = document.documentElement.scrollHeight')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Selenium反爬的破解"><a href="#Selenium反爬的破解" class="headerlink" title="Selenium反爬的破解"></a>Selenium反爬的破解</h4><p>有一些网站专门针对 Selenium 设置了反爬措施，因为使用 Selenium 驱动的浏览器，在控制台中可以看到如下所示的<code>webdriver</code>属性值为<code>true</code>，如果要绕过这项检查，可以在加载页面之前，先通过执行 JavaScript 代码将其修改为<code>undefined</code>。</p><img src="https://github.com/jackfrued/mypic/raw/master/20220310154246.png" style="zoom:50%"><p>另一方面，我们还可以将浏览器窗口上的“Chrome正受到自动测试软件的控制”隐藏掉，完整的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 创建Chrome参数对象options = webdriver.ChromeOptions()# 添加试验性参数options.add_experimental_option('excludeSwitches', ['enable-automation'])options.add_experimental_option('useAutomationExtension', False)# 创建Chrome浏览器对象并传入参数browser = webdriver.Chrome(options=options)# 执行Chrome开发者协议命令（在加载页面时执行指定的JavaScript代码）browser.execute_cdp_cmd(    'Page.addScriptToEvaluateOnNewDocument',    {'source': 'Object.defineProperty(navigator, "webdriver", {get: () =&gt; undefined})'})browser.set_window_size(1200, 800)browser.get('https://www.baidu.com/')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="无头浏览器"><a href="#无头浏览器" class="headerlink" title="无头浏览器"></a>无头浏览器</h4><p>很多时候，我们在爬取数据时并不需要看到浏览器窗口，只要有 Chrome 浏览器以及对应的驱动程序，我们的爬虫就能够运转起来。如果不想看到浏览器窗口，我们可以通过下面的方式设置使用无头浏览器。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">options = webdriver.ChromeOptions()options.add_argument('--headless')browser = webdriver.Chrome(options=options)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h3><p>Selenium 相关的知识还有很多，我们在此就不一一赘述了，下面为大家罗列一些浏览器对象和<code>WebElement</code>对象常用的属性和方法。具体的内容大家还可以参考 Selenium <a href="https://selenium-python-zh.readthedocs.io/en/latest/index.html">官方文档的中文翻译</a>。</p><h4 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h4><p>表1. 常用属性</p><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>current_url</code></td><td>当前页面的URL</td></tr><tr><td><code>current_window_handle</code></td><td>当前窗口的句柄（引用）</td></tr><tr><td><code>name</code></td><td>浏览器的名称</td></tr><tr><td><code>orientation</code></td><td>当前设备的方向（横屏、竖屏）</td></tr><tr><td><code>page_source</code></td><td>当前页面的源代码（包括动态内容）</td></tr><tr><td><code>title</code></td><td>当前页面的标题</td></tr><tr><td><code>window_handles</code></td><td>浏览器打开的所有窗口的句柄</td></tr></tbody></table><p>表2. 常用方法</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>back</code> / <code>forward</code></td><td>在浏览历史记录中后退/前进</td></tr><tr><td><code>close</code> / <code>quit</code></td><td>关闭当前浏览器窗口 / 退出浏览器实例</td></tr><tr><td><code>get</code></td><td>加载指定 URL 的页面到浏览器中</td></tr><tr><td><code>maximize_window</code></td><td>将浏览器窗口最大化</td></tr><tr><td><code>refresh</code></td><td>刷新当前页面</td></tr><tr><td><code>set_page_load_timeout</code></td><td>设置页面加载超时时间</td></tr><tr><td><code>set_script_timeout</code></td><td>设置 JavaScript 执行超时时间</td></tr><tr><td><code>implicit_wait</code></td><td>设置等待元素被找到或目标指令完成</td></tr><tr><td><code>get_cookie</code> / <code>get_cookies</code></td><td>获取指定的Cookie / 获取所有Cookie</td></tr><tr><td><code>add_cookie</code></td><td>添加 Cookie 信息</td></tr><tr><td><code>delete_cookie</code> / <code>delete_all_cookies</code></td><td>删除指定的 Cookie / 删除所有 Cookie</td></tr><tr><td><code>find_element</code> / <code>find_elements</code></td><td>查找单个元素 / 查找一系列元素</td></tr></tbody></table><h4 id="WebElement对象"><a href="#WebElement对象" class="headerlink" title="WebElement对象"></a>WebElement对象</h4><p>表1. WebElement常用属性</p><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>location</code></td><td>元素的位置</td></tr><tr><td><code>size</code></td><td>元素的尺寸</td></tr><tr><td><code>text</code></td><td>元素的文本内容</td></tr><tr><td><code>id</code></td><td>元素的 ID</td></tr><tr><td><code>tag_name</code></td><td>元素的标签名</td></tr></tbody></table><p>表2. 常用方法</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>clear</code></td><td>清空文本框或文本域中的内容</td></tr><tr><td><code>click</code></td><td>点击元素</td></tr><tr><td><code>get_attribute</code></td><td>获取元素的属性值</td></tr><tr><td><code>is_displayed</code></td><td>判断元素对于用户是否可见</td></tr><tr><td><code>is_enabled</code></td><td>判断元素是否处于可用状态</td></tr><tr><td><code>is_selected</code></td><td>判断元素（单选框和复选框）是否被选中</td></tr><tr><td><code>send_keys</code></td><td>模拟输入文本</td></tr><tr><td><code>submit</code></td><td>提交表单</td></tr><tr><td><code>value_of_css_property</code></td><td>获取指定的CSS属性值</td></tr><tr><td><code>find_element</code> / <code>find_elements</code></td><td>获取单个子元素 / 获取一系列子元素</td></tr><tr><td><code>screenshot</code></td><td>为元素生成快照</td></tr></tbody></table><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>下面的例子演示了如何使用 Selenium 从“360图片”网站搜索和下载图片。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import osimport timefrom concurrent.futures import ThreadPoolExecutorimport requestsfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import KeysDOWNLOAD_PATH = 'images/'def download_picture(picture_url: str):    """    下载保存图片    :param picture_url: 图片的URL    """    filename = picture_url[picture_url.rfind('/') + 1:]    resp = requests.get(picture_url)    with open(os.path.join(DOWNLOAD_PATH, filename), 'wb') as file:        file.write(resp.content)if not os.path.exists(DOWNLOAD_PATH):    os.makedirs(DOWNLOAD_PATH)browser = webdriver.Chrome()browser.get('https://image.so.com/z?ch=beauty')browser.implicitly_wait(10)kw_input = browser.find_element(By.CSS_SELECTOR, 'input[name=q]')kw_input.send_keys('苍老师')kw_input.send_keys(Keys.ENTER)for _ in range(10):    browser.execute_script(        'document.documentElement.scrollTop = document.documentElement.scrollHeight'    )    time.sleep(1)imgs = browser.find_elements(By.CSS_SELECTOR, 'div.waterfall img')with ThreadPoolExecutor(max_workers=32) as pool:    for img in imgs:        pic_url = img.get_attribute('src')        pool.submit(download_picture, pic_url)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上面的代码，检查指定的目录下是否下载了根据关键词搜索到的图片。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第39课：爬虫框架Scrapy简介</title>
      <link href="/blog/nbaybo9h.html"/>
      <url>/blog/nbaybo9h.html</url>
      
        <content type="html"><![CDATA[<h2 id="第39课：爬虫框架Scrapy简介"><a href="#第39课：爬虫框架Scrapy简介" class="headerlink" title="第39课：爬虫框架Scrapy简介"></a>第39课：爬虫框架Scrapy简介</h2><p>当你写了很多个爬虫程序之后，你会发现每次写爬虫程序时，都需要将页面获取、页面解析、爬虫调度、异常处理、反爬应对这些代码从头至尾实现一遍，这里面有很多工作其实都是简单乏味的重复劳动。那么，有没有什么办法可以提升我们编写爬虫代码的效率呢？答案是肯定的，那就是利用爬虫框架，而在所有的爬虫框架中，Scrapy 应该是最流行、最强大的框架。</p><h3 id="Scrapy-概述"><a href="#Scrapy-概述" class="headerlink" title="Scrapy 概述"></a>Scrapy 概述</h3><p>Scrapy 是基于 Python 的一个非常流行的网络爬虫框架，可以用来抓取 Web 站点并从页面中提取结构化的数据。下图展示了 Scrapy 的基本架构，其中包含了主要组件和系统的数据处理流程（图中带数字的红色箭头）。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210824003638.png"></p><h4 id="Scrapy的组件"><a href="#Scrapy的组件" class="headerlink" title="Scrapy的组件"></a>Scrapy的组件</h4><p>我们先来说说 Scrapy 中的组件。</p><ol><li>Scrapy 引擎（Engine）：用来控制整个系统的数据处理流程。</li><li>调度器（Scheduler）：调度器从引擎接受请求并排序列入队列，并在引擎发出请求后返还给它们。</li><li>下载器（Downloader）：下载器的主要职责是抓取网页并将网页内容返还给蜘蛛（Spiders）。</li><li>蜘蛛程序（Spiders）：蜘蛛是用户自定义的用来解析网页并抓取特定URL的类，每个蜘蛛都能处理一个域名或一组域名，简单的说就是用来定义特定网站的抓取和解析规则的模块。</li><li>数据管道（Item Pipeline）：管道的主要责任是负责处理有蜘蛛从网页中抽取的数据条目，它的主要任务是清理、验证和存储数据。当页面被蜘蛛解析后，将被发送到数据管道，并经过几个特定的次序处理数据。每个数据管道组件都是一个 Python 类，它们获取了数据条目并执行对数据条目进行处理的方法，同时还需要确定是否需要在数据管道中继续执行下一步或是直接丢弃掉不处理。数据管道通常执行的任务有：清理 HTML 数据、验证解析到的数据（检查条目是否包含必要的字段）、检查是不是重复数据（如果重复就丢弃）、将解析到的数据存储到数据库（关系型数据库或 NoSQL 数据库）中。</li><li>中间件（Middlewares）：中间件是介于引擎和其他组件之间的一个钩子框架，主要是为了提供自定义的代码来拓展 Scrapy 的功能，包括下载器中间件和蜘蛛中间件。</li></ol><h4 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h4><p>Scrapy 的整个数据处理流程由引擎进行控制，通常的运转流程包括以下的步骤：</p><ol><li><p>引擎询问蜘蛛需要处理哪个网站，并让蜘蛛将第一个需要处理的 URL 交给它。</p></li><li><p>引擎让调度器将需要处理的 URL 放在队列中。</p></li><li><p>引擎从调度那获取接下来进行爬取的页面。</p></li><li><p>调度将下一个爬取的 URL 返回给引擎，引擎将它通过下载中间件发送到下载器。</p></li><li><p>当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎；如果下载失败了，引擎会通知调度器记录这个 URL，待会再重新下载。</p></li><li><p>引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。</p></li><li><p>蜘蛛处理响应并返回爬取到的数据条目，此外还要将需要跟进的新的 URL 发送给引擎。</p></li><li><p>引擎将抓取到的数据条目送入数据管道，把新的 URL 发送给调度器放入队列中。</p></li></ol><p>上述操作中的第2步到第8步会一直重复直到调度器中没有需要请求的 URL，爬虫就停止工作。</p><h3 id="安装和使用Scrapy"><a href="#安装和使用Scrapy" class="headerlink" title="安装和使用Scrapy"></a>安装和使用Scrapy</h3><p>可以使用 Python 的包管理工具<code>pip</code>来安装 Scrapy。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">pip install scrapy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在命令行中使用<code>scrapy</code>命令创建名为<code>demo</code>的项目。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">scrapy startproject demo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>项目的目录结构如下图所示。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">demo|____ demo|________ spiders|____________ __init__.py|________ __init__.py|________ items.py|________ middlewares.py|________ pipelines.py|________ settings.py|____ scrapy.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换到<code>demo</code> 目录，用下面的命令创建名为<code>douban</code>的蜘蛛程序。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">scrapy genspider douban movie.douban.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p>接下来，我们实现一个爬取豆瓣电影 Top250 电影标题、评分和金句的爬虫。</p><ol><li><p>在<code>items.py</code>的<code>Item</code>类中定义字段，这些字段用来保存数据，方便后续的操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import scrapyclass DoubanItem(scrapy.Item):    title = scrapy.Field()    score = scrapy.Field()    motto = scrapy.Field()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改<code>spiders</code>文件夹中名为<code>douban.py</code> 的文件，它是蜘蛛程序的核心，需要我们添加解析页面的代码。在这里，我们可以通过对<code>Response</code>对象的解析，获取电影的信息，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import scrapyfrom scrapy import Selector, Requestfrom scrapy.http import HtmlResponsefrom demo.items import MovieItemclass DoubanSpider(scrapy.Spider):    name = 'douban'    allowed_domains = ['movie.douban.com']    start_urls = ['https://movie.douban.com/top250?start=0&amp;filter=']    def parse(self, response: HtmlResponse):        sel = Selector(response)        movie_items = sel.css('#content &gt; div &gt; div.article &gt; ol &gt; li')        for movie_sel in movie_items:            item = MovieItem()            item['title'] = movie_sel.css('.title::text').extract_first()            item['score'] = movie_sel.css('.rating_num::text').extract_first()            item['motto'] = movie_sel.css('.inq::text').extract_first()            yield item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码不难看出，我们可以使用 CSS 选择器进行页面解析。当然，如果你愿意也可以使用 XPath 或正则表达式进行页面解析，对应的方法分别是<code>xpath</code>和<code>re</code>。</p><p>如果还要生成后续爬取的请求，我们可以用<code>yield</code>产出<code>Request</code>对象。<code>Request</code>对象有两个非常重要的属性，一个是<code>url</code>，它代表了要请求的地址；一个是<code>callback</code>，它代表了获得响应之后要执行的回调函数。我们可以将上面的代码稍作修改。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import scrapyfrom scrapy import Selector, Requestfrom scrapy.http import HtmlResponsefrom demo.items import MovieItemclass DoubanSpider(scrapy.Spider):    name = 'douban'    allowed_domains = ['movie.douban.com']    start_urls = ['https://movie.douban.com/top250?start=0&amp;filter=']    def parse(self, response: HtmlResponse):        sel = Selector(response)        movie_items = sel.css('#content &gt; div &gt; div.article &gt; ol &gt; li')        for movie_sel in movie_items:            item = MovieItem()            item['title'] = movie_sel.css('.title::text').extract_first()            item['score'] = movie_sel.css('.rating_num::text').extract_first()            item['motto'] = movie_sel.css('.inq::text').extract_first()            yield item        hrefs = sel.css('#content &gt; div &gt; div.article &gt; div.paginator &gt; a::attr("href")')        for href in hrefs:            full_url = response.urljoin(href.extract())            yield Request(url=full_url)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，我们已经可以通过下面的命令让爬虫运转起来。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">scrapy crawl movie<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在控制台看到爬取到的数据，如果想将这些数据保存到文件中，可以通过<code>-o</code>参数来指定文件名，Scrapy 支持我们将爬取到的数据导出成 JSON、CSV、XML 等格式。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">scrapy crawl moive -o result.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不知大家是否注意到，通过运行爬虫获得的 JSON 文件中有<code>275</code>条数据，那是因为首页被重复爬取了。要解决这个问题，可以对上面的代码稍作调整，不在<code>parse</code>方法中解析获取新页面的 URL，而是通过<code>start_requests</code>方法提前准备好待爬取页面的 URL，调整后的代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import scrapyfrom scrapy import Selector, Requestfrom scrapy.http import HtmlResponsefrom demo.items import MovieItemclass DoubanSpider(scrapy.Spider):    name = 'douban'    allowed_domains = ['movie.douban.com']    def start_requests(self):        for page in range(10):            yield Request(url=f'https://movie.douban.com/top250?start={page * 25}')    def parse(self, response: HtmlResponse):        sel = Selector(response)        movie_items = sel.css('#content &gt; div &gt; div.article &gt; ol &gt; li')        for movie_sel in movie_items:            item = MovieItem()            item['title'] = movie_sel.css('.title::text').extract_first()            item['score'] = movie_sel.css('.rating_num::text').extract_first()            item['motto'] = movie_sel.css('.inq::text').extract_first()            yield item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果希望完成爬虫数据的持久化，可以在数据管道中处理蜘蛛程序产生的<code>Item</code>对象。例如，我们可以通过前面讲到的<code>openpyxl</code>操作 Excel 文件，将数据写入 Excel 文件中，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import openpyxlfrom demo.items import MovieItemclass MovieItemPipeline:    def __init__(self):        self.wb = openpyxl.Workbook()        self.sheet = self.wb.active        self.sheet.title = 'Top250'        self.sheet.append(('名称', '评分', '名言'))    def process_item(self, item: MovieItem, spider):        self.sheet.append((item['title'], item['score'], item['motto']))        return item    def close_spider(self, spider):        self.wb.save('豆瓣电影数据.xlsx')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>process_item</code>和<code>close_spider</code>都是回调方法（钩子函数）， 简单的说就是 Scrapy 框架会自动去调用的方法。当蜘蛛程序产生一个<code>Item</code>对象交给引擎时，引擎会将该<code>Item</code>对象交给数据管道，这时我们配置好的数据管道的<code>parse_item</code>方法就会被执行，所以我们可以在该方法中获取数据并完成数据的持久化操作。另一个方法<code>close_spider</code>是在爬虫结束运行前会自动执行的方法，在上面的代码中，我们在这个地方进行了保存 Excel 文件的操作，相信这段代码大家是很容易读懂的。</p><p>总而言之，数据管道可以帮助我们完成以下操作：</p><ul><li>清理 HTML 数据，验证爬取的数据。</li><li>丢弃重复的不必要的内容。</li><li>将爬取的结果进行持久化操作。</li></ul></li><li><p>修改<code>settings.py</code>文件对项目进行配置，主要需要修改以下几个配置。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 用户浏览器USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'# 并发请求数量 CONCURRENT_REQUESTS = 4# 下载延迟DOWNLOAD_DELAY = 3# 随机化下载延迟RANDOMIZE_DOWNLOAD_DELAY = True# 是否遵守爬虫协议ROBOTSTXT_OBEY = True# 配置数据管道ITEM_PIPELINES = {   'demo.pipelines.MovieItemPipeline': 300,}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面配置文件中的<code>ITEM_PIPELINES</code>选项是一个字典，可以配置多个处理数据的管道，后面的数字代表了执行的优先级，数字小的先执行。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第40课：关系型数据库和MySQL概述</title>
      <link href="/blog/f0ztf7td.html"/>
      <url>/blog/f0ztf7td.html</url>
      
        <content type="html"><![CDATA[<h2 id="第40课：关系型数据库和MySQL概述"><a href="#第40课：关系型数据库和MySQL概述" class="headerlink" title="第40课：关系型数据库和MySQL概述"></a>第40课：关系型数据库和MySQL概述</h2><h3 id="关系型数据库概述"><a href="#关系型数据库概述" class="headerlink" title="关系型数据库概述"></a>关系型数据库概述</h3><ol><li><p>数据持久化 - 将数据保存到能够长久保存数据的存储介质中，在掉电的情况下数据也不会丢失。</p></li><li><p>数据库发展史 - 网状数据库、层次数据库、关系数据库、NoSQL 数据库、NewSQL 数据库。</p><blockquote><p>1970年，IBM的研究员E.F.Codd在<em>Communication of the ACM</em>上发表了名为<em>A Relational Model of Data for Large Shared Data Banks</em>的论文，提出了<strong>关系模型</strong>的概念，奠定了关系模型的理论基础。后来Codd又陆续发表多篇文章，论述了范式理论和衡量关系系统的12条标准，用数学理论奠定了关系数据库的基础。</p></blockquote></li><li><p>关系数据库特点。</p><ul><li><p>理论基础：<strong>关系代数</strong>（关系运算、集合论、一阶谓词逻辑）。</p></li><li><p>具体表象：用<strong>二维表</strong>（有行和列）组织数据。</p></li><li><p>编程语言：<strong>结构化查询语言</strong>（SQL）。</p></li></ul></li><li><p>ER模型（实体关系模型）和概念模型图。</p><p><strong>ER模型</strong>，全称为<strong>实体关系模型</strong>（Entity-Relationship Model），由美籍华裔计算机科学家陈品山先生提出，是概念数据模型的高层描述方式，如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210826003119.png" width="75%"><ul><li>实体 - 矩形框</li><li>属性 - 椭圆框</li><li>关系 - 菱形框</li><li>重数 - 1:1（一对一） / 1:N（一对多） / M:N（多对多）</li></ul><p>实际项目开发中，我们可以利用数据库建模工具（如：PowerDesigner）来绘制概念数据模型（其本质就是 ER 模型），然后再设置好目标数据库系统，将概念模型转换成物理模型，最终生成创建二维表的 SQL（很多工具都可以根据我们设计的物理模型图以及设定的目标数据库来导出 SQL 或直接生成数据表）。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210826003212.png"></p></li><li><p>关系数据库产品。</p><ul><li><a href="https://www.oracle.com/index.html">Oracle</a> - 目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库，它实现了分布式处理的功能。在 Oracle 最新的 12c 版本中，还引入了多承租方架构，使用该架构可轻松部署和管理数据库云。</li><li><a href="https://www.ibm.com/analytics/us/en/db2/">DB2</a> - IBM 公司开发的、主要运行于 Unix（包括 IBM 自家的 <a href="https://zh.wikipedia.org/wiki/AIX">AIX</a>）、Linux、以及 Windows 服务器版等系统的关系数据库产品。DB2 历史悠久且被认为是最早使用 SQL 的数据库产品，它拥有较为强大的商业智能功能。</li><li><a href="https://www.microsoft.com/en-us/sql-server/">SQL Server</a> - 由 Microsoft 开发和推广的关系型数据库产品，最初适用于中小企业的数据管理，但是近年来它的应用范围有所扩展，部分大企业甚至是跨国公司也开始基于它来构建自己的数据管理系统。</li><li><a href="https://www.mysql.com/">MySQL</a> - MySQL 是开放源代码的，任何人都可以在 GPL（General Public License）的许可下下载并根据个性化的需要对其进行修改。MySQL 因为其速度、可靠性和适应性而备受关注。</li><li><a href="">PostgreSQL</a> - 在 BSD 许可证下发行的开放源代码的关系数据库产品。</li></ul></li></ol><h3 id="MySQL-简介"><a href="#MySQL-简介" class="headerlink" title="MySQL 简介"></a>MySQL 简介</h3><p>MySQL 最早是由瑞典的 MySQL AB 公司开发的一个开放源码的关系数据库管理系统，该公司于2008年被昇阳微系统公司（Sun Microsystems）收购。在2009年，甲骨文公司（Oracle）收购昇阳微系统公司，因此 MySQL 目前也是 Oracle 旗下产品。</p><p>MySQL 在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用于中小型网站开发。随着 MySQL 的不断成熟，它也逐渐被应用于更多大规模网站和应用，比如维基百科、谷歌（Google）、脸书（Facebook）、淘宝网等网站都使用了 MySQL 来提供数据持久化服务。</p><p>甲骨文公司收购后昇阳微系统公司，大幅调涨 MySQL 商业版的售价，且甲骨文公司不再支持另一个自由软件项目 <a href="https://zh.wikipedia.org/wiki/OpenSolaris">OpenSolaris </a> 的发展，因此导致自由软件社区对于 Oracle 是否还会持续支持 MySQL 社区版（MySQL 的各个发行版本中唯一免费的版本）有所担忧，MySQL 的创始人麦克尔·维德纽斯以 MySQL 为基础，创建了 <a href="https://zh.wikipedia.org/wiki/MariaDB">MariaDB</a>（以他女儿的名字命名的数据库）分支。有许多原来使用 MySQL 数据库的公司（例如：维基百科）已经陆续完成了从 MySQL 数据库到 MariaDB 数据库的迁移。</p><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><h4 id="Windows-环境"><a href="#Windows-环境" class="headerlink" title="Windows 环境"></a>Windows 环境</h4><ol><li><p>通过<a href="https://www.mysql.com/">官方网站</a>提供的<a href="https://dev.mysql.com/downloads/windows/installer/8.0.html">下载链接</a>下载“MySQL社区版服务器”安装程序，如下图所示，建议大家下载离线安装版的MySQL Installer。</p> <img src="https://github.com/jackfrued/mypic/raw/master/20211105230905.png" style="zoom:50%"></li><li><p>运行 Installer，按照下面的步骤进行安装。</p><ul><li>选择自定义安装。</li></ul> <img src="https://github.com/jackfrued/mypic/raw/master/20211105231152.jpg" style="zoom:35%"><ul><li>选择需要安装的组件。</li></ul> <img src="https://github.com/jackfrued/mypic/raw/master/20211105231255.jpg" style="zoom:35%"><ul><li>如果缺少依赖项，需要先安装依赖项。</li></ul> <img src="https://github.com/jackfrued/mypic/raw/master/20211105231620.png" style="zoom:35%"><ul><li>准备开始安装。</li></ul> <img src="https://github.com/jackfrued/mypic/raw/master/20211105231719.jpg" style="zoom:35%"><ul><li>安装完成。</li></ul> <img src="https://github.com/jackfrued/mypic/raw/master/20211105232024.jpg" style="zoom:35%"><ul><li>准备执行配置向导。</li></ul> <img src="https://github.com/jackfrued/mypic/raw/master/20211105231815.jpg" style="zoom:35%"></li><li><p>执行安装后的配置向导。</p><ul><li>配置服务器类型和网络。</li></ul> <img src="https://github.com/jackfrued/mypic/raw/master/20211105232109.jpg" style="zoom:35%"><ul><li><p>配置认证方法（保护密码的方式）。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105232408.jpg" style="zoom:35%"></li><li><p>配置用户和角色。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105232521.jpg" style="zoom:35%"></li><li><p>配置Windows服务名以及是否开机自启。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105232608.jpg" style="zoom:35%"></li><li><p>配置日志。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105232641.jpg" style="zoom:35%"></li><li><p>配置高级选项。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105232724.jpg" alt="ACAC15B8633133B65476286A49BFBD7E" style="zoom:35%"></li><li><p>应用配置。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105232800.jpg" style="zoom:35%"></li></ul></li><li><p>可以在 Windows 系统的“服务”窗口中启动或停止 MySQL。</p> <img src="https://github.com/jackfrued/mypic/raw/master/20211105232926.jpg" style="zoom:50%"></li><li><p>配置 PATH 环境变量，以便在命令行提示符窗口使用 MySQL 客户端工具。</p><ul><li><p>打开 Windows 的“系统”窗口并点击“高级系统设置”。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105233054.jpg" style="zoom:50%"></li><li><p>在“系统属性”的“高级”窗口，点击“环境变量”按钮。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105233312.jpg" style="zoom:50%"></li><li><p>修改PATH环境变量，将MySQL安装路径下的<code>bin</code>文件夹的路径配置到PATH环境变量中。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105233359.jpg" style="zoom:50%"></li><li><p>配置完成后，可以尝试在“命令提示符”下使用 MySQL 的命令行工具。</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211105233643.jpg" style="zoom:50%"></li></ul></li></ol><h4 id="Linux-环境"><a href="#Linux-环境" class="headerlink" title="Linux 环境"></a>Linux 环境</h4><p>下面以 CentOS 7.x 环境为例，演示如何安装 MySQL 5.7.x，如果需要在其他 Linux 系统下安装其他版本的 MySQL，请读者自行在网络上查找对应的安装教程。</p><ol><li><p>安装 MySQL。</p><p>可以在 <a href="https://www.mysql.com/">MySQL 官方网站</a>下载安装文件。首先在下载页面中选择平台和版本，然后找到对应的下载链接，直接下载包含所有安装文件的归档文件，解归档之后通过包管理工具进行安装。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果系统上有 MariaDB 相关的文件，需要先移除 MariaDB 相关的文件。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">yum list installed | grep mariadb | awk '{print $1}' | xargs yum erase -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新和安装可能用到的底层依赖库。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yum updateyum install -y libaio libaio-devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来可以按照如下所示的顺序用 RPM（Redhat Package Manager）工具安装 MySQL。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-compat-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-devel-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用下面的命令查看已经安装的 MySQL 相关的包。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">rpm -qa | grep mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>配置 MySQL。</p><p>MySQL 的配置文件在<code>/etc</code>目录下，名为<code>my.cnf</code>，默认的配置文件内容如下所示。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">cat /etc/my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-INI" data-language="INI"><code class="language-INI"># For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html[mysqld]## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过配置文件，我们可以修改 MySQL 服务使用的端口、字符集、最大连接数、套接字队列大小、最大数据包大小、日志文件的位置、日志过期时间等配置。当然，我们还可以通过修改配置文件来对 MySQL 服务器进行性能调优和安全管控。</p></li><li><p>启动 MySQL 服务。</p><p>可以使用下面的命令来启动 MySQL。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">service mysqld start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 CentOS 7 中，更推荐使用下面的命令来启动 MySQL。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">systemctl start mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动 MySQL 成功后，可以通过下面的命令来检查网络端口使用情况，MySQL 默认使用<code>3306</code>端口。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">netstat -ntlp | grep mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用下面的命令查找是否有名为<code>mysqld</code>的进程。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">pgrep mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用 MySQL 客户端工具连接服务器。</p><p>命令行工具：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>说明：启动客户端时，<code>-u</code>参数用来指定用户名，MySQL 默认的超级管理账号为<code>root</code>；<code>-p</code>表示要输入密码（用户口令）；如果连接的是其他主机而非本机，可以用<code>-h</code>来指定连接主机的主机名或IP地址。</p></blockquote><p>如果是首次安装 MySQL，可以使用下面的命令来找到默认的初始密码。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">cat /var/log/mysqld.log | grep password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会查看 MySQL 的日志带有<code>password</code>的行，在显示的结果中<code>root@localhost:</code>后面的部分就是默认设置的初始密码。</p><p>进入客户端工具后，可以通过下面的指令来修改超级管理员（root）的访问口令为<code>123456</code>。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">set global validate_password_policy=0;set global validate_password_length=6;alter user 'root'@'localhost' identified by '123456';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：MySQL 较新的版本默认不允许使用弱口令作为用户口令，所以上面的代码修改了验证用户口令的策略和口令的长度。事实上我们不应该使用弱口令，因为存在用户口令被暴力破解的风险。近年来，<strong>攻击数据库窃取数据和劫持数据库勒索比特币</strong>的事件屡见不鲜，要避免这些潜在的风险，最为重要的一点是<strong>不要让数据库服务器暴露在公网上</strong>（最好的做法是将数据库置于内网，至少要做到不向公网开放数据库服务器的访问端口），另外要保管好<code>root</code>账号的口令，应用系统需要访问数据库时，通常不使用<code>root</code>账号进行访问，而是<strong>创建其他拥有适当权限的账号来访问</strong>。</p></blockquote><p>再次使用客户端工具连接 MySQL 服务器时，就可以使用新设置的口令了。在实际开发中，为了方便用户操作，可以选择图形化的客户端工具来连接 MySQL 服务器，包括：</p><ul><li><p>MySQL Workbench（官方工具）</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20211106063939.png" style="zoom:50%"></li><li><p>Navicat for MySQL（界面简单友好）</p>  <img src="https://github.com/jackfrued/mypic/raw/master/20210521152457.png" style="zoom:50%;"></li></ul></li></ol><h4 id="macOS环境"><a href="#macOS环境" class="headerlink" title="macOS环境"></a>macOS环境</h4><p>macOS 系统安装 MySQL 是比较简单的，只需要从刚才说到的官方网站下载 DMG 安装文件并运行就可以了，下载的时候需要根据自己使用的是 Intel 的芯片还是苹果的 M1 芯片选择下载链接，如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20211121215901.png" style="zoom:50%;"><p>安装成功后，可以在“系统偏好设置”中找到“MySQL”，在如下所示的画面中，可以启动和停止 MySQL 服务器，也可以对 MySQL 核心文件的路径进行配置。</p><img src="https://github.com/jackfrued/mypic/raw/master/20211121215153.png" style="zoom:40%;"><h3 id="MySQL-基本命令"><a href="#MySQL-基本命令" class="headerlink" title="MySQL 基本命令"></a>MySQL 基本命令</h3><h4 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h4><ol><li>查看所有数据库</li></ol><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show databases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>查看所有字符集</li></ol><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show character set;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>查看所有的排序规则</li></ol><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show collation;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>查看所有的引擎</li></ol><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show engines;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>查看所有日志文件</li></ol><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show binary logs;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>查看数据库下所有表</li></ol><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show tables;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h4><p>在 MySQL 命令行工具中，可以使用<code>help</code>命令或<code>?</code>来获取帮助，如下所示。</p><ol><li><p>查看<code>show</code>命令的帮助。</p> <pre class="line-numbers language-MySQL" data-language="MySQL"><code class="language-MySQL">? show<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看有哪些帮助内容。</p> <pre class="line-numbers language-MySQL" data-language="MySQL"><code class="language-MySQL">? contents<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取函数的帮助。</p> <pre class="line-numbers language-MySQL" data-language="MySQL"><code class="language-MySQL">? functions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取数据类型的帮助。</p> <pre class="line-numbers language-MySQL" data-language="MySQL"><code class="language-MySQL">? data types<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><ol><li><p>新建/重建服务器连接 - <code>connect</code> / <code>resetconnection</code>。</p></li><li><p>清空当前输入 - <code>\c</code>。在输入错误时，可以及时使用<code>\c</code>清空当前输入并重新开始。</p></li><li><p>修改终止符（定界符）- <code>delimiter</code>。默认的终止符是<code>;</code>，可以使用该命令修改成其他的字符，例如修改为<code>$</code>符号，可以用<code>delimiter $</code>命令。</p></li><li><p>打开系统默认编辑器 - <code>edit</code>。编辑完成保存关闭之后，命令行会自动执行编辑的内容。</p></li><li><p>查看服务器状态 - <code>status</code>。</p></li><li><p>修改默认提示符 - <code>prompt</code>。</p></li><li><p>执行系统命令 - <code>system</code>。可以将系统命令跟在<code>system</code>命令的后面执行，<code>system</code>命令也可以缩写为<code>\!</code>。</p></li><li><p>执行 SQL 文件 - <code>source</code>。<code>source</code>命令后面跟 SQL 文件路径。</p></li><li><p>重定向输出 - <code>tee</code> / <code>notee</code>。可以将命令的输出重定向到指定的文件中。</p></li><li><p>切换数据库 - <code>use</code>。</p></li><li><p>显示警告信息 - <code>warnings</code>。</p></li><li><p>退出命令行 - <code>quit</code>或<code>exit</code>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第41课：SQL详解之DDL</title>
      <link href="/blog/nvpu3nb9.html"/>
      <url>/blog/nvpu3nb9.html</url>
      
        <content type="html"><![CDATA[<h2 id="第41课：SQL详解之DDL"><a href="#第41课：SQL详解之DDL" class="headerlink" title="第41课：SQL详解之DDL"></a>第41课：SQL详解之DDL</h2><p>我们通常可以将 SQL 分为四类，分别是 DDL（数据定义语言）、DML（数据操作语言）、DQL（数据查询语言）和 DCL（数据控制语言）。DDL 主要用于创建、删除、修改数据库中的对象，比如创建、删除和修改二维表，核心的关键字包括<code>create</code>、<code>drop</code>和<code>alter</code>；DML 主要负责数据的插入、删除和更新，关键词包括<code>insert</code>、<code>delete</code>和<code>update</code>；DQL 负责数据查询，最重要的一个关键词是<code>select</code>；DCL 通常用于授予和召回权限，核心关键词是<code>grant</code>和<code>revoke</code>。</p><blockquote><p><strong>说明</strong>：SQL 是不区分大小写的语言，有人会建议将关键字大写，其他部分小写。为了书写和识别方便，下面的 SQL 我都是使用小写字母进行书写的。 如果公司的 SQL 编程规范有强制规定，那么就按照公司的要求来，个人的喜好不应该凌驾于公司的编程规范之上，这一点对职业人来说应该是常识。</p></blockquote><h3 id="建库建表"><a href="#建库建表" class="headerlink" title="建库建表"></a>建库建表</h3><p>下面我们来实现一个非常简单的学校选课系统的数据库。我们将数据库命名为<code>school</code>，四个关键的实体分别是学院、老师、学生和课程，其中，学生跟学院是从属关系，这个关系从数量上来讲是多对一关系，因为一个学院可以有多名学生，而一个学生通常只属于一个学院；同理，老师跟学院的从属关系也是多对一关系。一名老师可以讲授多门课程，一门课程如果只有一个授课老师的话，那么课程跟老师也是多对一关系；如果允许多个老师合作讲授一门课程，那么课程和老师就是多对多关系。简单起见，我们将课程和老师设计为多对一关系。学生和课程是典型的多对多关系，因为一个学生可以选择多门课程，一门课程也可以被多个学生选择，而关系型数据库需要借助中间表才能维持维持两个实体的多对多关系。最终，我们的学校选课系统一共有五张表，分别是学院表（<code>tb_college</code>）、学生表（<code>tb_student</code>）、教师表（<code>tb_teacher</code>）、课程表（<code>tb_course</code>）和选课记录表（<code>tb_record</code>），其中选课记录表就是维持学生跟课程多对多关系的中间表。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 如果存在名为school的数据库就删除它drop database if exists `school`;-- 创建名为school的数据库并设置默认的字符集和排序方式create database `school` default character set utf8mb4 collate utf8mb4_general_ci;-- 切换到school数据库上下文环境use `school`;-- 创建学院表create table `tb_college`(`col_id` int unsigned auto_increment comment '编号',`col_name` varchar(50) not null comment '名称',`col_intro` varchar(500) default '' comment '介绍',primary key (`col_id`)) engine=innodb auto_increment=1 comment '学院表';-- 创建学生表create table `tb_student`(`stu_id` int unsigned not null comment '学号',`stu_name` varchar(20) not null comment '姓名',`stu_sex` boolean default 1 not null comment '性别',`stu_birth` date not null comment '出生日期',`stu_addr` varchar(255) default '' comment '籍贯',`col_id` int unsigned not null comment '所属学院',primary key (`stu_id`),constraint `fk_student_col_id` foreign key (`col_id`) references `tb_college` (`col_id`)) engine=innodb comment '学生表';-- 创建教师表create table `tb_teacher`(`tea_id` int unsigned not null comment '工号',`tea_name` varchar(20) not null comment '姓名',`tea_title` varchar(10) default '助教' comment '职称',`col_id` int unsigned not null comment '所属学院',primary key (`tea_id`),constraint `fk_teacher_col_id` foreign key (`col_id`) references `tb_college` (`col_id`)) engine=innodb comment '老师表';-- 创建课程表create table `tb_course`(`cou_id` int unsigned not null comment '编号',`cou_name` varchar(50) not null comment '名称',`cou_credit` int not null comment '学分',`tea_id` int unsigned not null comment '授课老师',primary key (`cou_id`),constraint `fk_course_tea_id` foreign key (`tea_id`) references `tb_teacher` (`tea_id`)) engine=innodb comment '课程表';-- 创建选课记录表create table `tb_record`(`rec_id` bigint unsigned auto_increment comment '选课记录号',`stu_id` int unsigned not null comment '学号',`cou_id` int unsigned not null comment '课程编号',`sel_date` date not null comment '选课日期',`score` decimal(4,1) comment '考试成绩',primary key (`rec_id`),constraint `fk_record_stu_id` foreign key (`stu_id`) references `tb_student` (`stu_id`),constraint `fk_record_cou_id` foreign key (`cou_id`) references `tb_course` (`cou_id`),constraint `uk_record_stu_cou` unique (`stu_id`, `cou_id`)) engine=innodb comment '选课记录表';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的DDL有几个地方需要强调一下：</p><ul><li><p>首先，上面 SQL 中的数据库名、表名、字段名都被反引号（`）包裹起来，反引号并不是必须的，但是却可以解决表名、字段名等跟 SQL 关键字（SQL 中有特殊含义的单词）冲突的问题。</p></li><li><p>创建数据库时，我们通过<code>default character set utf8mb4</code>指定了数据库默认使用的字符集为<code>utf8mb4</code>（最大<code>4</code>字节的<code>utf-8</code>编码），我们推荐使用该字符集，它也是 MySQL 8.x 默认使用的字符集，因为它能够支持国际化编码，还可以存储 Emoji 字符。可以通过下面的命令查看 MySQL 支持的字符集以及默认的排序规则。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show character set;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">+----------+---------------------------------+---------------------+--------+| Charset  | Description                     | Default collation   | Maxlen |+----------+---------------------------------+---------------------+--------+| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 || dec8     | DEC West European               | dec8_swedish_ci     |      1 || cp850    | DOS West European               | cp850_general_ci    |      1 || hp8      | HP West European                | hp8_english_ci      |      1 || koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    |      1 || latin1   | cp1252 West European            | latin1_swedish_ci   |      1 || latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 || swe7     | 7bit Swedish                    | swe7_swedish_ci     |      1 || ascii    | US ASCII                        | ascii_general_ci    |      1 || ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 || sjis     | Shift-JIS Japanese              | sjis_japanese_ci    |      2 || hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   |      1 || tis620   | TIS620 Thai                     | tis620_thai_ci      |      1 || euckr    | EUC-KR Korean                   | euckr_korean_ci     |      2 || koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 || gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 || greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 || cp1250   | Windows Central European        | cp1250_general_ci   |      1 || gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 || latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 || armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 || utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 || ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 || cp866    | DOS Russian                     | cp866_general_ci    |      1 || keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  |      1 || macce    | Mac Central European            | macce_general_ci    |      1 || macroman | Mac West European               | macroman_general_ci |      1 || cp852    | DOS Central European            | cp852_general_ci    |      1 || latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 || utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 || cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 || utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 || utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 || cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 || cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 || utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 || binary   | Binary pseudo charset           | binary              |      1 || geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  |      1 || cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   |      2 || eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 || gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |+----------+---------------------------------+---------------------+--------+41 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要设置 MySQL 服务启动时默认使用的字符集，可以修改MySQL的配置并添加以下内容。</p><pre class="line-numbers language-INI" data-language="INI"><code class="language-INI">[mysqld]character-set-server=utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：如果不清楚如何修改 MySQL 的配置文件就先不要管它。</p></blockquote></li><li><p>创建和删除数据库时，关键字<code>database</code>也可以替换为<code>schema</code>，二者作用相同。</p></li><li><p>建表语句中的<code>not null</code>是非空约束，它限定了字段不能为空；<code>default</code>用于为字段指定默认值，我们称之为默认值约束；<code>primary key</code>是主键约束，它设定了能够唯一确定一条记录的列，也确保了每条记录都是独一无二的，因为主键不允许重复；<code>foreign key</code>是外键约束，它维持了两张表的参照完整性，举个例子，由于学生表中为 col_id 字段添加了外键约束，限定其必须引用（<code>references</code>）学院表中的 col_id，因此学生表中的学院编号必须来自于学院表中的学院编号，不能够随意为该字段赋值。如果需要给主键约束、外键约束等起名字，可以使用<code>constriant</code>关键字并在后面跟上约束的名字。</p></li><li><p>建表语句中的<code>comment</code> 关键字用来给列和表添加注释，增强代码的可读性和可维护性。</p></li><li><p>在创建表的时候，可以自行选择底层的存储引擎。MySQL 支持多种存储引擎，可以通过<code>show engines</code>命令进行查看。MySQL 5.5 以后的版本默认使用的存储引擎是 InnoDB，它是我们推荐大家使用的存储引擎（因为更适合当下互联网应用对高并发、性能以及事务支持等方面的需求），为了 SQL 语句的向下兼容性，我们可以在建表语句结束处右圆括号的后面通过<code>engine=innodb</code>来指定使用 InnoDB 存储引擎。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show engines\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面的 \G 是为了换一种输出方式，在命令行客户端中，如果表的字段很多一行显示不完，就会导致输出的内容看起来非常不舒服，使用 \G 可以将记录的每个列以独占整行的的方式输出，这种输出方式在命令行客户端中看起来会舒服很多。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">*************************** 1. row ***************************      Engine: InnoDB     Support: DEFAULT     Comment: Supports transactions, row-level locking, and foreign keysTransactions: YES          XA: YES  Savepoints: YES*************************** 2. row ***************************      Engine: MRG_MYISAM     Support: YES     Comment: Collection of identical MyISAM tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 3. row ***************************      Engine: MEMORY     Support: YES     Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 4. row ***************************      Engine: BLACKHOLE     Support: YES     Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO          XA: NO  Savepoints: NO*************************** 5. row ***************************      Engine: MyISAM     Support: YES     Comment: MyISAM storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 6. row ***************************      Engine: CSV     Support: YES     Comment: CSV storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 7. row ***************************      Engine: ARCHIVE     Support: YES     Comment: Archive storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 8. row ***************************      Engine: PERFORMANCE_SCHEMA     Support: YES     Comment: Performance SchemaTransactions: NO          XA: NO  Savepoints: NO*************************** 9. row ***************************      Engine: FEDERATED     Support: NO     Comment: Federated MySQL storage engineTransactions: NULL          XA: NULL  Savepoints: NULL9 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的表格对MySQL几种常用的数据引擎进行了简单的对比。</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MRG_MYISAM</th><th>MEMORY</th><th>MyISAM</th></tr></thead><tbody><tr><td>存储限制</td><td>有</td><td>没有</td><td>有</td><td>有</td></tr><tr><td>事务</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td></tr><tr><td>全文检索</td><td>支持（5.6+）</td><td></td><td></td><td>支持</td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>数据缓存</td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中</td><td>低</td></tr><tr><td>存储空间使用</td><td>高</td><td>低</td><td></td><td>低</td></tr><tr><td>批量插入性能</td><td>低</td><td>高</td><td>高</td><td>高</td></tr><tr><td>是否支持外键</td><td>支持</td><td></td><td></td><td></td></tr></tbody></table><p>通过上面的比较我们可以了解到，InnoDB 是唯一能够支持外键、事务以及行锁的存储引擎，所以我们之前说它更适合互联网应用，而且在较新版本的 MySQL 中，它也是默认使用的存储引擎。</p></li><li><p>在定义表结构为每个字段选择数据类型时，如果不清楚哪个数据类型更合适，可以通过 MySQL 的帮助系统来了解每种数据类型的特性、数据的长度和精度等相关信息。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">? data types<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>说明</strong>：在 MySQLWorkbench 中，不能使用<code>?</code>获取帮助，要使用对应的命令<code>help</code>。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">You asked for help about help category: "Data Types"For more information, type 'help &lt;item&gt;', where &lt;item&gt; is one of the followingtopics:   AUTO_INCREMENT   BIGINT   BINARY   BIT   BLOB   BLOB DATA TYPE   BOOLEAN   CHAR   CHAR BYTE   DATE   DATETIME   DEC   DECIMAL   DOUBLE   DOUBLE PRECISION   ENUM   FLOAT   INT   INTEGER   LONGBLOB   LONGTEXT   MEDIUMBLOB   MEDIUMINT   MEDIUMTEXT   SET DATA TYPE   SMALLINT   TEXT   TIME   TIMESTAMP   TINYBLOB   TINYINT   TINYTEXT   VARBINARY   VARCHAR   YEAR DATA TYPE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取 varchar 类型的帮助：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">? varchar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-none"><code class="language-none">Name: 'VARCHAR'Description:[NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATEcollation_name]A variable-length string. M represents the maximum column length incharacters. The range of M is 0 to 65,535. The effective maximum lengthof a VARCHAR is subject to the maximum row size (65,535 bytes, which isshared among all columns) and the character set used. For example, utf8characters can require up to three bytes per character, so a VARCHARcolumn that uses the utf8 character set can be declared to be a maximumof 21,844 characters. Seehttp://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html.MySQL stores VARCHAR values as a 1-byte or 2-byte length prefix plusdata. The length prefix indicates the number of bytes in the value. AVARCHAR column uses one length byte if values require no more than 255bytes, two length bytes if values may require more than 255 bytes.*Note*:MySQL follows the standard SQL specification, and does not removetrailing spaces from VARCHAR values.VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is thestandard SQL way to define that a VARCHAR column should use somepredefined character set. MySQL uses utf8 as this predefined characterset. http://dev.mysql.com/doc/refman/5.7/en/charset-national.html.NVARCHAR is shorthand for NATIONAL VARCHAR.URL: http://dev.mysql.com/doc/refman/5.7/en/string-type-overview.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在数据类型的选择上，保存字符串数据通常都使用 VARCHAR 和 CHAR 两种类型，前者通常称为变长字符串，而后者通常称为定长字符串；对于 InnoDB 存储引擎，行存储格式没有区分固定长度和可变长度列，因此 VARCHAR 类型和 CHAR 类型没有本质区别，后者不一定比前者性能更好。如果要保存的很大字符串，可以使用 TEXT 类型；如果要保存很大的字节串，可以使用 BLOB（二进制大对象）类型。在 MySQL 中，TEXT 和 BLOB又分别包括 TEXT、MEDIUMTEXT、LONGTEXT 和 BLOB、MEDIUMBLOB、LONGBLOB 三种不同的类型，它们主要的区别在于存储数据的最大大小不同。保存浮点数可以用 FLOAT 或 DOUBLE 类型，FLOAT 已经不推荐使用了，而且在 MySQL 后续的版本中可能会被移除掉。而保存定点数应该使用 DECIMAL 类型，它可以指定小数点前后有效数字的位数。如果要保存时间日期，DATETIME 类型优于 TIMESTAMP 类型，因为前者能表示的时间日期范围更大，后者底层其实就是一个整数，记录了指定的日期时间和 1970-01-01 00:00:00 相差多少个毫秒，该类型在 2038-01-19 03:14:07 之后就会溢出。</p><p>对于自增字段 AUTO_INCREMENT，如果使用 MySQL 5.x 版本要注意自增字段的回溯问题，当然这个问题在 MySQL 8.x 中已经得到了很好的解决，当然，MySQL 8.x 还有很多其他的好处，不管是功能还是性能上都有很多的优化和调整，因此强烈推荐大家使用 MySQL 8.x 版本。对于高并发访问数据库的场景，AUTO_INCREMENT 不仅存在性能上的问题，还可能在多机结构上产生重复的 ID 值，在这种场景下，使用分布式 ID 生成算法（SnowFlake、TinyID等）才是最好的选择，有兴趣的读者可以自行研究。</p></li></ul><h3 id="删除表和修改表"><a href="#删除表和修改表" class="headerlink" title="删除表和修改表"></a>删除表和修改表</h3><p>下面以学生表为例，为大家说明如何删除表和修改表。删除表可以使用<code>drop table</code>，代码如下所示。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop table `tb_student`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop table if exists `tb_student`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，如果学生表已经录入了数据而且该数据被其他表引用了，那么就不能删除学生表，否则上面的操作会报错。在下一课中，我们会讲解如何向表中插入数据，到时候大家可以试一试，能否顺利删除学生表。</p><p>如果要修改学生表，可以使用<code>alter table</code>，具体可以分为以下几种情况：</p><p>修改表，添加一个新列，例如给学生表添加一个联系电话的列。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">alter table `tb_student` add column `stu_tel` varchar(20) not null comment '联系电话';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>注意</strong>：如果新增列的时候指定了非空约束（<code>not null</code>），那么学生表不能够有数据，否则原来的数据增加了 stu_tel 列之后是没有数据的，这就违反了非空约束的要求；当然，我们在添加列的时候也可以使用默认值约束来解决这个问题。</p></blockquote><p>修改表，删除指定的列，例如将上面添加的联系电话列删除掉。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">alter table `tb_student` drop column `stu_tel`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改表，修改列的数据类型，例如将学生表的 stu_sex 修改为字符。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">alter table `tb_student` modify column `stu_sex` char(1) not null default 'M' comment '性别';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改表，修改列的命名，例如将学生表的 stu_sex 修改为 stu_gender。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">alter table `tb_student` change column `stu_sex` `stu_gender` boolean default 1 comment '性别';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改表，删除约束条件，例如删除学生表的 col_id 列的外键约束。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">alter table `tb_student` drop foreign key `fk_student_col_id`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改表，添加约束条件，例如给学生表的 col_id 列加上外键约束。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">alter table `tb_student` add foreign key (`col_id`) references `tb_college` (`col_id`);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">alter table `tb_student` add constraint `fk_student_col_id` foreign key (`col_id`) references `tb_college` (`col_id`);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>说明</strong>：在添加外键约束时，还可以通过<code>on update</code>和<code>on delete</code>来指定在被引用的表发生删除和更新操作时，应该进行何种处理，二者的默认值都是<code>restrict</code>，表示如果存在外键约束，则不允许更新和删除被引用的数据。除了<code>restrict</code>之外，这里可能的取值还有<code>cascade</code>（级联操作）和<code>set null</code>（设置为空），有兴趣的读者可以自行研究。</p></blockquote><p>修改表的名字，例如将学生表的名字修改为 tb_stu_info。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">alter table `tb_student` rename to `tb_stu_info`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>提示</strong>：一般情况下，请不要轻易修改数据库或表的名字。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第42课：SQL详解之DML</title>
      <link href="/blog/rmt5mbvd.html"/>
      <url>/blog/rmt5mbvd.html</url>
      
        <content type="html"><![CDATA[<h2 id="第42课：SQL详解之DML"><a href="#第42课：SQL详解之DML" class="headerlink" title="第42课：SQL详解之DML"></a>第42课：SQL详解之DML</h2><p>我们接着上一课中创建的学校选课系统数据库，为大家讲解 DML 的使用。DML 可以帮助将数据插入到二维表（<code>insert</code>操作）、从二维表删除数据（<code>delete</code>操作）以及更新二维表的数据（<code>update</code>操作）。在执行 DML 之前，我们先通过下面的<code>use</code>命令切换到<code>school</code>数据库。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">use `school`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="insert操作"><a href="#insert操作" class="headerlink" title="insert操作"></a>insert操作</h3><p>顾名思义，<code>insert</code>是用来插入行到二维表中的，插入的方式包括：插入完整的行、插入行的一部分、插入多行、插入查询的结果。我们通过如下所示的 SQL 向学院表中添加一个学院。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">insert into `tb_college` values (default, '计算机学院', '学习计算机科学与技术的地方');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，由于学院表的主键是一个自增字段，因此上面的 SQL 中用<code>default</code>表示该列使用默认值，我们也可以使用下面的方式完成同样的操作。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">insert into `tb_college` (`col_name`, `col_intro`) values ('计算机学院', '学习计算机科学与技术的地方');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们推荐大家使用下面这种做法，指定为哪些字段赋值，这样做可以不按照建表时设定的字段顺序赋值，可以按照<code>values</code>前面的元组中给定的字段顺序为字段赋值，但是需要注意，除了允许为<code>null</code>和有默认值的字段外，其他的字段都必须要一一列出并在<code>values</code>后面的元组中为其赋值。如果希望一次性插入多条记录，我们可以在<code>values</code>后面跟上多个元组来实现批量插入，代码如下所示。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">insert into `tb_college`     (`col_name`, `col_intro`) values     ('外国语学院', '学习歪果仁的语言的学院'),    ('经济管理学院', '经世济民，治理国家；管理科学，兴国之道'),    ('体育学院', '发展体育运动，增强人民体质');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在插入数据时，要注意主键是不能重复的，如果插入的数据与表中已有记录主键相同，那么<code>insert</code>操作将会产生 Duplicated Entry 的报错信息。再次提醒大家，如果<code>insert</code>操作省略了某些列，那么这些列要么有默认值，要么允许为<code>null</code>，否则也将产生错误。在业务系统中，为了让<code>insert</code>操作不影响其他操作（主要是后面要讲的<code>select</code>操作）的性能，可以在<code>insert</code>和<code>into</code>之间加一个<code>low_priority</code>来降低<code>insert</code>操作的优先级，这个做法也适用于下面要讲的<code>delete</code>和<code>update</code>操作。</p><p>假如有一张名为<code>tb_temp</code>的表中有<code>a</code>和<code>b</code>两个列，分别保存了学院的名称和学院的介绍，我们也可以通过查询操作获得<code>tb_temp</code>表的数据并插入到学院表中，如下所示，其中的<code>select</code>就是我们之前提到的 DQL，在下一课中会详细讲解。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">insert into `tb_college`    (`col_name`, `col_intro`)select `a`, `b` from `tb_temp`;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="delete-操作"><a href="#delete-操作" class="headerlink" title="delete 操作"></a>delete 操作</h3><p>如果需要从表中删除数据，可以使用<code>delete</code>操作，它可以帮助我们删除指定行或所有行，例如我们要删除编号为<code>1</code>的学院，就可以使用如下所示的 SQL。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">delete from `tb_college` where col_id=1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，上面的<code>delete</code>操作中的<code>where</code>子句是用来指定条件的，只有满足条件的行会被删除。如果我们不小心写出了下面的 SQL，就会删除学院表中所有的记录，这是相当危险的，在实际工作中通常也不会这么做。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">delete from `tb_college`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要说明的是，即便删除了所有的数据，<code>delete</code>操作不会删除表本身，也不会让 AUTO_INCREMENT 字段的值回到初始值。如果需要删除所有的数据而且让 AUTO_INCREMENT 字段回到初始值，可以使用<code>truncate table</code>执行截断表操作，<code>truncate</code>的本质是删除原来的表并重新创建一个表，它的速度其实更快，因为不需要逐行删除数据。但是请大家记住一点，用<code>truncate table</code>删除数据是非常危险的，因为它会删除所有的数据，而且由于原来的表已经被删除了，要想恢复误删除的数据也会变得极为困难。</p><h3 id="update-操作"><a href="#update-操作" class="headerlink" title="update 操作"></a>update 操作</h3><p>如果要修改表中的数据，可以使用<code>update</code>操作，它可以用来删除指定的行或所有的行。例如，我们将学生表中的“杨过”修改为“杨逍”，这里我们假设“杨过”的学号为<code>1001</code>，代码如下所示。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">update `tb_student` set `stu_name`='杨逍' where `stu_id`=1001;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意上面 SQL 中的<code>where</code>子句，我们使用学号作为条件筛选出对应的学生，然后通过前面的赋值操作将其姓名修改为“杨逍”。这里为什么不直接使用姓名作为筛选条件，那是因为学生表中可能有多个名为“杨过”的学生，如果使用 stu_name 作为筛选条件，那么我们的<code>update</code>操作有可能会一次更新多条数据，这显然不是我们想要看到的。还有一个需要注意的地方是<code>update</code>操作中的<code>set</code>关键字，因为 SQL 中的<code>=</code>并不表示赋值，而是判断相等的运算符，只有出现在<code>set</code> 关键字后面的<code>=</code>，才具备赋值的能力。</p><p>如果要同时修改学生的姓名和生日，我们可以对上面的<code>update</code>语句稍作修改，如下所示。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">update `tb_student` set `stu_name`='杨逍', `stu_birth`='1975-12-29' where `stu_id`=1001;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>update</code>语句中也可以使用查询的方式获得数据并以此来更新指定的表数据，有兴趣的读者可以自行研究。在书写<code>update</code>语句时，通常都会有<code>where</code>子句，因为实际工作中几乎不太会用到更新全表的操作，这一点大家一定要注意。</p><h3 id="完整的数据"><a href="#完整的数据" class="headerlink" title="完整的数据"></a>完整的数据</h3><p>下面我们给出完整的向 school 数据库的五张表中插入数据的 SQL。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">use `school`;-- 插入学院数据insert into `tb_college`     (`col_name`, `col_intro`) values     ('计算机学院', '计算机学院1958年设立计算机专业，1981年建立计算机科学系，1998年设立计算机学院，2005年5月，为了进一步整合教学和科研资源，学校决定，计算机学院和软件学院行政班子合并统一运作、实行教学和学生管理独立运行的模式。 学院下设三个系：计算机科学与技术系、物联网工程系、计算金融系；两个研究所：图象图形研究所、网络空间安全研究院（2015年成立）；三个教学实验中心：计算机基础教学实验中心、IBM技术中心和计算机专业实验中心。'),    ('外国语学院', '外国语学院设有7个教学单位，6个文理兼收的本科专业；拥有1个一级学科博士授予点，3个二级学科博士授予点，5个一级学科硕士学位授权点，5个二级学科硕士学位授权点，5个硕士专业授权领域，同时还有2个硕士专业学位（MTI）专业；有教职员工210余人，其中教授、副教授80余人，教师中获得中国国内外名校博士学位和正在职攻读博士学位的教师比例占专任教师的60%以上。'),    ('经济管理学院', '经济学院前身是创办于1905年的经济科；已故经济学家彭迪先、张与九、蒋学模、胡寄窗、陶大镛、胡代光，以及当代学者刘诗白等曾先后在此任教或学习。');-- 插入学生数据insert into `tb_student`     (`stu_id`, `stu_name`, `stu_sex`, `stu_birth`, `stu_addr`, `col_id`) values    (1001, '杨过', 1, '1990-3-4', '湖南长沙', 1),    (1002, '任我行', 1, '1992-2-2', '湖南长沙', 1),    (1033, '王语嫣', 0, '1989-12-3', '四川成都', 1),    (1572, '岳不群', 1, '1993-7-19', '陕西咸阳', 1),    (1378, '纪嫣然', 0, '1995-8-12', '四川绵阳', 1),    (1954, '林平之', 1, '1994-9-20', '福建莆田', 1),    (2035, '东方不败', 1, '1988-6-30', null, 2),    (3011, '林震南', 1, '1985-12-12', '福建莆田', 3),    (3755, '项少龙', 1, '1993-1-25', '四川成都', 3),    (3923, '杨不悔', 0, '1985-4-17', '四川成都', 3);-- 插入老师数据insert into `tb_teacher`     (`tea_id`, `tea_name`, `tea_title`, `col_id`) values     (1122, '张三丰', '教授', 1),    (1133, '宋远桥', '副教授', 1),    (1144, '杨逍', '副教授', 1),    (2255, '范遥', '副教授', 2),    (3366, '韦一笑', default, 3);-- 插入课程数据insert into `tb_course`     (`cou_id`, `cou_name`, `cou_credit`, `tea_id`) values     (1111, 'Python程序设计', 3, 1122),    (2222, 'Web前端开发', 2, 1122),    (3333, '操作系统', 4, 1122),    (4444, '计算机网络', 2, 1133),    (5555, '编译原理', 4, 1144),    (6666, '算法和数据结构', 3, 1144),    (7777, '经贸法语', 3, 2255),    (8888, '成本会计', 2, 3366),    (9999, '审计学', 3, 3366);-- 插入选课数据insert into `tb_record`     (`stu_id`, `cou_id`, `sel_date`, `score`) values     (1001, 1111, '2017-09-01', 95),    (1001, 2222, '2017-09-01', 87.5),    (1001, 3333, '2017-09-01', 100),    (1001, 4444, '2018-09-03', null),    (1001, 6666, '2017-09-02', 100),    (1002, 1111, '2017-09-03', 65),    (1002, 5555, '2017-09-01', 42),    (1033, 1111, '2017-09-03', 92.5),    (1033, 4444, '2017-09-01', 78),    (1033, 5555, '2017-09-01', 82.5),    (1572, 1111, '2017-09-02', 78),    (1378, 1111, '2017-09-05', 82),    (1378, 7777, '2017-09-02', 65.5),    (2035, 7777, '2018-09-03', 88),    (2035, 9999, '2019-09-02', null),    (3755, 1111, '2019-09-02', null),    (3755, 8888, '2019-09-02', null),    (3755, 9999, '2017-09-01', 92);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：上面的<code>insert</code>语句使用了批处理的方式来插入数据，这种做法插入数据的效率比较高。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第43课：SQL详解之DQL</title>
      <link href="/blog/ogap88ja.html"/>
      <url>/blog/ogap88ja.html</url>
      
        <content type="html"><![CDATA[<h2 id="第43课：SQL详解之DQL"><a href="#第43课：SQL详解之DQL" class="headerlink" title="第43课：SQL详解之DQL"></a>第43课：SQL详解之DQL</h2><p>接下来，我们利用之前创建的学校选课系统数据库，为大家讲解 DQL 的应用。无论对于开发人员还是数据分析师，DQL 都是非常重要的，它关系着我们能否从关系数据库中获取我们需要的数据。建议大家把上上一节课中建库建表的 DDL 以及 上一节课中插入数据的 DML 重新执行一次，确保表和数据跟没有问题再执行下面的操作。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">use `school`;-- 01. 查询所有学生的所有信息select *  from tb_student;  select stu_id     , stu_name     , stu_sex     , stu_birth     , stu_addr     , col_id  from tb_student;-- 02. 查询学生的学号、姓名和籍贯(投影和别名)select stu_id as 学号     , stu_name as 姓名     , stu_addr as 籍贯  from tb_student;-- 03. 查询所有课程的名称及学分(投影和别名)select cou_name as 课程名称     , cou_credit as 学分  from tb_course;-- 04. 查询所有女学生的姓名和出生日期(数据筛选)select stu_name     , stu_birth  from tb_student where stu_sex = 0;-- 05. 查询籍贯为“四川成都”的女学生的姓名和出生日期(数据筛选)select stu_name     , stu_birth  from tb_student where stu_sex = 0 and stu_addr = '四川成都';-- 06. 查询籍贯为“四川成都”或者性别是女的学生(数据筛选)select stu_name     , stu_birth  from tb_student where stu_sex = 0 or stu_addr = '四川成都';-- 07. 查询所有80后学生的姓名、性别和出生日期(数据筛选)select stu_name     , stu_sex     , stu_birth  from tb_student where '1980-1-1' &lt;= stu_birth and stu_birth &lt;= '1989-12-31'; select stu_name     , stu_sex     , stu_birth  from tb_student where stu_birth between '1980-1-1' and '1989-12-31';-- MySQL方言select stu_name     , if(stu_sex, '男', '女') as stu_sex     , stu_birth  from tb_student where stu_birth between '1980-1-1' and '1989-12-31';select stu_name     , case stu_sex             when 1 then '男'             else '女'   end as stu_sex     , stu_birth  from tb_student where stu_birth between '1980-1-1' and '1989-12-31';-- 08. 查询学分大于2分的课程名称和学分(数据筛选)select cou_name     , cou_credit  from tb_course where cou_credit &gt; 2;-- 09. 查询学分是奇数的课程的名称和学分(数据筛选)select cou_name     , cou_credit  from tb_course where cou_credit mod 2 &lt;&gt; 0;-- 10. 查询选择选了1111的课程考试成绩在90分以上的学生学号(数据筛选)select stu_id  from tb_record where cou_id = 1111 and score &gt; 90;-- 11. 查询名字叫“杨过”的学生的姓名和性别select stu_name     , stu_sex  from tb_student where stu_name = '杨过';    -- 12. 查询姓“杨”的学生姓名和性别(模糊查询)-- wild card - 通配符 - % - 代表零个或任意多个字符select stu_name     , stu_sex  from tb_student where stu_name like '杨%';-- 13. 查询姓“杨”名字两个字的学生姓名和性别(模糊查询)-- wild card - 通配符 - _ - 精确匹配一个字符select stu_name     , stu_sex  from tb_student where stu_name like '杨_';-- 14. 查询姓“杨”名字三个字的学生姓名和性别(模糊查询)select stu_name     , stu_sex  from tb_student where stu_name like '杨__';-- 15. 查询名字中有“不”字或“嫣”字的学生的姓名(模糊查询)select stu_name  from tb_student where stu_name like '%不%' or stu_name like '%嫣%'; select stu_name  from tb_student where stu_name like '%不%' unionselect stu_name  from tb_student where stu_name like '%嫣%'; update tb_student   set stu_name = '岳不嫣' where stu_id = 1572;select stu_name  from tb_student where stu_name like '%不%' union allselect stu_name  from tb_student where stu_name like '%嫣%';-- 16. 查询姓“杨”或姓“林”名字三个字的学生的姓名(正则表达式模糊查询)-- regular expressionselect stu_name  from tb_student where stu_name regexp '[杨林][\\u4e00-\\u9fa5]{2}';-- 17. 查询没有录入籍贯的学生姓名(空值处理)select stu_name  from tb_student where stu_addr is null or trim(stu_addr) = ''; update tb_student   set stu_addr = ' ' where stu_id = 1572;-- 18. 查询录入了籍贯的学生姓名(空值处理)select stu_name  from tb_student where stu_addr is not null and trim(stu_addr) &lt;&gt; '';-- 19. 查询学生选课的所有日期(去重)select distinct sel_date  from tb_record;-- 20. 查询学生的籍贯(空值处理和去重)select distinct stu_addr  from tb_student where stu_addr is not null and trim(stu_addr) &lt;&gt; '';-- 21. 查询男学生的姓名和生日按年龄从大到小排列(排序)-- ascending / descendingselect stu_name     , stu_birth  from tb_student where stu_sex = 1 order by stu_birth asc;-- 22. 将上面查询中的生日换算成年龄(日期函数、数值函数)-- 获取当前日期：curdate()-- 计算时间差：timestampdiff(unit, date1, date2)select stu_name     , timestampdiff(year, stu_birth, curdate()) as stu_age  from tb_student where stu_sex = 1 order by stu_age desc;-- 聚合函数：max / min / avg / sum / count / std / variance-- 聚合函数会自动忽略掉null-- 23. 查询年龄最大的学生的出生日期(聚合函数)select min(stu_birth)  from tb_student;-- 24. 查询年龄最小的学生的出生日期(聚合函数)select max(stu_birth)  from tb_student;-- 25. 查询编号为1111的课程考试成绩的最高分(聚合函数)select max(score)  from tb_record where cou_id = 1111;-- 26. 查询学号为1001的学生考试成绩的最低分(聚合函数)select min(score)  from tb_record where stu_id = 1001;-- 27. 查询学号为1001的学生考试成绩的平均分和标准差(聚合函数)-- 四舍五入函数：round(num, n)select round(avg(score), 1) as avg_score     , round(std(score), 4) as std_score  from tb_record where stu_id = 1001;-- 28. 查询学号为1001的学生考试成绩的平均分，如果有null值，null值算0分(聚合函数)select sum(score) / count(*)  from tb_record where stu_id = 1001;-- 29. 查询男女学生的人数(分组和聚合函数)select case stu_sex when 1 then '男' else '女' end as stu_sex     , count(*) as total  from tb_student group by stu_sex;-- 30. 查询每个学院学生人数(分组和聚合函数)select col_id     , count(*) as total  from tb_student group by col_id  with rollup;-- 31. 查询每个学院男女学生人数(分组和聚合函数)select col_id     , case stu_sex when 1 then '男' else '女' end as stu_sex     , count(*) as total  from tb_student group by col_id, stu_sex;-- 32. 查询选课学生的学号和平均成绩(分组和聚合函数)select stu_id     , round(avg(score), 1) as avg_score  from tb_record group by stu_id;-- 33. 查询平均成绩大于等于90分的学生的学号和平均成绩(分组和聚合函数)-- 结论：分组前的筛选使用where子句，分组后的筛选使用having子句select stu_id     , round(avg(score), 1) as avg_score  from tb_record group by stu_idhaving avg(score) &gt;= 90;-- 34. 查询所有课程成绩大于80分的同学的学号(分组和聚合函数)select stu_id  from tb_record group by stu_idhaving min(score) &gt; 80;-- Error Code: 1242. Subquery returns more than 1 rowselect stu_id , stu_name  from tb_student where stu_id in (select stu_idfrom tb_record   group by stu_id  having min(score) &gt; 80);-- 35. 查询年龄最大的学生的姓名(嵌套查询)-- 嵌套查询/子查询：把一个查询的结果作为另外一个查询的一部分来使用select @a := min(stu_birth)  from tb_student;  select stu_name  from tb_student where stu_birth = @a; select stu_name  from tb_student where stu_birth = (select min(stu_birth)                      from tb_student);-- 36. 查询选了两门以上的课程的学生姓名(嵌套查询/分组/数据筛选)select stu_name  from tb_student where stu_id in (select stu_id                    from tb_record                   group by stu_id                  having count(*) &gt; 2);-- 37. 查询学生的姓名、生日和所在学院名称(连接查询)select stu_name     , stu_birth     , col_name  from tb_student, tb_college where tb_student.col_id = tb_college.col_id;select stu_name     , stu_birth     , col_name  from tb_student inner join tb_college       on tb_student.col_id = tb_college.col_id;select stu_name     , stu_birth     , col_name  from tb_student natural join tb_college;-- 38. 查询学生姓名、课程名称以及成绩(连接查询)select stu_name     , cou_name     , score  from tb_student, tb_course, tb_record where tb_student.stu_id = tb_record.stu_id       and tb_course.cou_id = tb_record.cou_id       and score is not null;select stu_name     , cou_name     , score  from tb_student    inner join tb_record           on tb_student.stu_id = tb_record.stu_id   inner join tb_course           on tb_course.cou_id = tb_record.cou_id where score is not null; select stu_name     , cou_name     , score  from tb_student        natural join tb_record    natural join tb_course where score is not null; -- 39. 上面的查询结果按课程和成绩排序取前5条数据(分页查询)select stu_name     , cou_name     , score  from tb_student        natural join tb_record    natural join tb_course where score is not null order by cou_id asc, score desc limit 5;-- 40. 上面的查询结果按课程和成绩排序取第6-10条数据(分页查询)select stu_name     , cou_name     , score  from tb_student        natural join tb_record    natural join tb_course where score is not null order by cou_id asc, score desc limit 5offset 5;-- 41. 上面的查询结果按课程和成绩排序取第11-15条数据(分页查询)select stu_name     , cou_name     , score  from tb_student        natural join tb_record    natural join tb_course where score is not null order by cou_id asc, score desc limit 5offset 10;-- 42. 查询选课学生的姓名和平均成绩(嵌套查询和连接查询)select stu_name     , avg_score  from tb_student       natural join (select stu_id  , avg(score) as avg_score   from tb_record  group by stu_id) as tmp;-- 43. 查询学生的姓名和选课的数量(嵌套查询和连接查询)select stu_name     , total  from tb_student       inner join (select stu_id, count(*) as total from tb_recordgroup by stu_id) as tmp       on tb_student.stu_id = tmp.stu_id;-- 44. 查询所有学生的姓名和选课数量(左外连接和嵌套查询)-- 左外连接：把左表（写在join左边的表）所有的数据都拿到，不满足连表条件的地方填充null - left outer join-- 右外连接：把右表（写在join右边的表）所有的数据都拿到，不满足连表条件的地方填充null - right outer join-- 全外连接：把左表和右表的数据全部拿到即便它们不满足连表条件，MySQL不支持全外连接 - full outer joinselect stu_name     , coalesce(total, 0) as total  from tb_student       left join (select stu_id   , count(*) as totalfrom tb_record   group by stu_id) as tmp       on tb_student.stu_id = tmp.stu_id;-- 45. 查询没有选课的学生的姓名(左外连接和数据筛选)select stu_name  from tb_student       left join tb_record       on tb_student.stu_id = tb_record.stu_id where tb_record.stu_id is null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的 DQL 有几个地方需要加以说明：</p><ol><li><p>MySQL目前的版本不支持全外连接，上面我们通过<code>union</code>操作，将左外连接和右外连接的结果求并集实现全外连接的效果。大家可以通过下面的图来加深对连表操作的认识。</p><img src="http://localhost/mypic/20211121135117.png" style="zoom:50%"></li><li><p>MySQL 中支持多种类型的运算符，包括：算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）、比较运算符（<code>=</code>、<code>&lt;&gt;</code>、<code>&lt;=&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>BETWEEN...AND..</code>.、<code>IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>LIKE</code>、<code>RLIKE</code>、<code>REGEXP</code>）、逻辑运算符（<code>NOT</code>、<code>AND</code>、<code>OR</code>、<code>XOR</code>）和位运算符（<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>~</code>、<code>&gt;&gt;</code>、<code>&lt;&lt;</code>），我们可以在 DML 中使用这些运算符处理数据。</p></li><li><p>在查询数据时，可以在<code>SELECT</code>语句及其子句（如<code>WHERE</code>子句、<code>ORDER BY</code>子句、<code>HAVING</code>子句等）中使用函数，这些函数包括字符串函数、数值函数、时间日期函数、流程函数等，如下面的表格所示。</p><p>常用字符串函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>CONCAT</code></td><td>将多个字符串连接成一个字符串</td></tr><tr><td><code>FORMAT</code></td><td>将数值格式化成字符串并指定保留几位小数</td></tr><tr><td><code>FROM_BASE64</code> / <code>TO_BASE64</code></td><td>BASE64解码/编码</td></tr><tr><td><code>BIN</code> / <code>OCT</code> / <code>HEX</code></td><td>将数值转换成二进制/八进制/十六进制字符串</td></tr><tr><td><code>LOCATE</code></td><td>在字符串中查找一个子串的位置</td></tr><tr><td><code>LEFT</code> / <code>RIGHT</code></td><td>返回一个字符串左边/右边指定长度的字符</td></tr><tr><td><code>LENGTH</code> / <code>CHAR_LENGTH</code></td><td>返回字符串的长度以字节/字符为单位</td></tr><tr><td><code>LOWER</code> / <code>UPPER</code></td><td>返回字符串的小写/大写形式</td></tr><tr><td><code>LPAD</code> / <code>RPAD</code></td><td>如果字符串的长度不足，在字符串左边/右边填充指定的字符</td></tr><tr><td><code>LTRIM</code> / <code>RTRIM</code></td><td>去掉字符串前面/后面的空格</td></tr><tr><td><code>ORD</code> / <code>CHAR</code></td><td>返回字符对应的编码/返回编码对应的字符</td></tr><tr><td><code>STRCMP</code></td><td>比较字符串，返回-1、0、1分别表示小于、等于、大于</td></tr><tr><td><code>SUBSTRING</code></td><td>返回字符串指定范围的子串</td></tr></tbody></table><p>常用数值函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>ABS</code></td><td>返回一个数的绝度值</td></tr><tr><td><code>CEILING</code> / <code>FLOOR</code></td><td>返回一个数上取整/下取整的结果</td></tr><tr><td><code>CONV</code></td><td>将一个数从一种进制转换成另一种进制</td></tr><tr><td><code>CRC32</code></td><td>计算循环冗余校验码</td></tr><tr><td><code>EXP</code> / <code>LOG</code> / <code>LOG2</code> / <code>LOG10</code></td><td>计算指数/对数</td></tr><tr><td><code>POW</code></td><td>求幂</td></tr><tr><td><code>RAND</code></td><td>返回[0,1)范围的随机数</td></tr><tr><td><code>ROUND</code></td><td>返回一个数四舍五入后的结果</td></tr><tr><td><code>SQRT</code></td><td>返回一个数的平方根</td></tr><tr><td><code>TRUNCATE</code></td><td>截断一个数到指定的精度</td></tr><tr><td><code>SIN</code> / <code>COS</code> / <code>TAN</code> / <code>COT</code> / <code>ASIN</code> / <code>ACOS</code> / <code>ATAN</code></td><td>三角函数</td></tr></tbody></table><p>常用时间日期函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>CURDATE</code> / <code>CURTIME</code> / <code>NOW</code></td><td>获取当前日期/时间/日期和时间</td></tr><tr><td><code>ADDDATE</code> / <code>SUBDATE</code></td><td>将两个日期表达式相加/相减并返回结果</td></tr><tr><td><code>DATE</code> / <code>TIME</code></td><td>从字符串中获取日期/时间</td></tr><tr><td><code>YEAR</code> / <code>MONTH</code> / <code>DAY</code></td><td>从日期中获取年/月/日</td></tr><tr><td><code>HOUR</code> / <code>MINUTE</code> / <code>SECOND</code></td><td>从时间中获取时/分/秒</td></tr><tr><td><code>DATEDIFF</code> / <code>TIMEDIFF</code></td><td>返回两个时间日期表达式相差多少天/小时</td></tr><tr><td><code>MAKEDATE</code> / <code>MAKETIME</code></td><td>制造一个日期/时间</td></tr></tbody></table><p>常用流程函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>IF</code></td><td>根据条件是否成立返回不同的值</td></tr><tr><td><code>IFNULL</code></td><td>如果为NULL则返回指定的值否则就返回本身</td></tr><tr><td><code>NULLIF</code></td><td>两个表达式相等就返回NULL否则返回第一个表达式的值</td></tr></tbody></table><p>其他常用函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>MD5</code> / <code>SHA1</code> / <code>SHA2</code></td><td>返回字符串对应的哈希摘要</td></tr><tr><td><code>CHARSET</code> / <code>COLLATION</code></td><td>返回字符集/校对规则</td></tr><tr><td><code>USER</code> / <code>CURRENT_USER</code></td><td>返回当前用户</td></tr><tr><td><code>DATABASE</code></td><td>返回当前数据库名</td></tr><tr><td><code>VERSION</code></td><td>返回当前数据库版本</td></tr><tr><td><code>FOUND_ROWS</code> / <code>ROW_COUNT</code></td><td>返回查询到的行数/受影响的行数</td></tr><tr><td><code>LAST_INSERT_ID</code></td><td>返回最后一个自增主键的值</td></tr><tr><td><code>UUID</code> / <code>UUID_SHORT</code></td><td>返回全局唯一标识符</td></tr></tbody></table></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第44课：SQL详解之DCL</title>
      <link href="/blog/smzkqpeg.html"/>
      <url>/blog/smzkqpeg.html</url>
      
        <content type="html"><![CDATA[<h2 id="第44课：SQL详解之DCL"><a href="#第44课：SQL详解之DCL" class="headerlink" title="第44课：SQL详解之DCL"></a>第44课：SQL详解之DCL</h2><p>数据库服务器通常包含了非常重要的数据，可以通过访问控制来确保这些数据的安全，而 DCL 就是解决这一问题的，它可以为指定的用户授予访问权限或者从指定用户处召回指定的权限。DCL 对数据库管理员来说非常重要，因为用户权限的管理关系到数据库的安全。简单的说，我们可以通过 DCL 允许受信任的用户访问数据库，阻止不受信任的用户访问数据库，同时还可以通过 DCL 将每个访问者的的权限最小化（让访问者的权限刚刚够用）。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>我们可以使用下面的 SQL 来创建一个用户并为其指定访问口令。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create user 'wangdachui'@'%' identified by 'Wang.618';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的 SQL 创建了名为 wangdachui 的用户，它的访问口令是 Wang.618，该用户可以从任意主机访问数据库服务器，因为 @ 后面使用了可以表示任意多个字符的通配符 %。如果要限制 wangdachui 这个用户只能从 192.168.0.x 这个网段的主机访问数据库服务器，可以按照下面的方式来修改 SQL 语句。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop user if exists 'wangdachui'@'%';create user 'wangdachui'@'192.168.0.%' identified by 'Wang.618';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时，如果我们使用 wangdachui 这个账号访问数据库服务器，我们几乎不能做任何操作，因为该账号没有任何操作权限。</p><h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><p>我们用下面的语句为 wangdachui 授予查询 school 数据库学院表（<code>tb_college</code>）的权限。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">grant select on `school`.`tb_college` to 'wangdachui'@'192.168.0.%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以让 wangdachui 对 school 数据库的所有对象都具有查询权限，代码如下所示。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">grant select on `school`.* to 'wangdachui'@'192.168.0.%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们希望 wangdachui 还有 insert、delete 和 update 权限，可以使用下面的方式进行操作。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">grant insert, delete, update on `school`.* to 'wangdachui'@'192.168.0.%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们还想授予 wangdachui 执行 DDL 的权限，可以使用如下所示的 SQL。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">grant create, drop, alter on `school`.* to 'wangdachui'@'192.168.0.%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们希望 wangdachui 账号对所有数据库的所有对象都具备所有的操作权限，可以执行如下所示的操作，但是一般情况下，我们不会这样做，因为我们之前说过，权限刚刚够用就行，一个普通的账号不应该拥有这么大的权限。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">grant all privileges on *.* to 'wangdachui'@'192.168.0.%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="召回权限"><a href="#召回权限" class="headerlink" title="召回权限"></a>召回权限</h3><p>如果要召回 wangdachui 对 school 数据库的 insert、delete 和 update 权限，可以使用下面的操作。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">revoke insert, delete, update on `school`.* from 'wangdachui'@'192.168.0.%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要召回所有的权限，可以按照如下所示的方式进行操作。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">revoke all privileges on *.* from 'wangdachui'@'192.168.0.%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要说明的是，由于数据库可能会缓存用户的权限，可以在授予或召回权限后执行下面的语句使新的权限即时生效。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第45课：索引</title>
      <link href="/blog/gghzhgln.html"/>
      <url>/blog/gghzhgln.html</url>
      
        <content type="html"><![CDATA[<h2 id="第45课：索引"><a href="#第45课：索引" class="headerlink" title="第45课：索引"></a>第45课：索引</h2><p>索引是关系型数据库中用来提升查询性能最为重要的手段。关系型数据库中的索引就像一本书的目录，我们可以想象一下，如果要从一本书中找出某个知识点，但是这本书没有目录，这将是意见多么可怕的事情！我们估计得一篇一篇的翻下去，才能确定这个知识点到底在什么位置。创建索引虽然会带来存储空间上的开销，就像一本书的目录会占用一部分篇幅一样，但是在牺牲空间后换来的查询时间的减少也是非常显著的。</p><p>MySQL 数据库中所有数据类型的列都可以被索引。对于MySQL 8.0 版本的 InnoDB 存储引擎来说，它支持三种类型的索引，分别是 B+ 树索引、全文索引和 R 树索引。这里，我们只介绍使用得最为广泛的 B+ 树索引。使用 B+ 树的原因非常简单，因为它是目前在基于磁盘进行海量数据存储和排序上最有效率的数据结构。B+ 树是一棵<a href="https://zh.wikipedia.org/zh-cn/%E5%B9%B3%E8%A1%A1%E6%A0%91">平衡树</a>，树的高度通常为3或4，但是却可以保存从百万级到十亿级的数据，而从这些数据里面查询一条数据，只需要3次或4次 I/O 操作。</p><p>B+ 树由根节点、中间节点和叶子节点构成，其中叶子节点用来保存排序后的数据。由于记录在索引上是排序过的，因此在一个叶子节点内查找数据时可以使用二分查找，这种查找方式效率非常的高。当数据很少的时候，B+ 树只有一个根节点，数据也就保存在根节点上。随着记录越来越多，B+ 树会发生分裂，根节点不再保存数据，而是提供了访问下一层节点的指针，帮助快速确定数据在哪个叶子节点上。</p><p>在创建二维表时，我们通常都会为表指定主键列，主键列上默认会创建索引，而对于 MySQL InnoDB 存储引擎来说，因为它使用的是索引组织表这种数据存储结构，所以主键上的索引就是整张表的数据，而这种索引我们也将其称之为<strong>聚集索引</strong>（clustered index）。很显然，一张表只能有一个聚集索引，否则表的数据岂不是要保存多次。我们自己创建的索引都是二级索引（secondary index），更常见的叫法是<strong>非聚集索引</strong>（non-clustered index）。通过我们自定义的非聚集索引只能定位记录的主键，在获取数据时可能需要再通过主键上的聚集索引进行查询，这种现象称为“回表”，因此通过非聚集索引检索数据通常比使用聚集索引检索数据要慢。</p><p>接下来我们通过一个简单的例子来说明索引的意义，比如我们要根据学生的姓名来查找学生，这个场景在实际开发中应该经常遇到，就跟通过商品名称查找商品是一个道理。我们可以使用 MySQL 的<code>explain</code>关键字来查看 SQL 的执行计划（数据库执行 SQL 语句的具体步骤）。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 11     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的 SQL 执行计划中，有几项值得我们关注：</p><ol><li><code>select_type</code>：查询的类型。<ul><li><code>SIMPLE</code>：简单 SELECT，不需要使用 UNION 操作或子查询。</li><li><code>PRIMARY</code>：如果查询包含子查询，最外层的 SELECT 被标记为 PRIMARY。</li><li><code>UNION</code>：UNION 操作中第二个或后面的 SELECT 语句。</li><li><code>SUBQUERY</code>：子查询中的第一个 SELECT。</li><li><code>DERIVED</code>：派生表的 SELECT 子查询。</li></ul></li><li><code>table</code>：查询对应的表。</li><li><code>type</code>：MySQL 在表中找到满足条件的行的方式，也称为访问类型，包括：<code>ALL</code>（全表扫描）、<code>index</code>（索引全扫描，只遍历索引树）、<code>range</code>（索引范围扫描）、<code>ref</code>（非唯一索引扫描）、<code>eq_ref</code>（唯一索引扫描）、<code>const</code> / <code>system</code>（常量级查询）、<code>NULL</code>（不需要访问表或索引）。在所有的访问类型中，很显然 ALL 是性能最差的，它代表的全表扫描是指要扫描表中的每一行才能找到匹配的行。</li><li><code>possible_keys</code>：MySQL 可以选择的索引，但是<strong>有可能不会使用</strong>。</li><li><code>key</code>：MySQL 真正使用的索引，如果为<code>NULL</code>就表示没有使用索引。</li><li><code>key_len</code>：使用的索引的长度，在不影响查询的情况下肯定是长度越短越好。</li><li><code>rows</code>：执行查询需要扫描的行数，这是一个<strong>预估值</strong>。</li><li><code>extra</code>：关于查询额外的信息。<ul><li><code>Using filesort</code>：MySQL 无法利用索引完成排序操作。</li><li><code>Using index</code>：只使用索引的信息而不需要进一步查表来获取更多的信息。</li><li><code>Using temporary</code>：MySQL 需要使用临时表来存储结果集，常用于分组和排序。</li><li><code>Impossible where</code>：<code>where</code>子句会导致没有符合条件的行。</li><li><code>Distinct</code>：MySQL 发现第一个匹配行后，停止为当前的行组合搜索更多的行。</li><li><code>Using where</code>：查询的列未被索引覆盖，筛选条件并不是索引的前导列。</li></ul></li></ol><p>从上面的执行计划可以看出，当我们通过学生名字查询学生时实际上是进行了全表扫描，不言而喻这个查询性能肯定是非常糟糕的，尤其是在表中的行很多的时候。如果我们需要经常通过学生姓名来查询学生，那么就应该在学生姓名对应的列上创建索引，通过索引来加速查询。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create index idx_student_name on tb_student(stuname);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次查看刚才的 SQL 对应的执行计划。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 62          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以注意到，在对学生姓名创建索引后，刚才的查询已经不是全表扫描而是基于索引的查询，而且扫描的行只有唯一的一行，这显然大大的提升了查询的性能。MySQL 中还允许创建前缀索引，即对索引字段的前N个字符创建索引，这样的话可以减少索引占用的空间（但节省了空间很有可能会浪费时间，<strong>时间和空间是不可调和的矛盾</strong>），如下所示。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create index idx_student_name_1 on tb_student(stuname(1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的索引相当于是根据学生姓名的第一个字来创建的索引，我们再看看 SQL 执行计划。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 5          ref: const         rows: 2     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不知道大家是否注意到，这一次扫描的行变成了2行，因为学生表中有两个姓“林”的学生，我们只用姓名的第一个字作为索引的话，在查询时通过索引就会找到这两行。</p><p>如果要删除索引，可以使用下面的SQL。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">alter table tb_student drop index idx_student_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop index idx_student_name on tb_student;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在创建索引时，我们还可以使用复合索引、函数索引（MySQL 5.7 开始支持），用好复合索引实现<strong>索引覆盖</strong>可以减少不必要的排序和回表操作，这样就会让查询的性能成倍的提升，有兴趣的读者可以自行研究。</p><p>我们简单的为大家总结一下索引的设计原则：</p><ol><li><strong>最适合</strong>索引的列是出现在<strong>WHERE子句</strong>和连接子句中的列。</li><li>索引列的基数越大（取值多、重复值少），索引的效果就越好。</li><li>使用<strong>前缀索引</strong>可以减少索引占用的空间，内存中可以缓存更多的索引。</li><li><strong>索引不是越多越好</strong>，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。</li><li>使用 InnoDB 存储引擎时，表的普通索引都会保存主键的值，所以<strong>主键要尽可能选择较短的数据类型</strong>，这样可以有效的减少索引占用的空间，提升索引的缓存效果。</li></ol><p>最后，还有一点需要说明，InnoDB 使用的 B-tree 索引，数值类型的列除了等值判断时索引会生效之外，使用<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN...AND... </code>、<code>&lt;&gt;</code>时，索引仍然生效；对于字符串类型的列，如果使用不以通配符开头的模糊查询，索引也是起作用的，但是其他的情况会导致索引失效，这就意味着很有可能会做全表查询。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第46课：视图+函数+过程</title>
      <link href="/blog/majutszz.html"/>
      <url>/blog/majutszz.html</url>
      
        <content type="html"><![CDATA[<h2 id="第46课：视图、函数和过程"><a href="#第46课：视图、函数和过程" class="headerlink" title="第46课：视图、函数和过程"></a>第46课：视图、函数和过程</h2><p>为了讲解视图、函数和过程，我们首先用下面的 DDL 和 DML 创建名为 hrs 的数据库并为其二维表添加如下所示的数据。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 创建名为hrs的数据库并指定默认的字符集create database `hrs` default charset utf8mb4;-- 切换到hrs数据库use `hrs`;-- 创建部门表create table `tb_dept`(`dno` int not null comment '编号',`dname` varchar(10) not null comment '名称',`dloc` varchar(20) not null comment '所在地',primary key (`dno`));-- 插入4个部门insert into `tb_dept` values     (10, '会计部', '北京'),    (20, '研发部', '成都'),    (30, '销售部', '重庆'),    (40, '运维部', '深圳');-- 创建员工表create table `tb_emp`(`eno` int not null comment '员工编号',`ename` varchar(20) not null comment '员工姓名',`job` varchar(20) not null comment '员工职位',`mgr` int comment '主管编号',`sal` int not null comment '员工月薪',`comm` int comment '每月补贴',`dno` int not null comment '所在部门编号',primary key (`eno`),constraint `fk_emp_mgr` foreign key (`mgr`) references tb_emp (`eno`),constraint `fk_emp_dno` foreign key (`dno`) references tb_dept (`dno`));-- 插入14个员工insert into `tb_emp` values     (7800, '张三丰', '总裁', null, 9000, 1200, 20),    (2056, '乔峰', '分析师', 7800, 5000, 1500, 20),    (3088, '李莫愁', '设计师', 2056, 3500, 800, 20),    (3211, '张无忌', '程序员', 2056, 3200, null, 20),    (3233, '丘处机', '程序员', 2056, 3400, null, 20),    (3251, '张翠山', '程序员', 2056, 4000, null, 20),    (5566, '宋远桥', '会计师', 7800, 4000, 1000, 10),    (5234, '郭靖', '出纳', 5566, 2000, null, 10),    (3344, '黄蓉', '销售主管', 7800, 3000, 800, 30),    (1359, '胡一刀', '销售员', 3344, 1800, 200, 30),    (4466, '苗人凤', '销售员', 3344, 2500, null, 30),    (3244, '欧阳锋', '程序员', 3088, 3200, null, 20),    (3577, '杨过', '会计', 5566, 2200, null, 10),    (3588, '朱九真', '会计', 5566, 2500, null, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是关系型数据库中将一组查询指令构成的结果集组合成可查询的数据表的对象。简单的说，视图就是虚拟的表，但与数据表不同的是，数据表是一种实体结构，而视图是一种虚拟结构，你也可以将视图理解为保存在数据库中被赋予名字的 SQL 语句。</p><p>使用视图可以获得以下好处：</p><ol><li>可以将实体数据表隐藏起来，让外部程序无法得知实际的数据结构，让访问者可以使用表的组成部分而不是整个表，降低数据库被攻击的风险。</li><li>在大多数的情况下视图是只读的（更新视图的操作通常都有诸多的限制），外部程序无法直接透过视图修改数据。</li><li>重用 SQL 语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询。</li><li>视图可以返回与实体数据表不同格式的数据，在创建视图的时候可以对数据进行格式化处理。</li></ol><p>创建视图。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create view `vw_emp_simple`asselect  `eno`,        `ename`,        `job`,        `dno`  from  `tb_emp`;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：因为视图不包含数据，所以每次使用视图时，都必须执行查询以获得数据，如果你使用了连接查询、嵌套查询创建了较为复杂的视图，你可能会发现查询性能下降得很厉害。因此，在使用复杂的视图前，应该进行测试以确保其性能能够满足应用的需求。</p></blockquote><p>有了上面的视图，我们就可以使用之前讲过的 DCL， 限制某些用户只能从视图中获取员工信息，这样员工表中的工资（<code>sal</code>）、补贴（<code>comm</code>）等敏感字段便不会暴露给用户。下面的代码演示了如何从视图中获取数据。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select * from `vw_emp_simple`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询结果：</p><pre class="line-numbers language-none"><code class="language-none">+------+-----------+--------------+-----+| eno  | ename     | job          | dno |+------+-----------+--------------+-----+| 1359 | 胡二刀    | 销售员       |  30 || 2056 | 乔峰      | 分析师       |  20 || 3088 | 李莫愁    | 设计师       |  20 || 3211 | 张无忌    | 程序员       |  20 || 3233 | 丘处机    | 程序员       |  20 || 3244 | 欧阳锋    | 程序员       |  20 || 3251 | 张翠山    | 程序员       |  20 || 3344 | 黄蓉      | 销售主管     |  30 || 3577 | 杨过      | 会计         |  10 || 3588 | 朱九真    | 会计         |  10 || 4466 | 苗人凤    | 销售员       |  30 || 5234 | 郭靖      | 出纳         |  10 || 5566 | 宋远桥    | 会计师       |  10 || 7800 | 张三丰    | 总裁         |  20 |+------+-----------+--------------+-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>既然视图是一张虚拟的表，那么视图的中的数据可以更新吗？视图的可更新性要视具体情况而定，以下类型的视图是不能更新的：</p><ol><li>使用了聚合函数（<code>SUM</code>、<code>MIN</code>、<code>MAX</code>、<code>AVG</code>、<code>COUNT</code>等）、<code>DISTINCT</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>UNION</code>或者<code>UNION ALL</code>的视图。</li><li><code>SELECT</code>中包含了子查询的视图。</li><li><code>FROM</code>子句中包含了一个不能更新的视图的视图。</li><li><code>WHERE</code>子句的子查询引用了<code>FROM</code>子句中的表的视图。</li></ol><p>删除视图。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop view if exists `vw_emp_simple`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>说明</strong>：如果希望更新视图，可以先用上面的命令删除视图，也可以通过<code>create or replace view</code>来更新视图。</p></blockquote><p>视图的规则和限制。</p><ol><li>视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。视图也可以和表一起使用。</li><li>创建视图时可以使用<code>order by</code>子句，但如果从视图中检索数据时也使用了<code>order by</code>，那么该视图中原先的<code>order by</code>会被覆盖。</li><li>视图无法使用索引，也不会激发触发器（实际开发中因为性能等各方面的考虑，通常不建议使用触发器，所以我们也不对这个概念进行介绍）的执行。</li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>MySQL 中的函数跟 Python 中的函数大同小异，因为函数都是用来封装功能上相对独立且会被重复使用的代码的。如果非要找出一些差别来，那么 MySQL 中的函数是可以执行 SQL 语句的。下面的例子，我们通过自定义函数实现了截断超长字符串的功能。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">delimiter $$create function fn_truncate_string(    content varchar(10000),    max_length int unsigned) returns varchar(10000) no sqlbegin    declare result varchar(10000) default content;    if char_length(content) &gt; max_length then        set result = left(content, max_length);        set result = concat(result, '……');    end if;    return result;end $$delimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明1</strong>：函数声明后面的<code>no sql</code>是声明函数体并没有使用 SQL 语句；如果函数体中需要通过 SQL 读取数据，需要声明为<code>reads sql data</code>。</p><p><strong>说明2</strong>：定义函数前后的<code>delimiter</code>命令是为了修改终止符（定界符），因为函数体中的语句都是用<code>;</code>表示结束，如果不重新定义定界符，那么遇到的<code>;</code>的时候代码就会被截断执行，显然这不是我们想要的效果。</p></blockquote><p>在查询中调用自定义函数。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select fn_truncate_string('和我在成都的街头走一走，直到所有的灯都熄灭了也不停留', 10) as short_string;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">+--------------------------------------+| short_string                         |+--------------------------------------+| 和我在成都的街头走一……                 |+--------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过程（又称存储过程）是事先编译好存储在数据库中的一组 SQL 的集合，调用过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能也是有帮助的。其实迄今为止，我们使用的 SQL 语句都是针对一个或多个表的单条语句，但在实际开发中经常会遇到某个操作需要多条 SQL 语句才能完成的情况。例如，电商网站在受理用户订单时，需要做以下一系列的处理。 </p><ol><li>通过查询来核对库存中是否有对应的物品以及库存是否充足。</li><li>如果库存有物品，需要锁定库存以确保这些物品不再卖给别人， 并且要减少可用的物品数量以反映正确的库存量。</li><li>如果库存不足，可能需要进一步与供应商进行交互或者至少产生一条系统提示消息。 </li><li>不管受理订单是否成功，都需要产生流水记录，而且需要给对应的用户产生一条通知信息。</li></ol><p>我们可以通过过程将复杂的操作封装起来，这样不仅有助于保证数据的一致性，而且将来如果业务发生了变动，只需要调整和修改过程即可。对于调用过程的用户来说，过程并没有暴露数据表的细节，而且执行过程比一条条的执行一组 SQL 要快得多。</p><p>下面的过程实现 hrs 数据库中员工工资的普调，具体的规则是：<code>10</code>部门的员工薪资上浮<code>300</code>， <code>20</code>部门的员工薪资上浮<code>800</code>，<code>30</code>部门的员工薪资上浮<code>500</code>。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">delimiter $$create procedure sp_upgrade_salary()begin    declare flag boolean default 1;    -- 定义一个异常处理器    declare continue handler for sqlexception set flag=0;    -- 开启事务环境    start transaction;        update tb_emp set sal=sal+300 where dno=10;    update tb_emp set sal=sal+800 where dno=20;    update tb_emp set sal=sal+500 where dno=30;    -- 提交或回滚事务    if flag then        commit;    else        rollback;    end if;end $$delimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面的过程代码中使用了<code>start transaction</code>来开启事务环境，关于事务，在本课的最后有一个简单的介绍。为了确定代码中是否发生异常，从而提交或回滚事务，上面的过程中定义了一个名为<code>flag</code>的变量和一个异常处理器，如果发生了异常，<code>flag</code>将会被赋值为<code>0</code>，后面的分支结构会根据<code>flag</code>的值来决定是执行<code>commit</code>，还是执行<code>rollback</code>。</p></blockquote><p>调用过程。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">call sp_upgrade_salary();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除过程。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop procedure if exists sp_upgrade_salary;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在过程中，我们可以定义变量、条件，可以使用分支和循环语句，可以通过游标操作查询结果，还可以使用事件调度器，这些内容我们暂时不在此处进行介绍。虽然我们说了很多过程的好处，但是在实际开发中，如果频繁的使用过程并将大量复杂的运算放到过程中，会给据库服务器造成巨大的压力，而数据库往往都是性能瓶颈所在，使用过程无疑是雪上加霜的操作。所以，对于互联网产品开发，我们一般建议让数据库只做好存储，复杂的运算和处理交给应用服务器上的程序去完成，如果应用服务器变得不堪重负了，我们可以比较容易的部署多台应用服务器来分摊这些压力。</p><p>如果大家对上面讲到的视图、函数、过程包括我们没有讲到的触发器这些知识有兴趣，建议大家阅读 MySQL 的入门读物<a href="https://item.jd.com/12818982.html">《MySQL必知必会》</a>进行一般性了解即可，因为这些知识点在大家将来的工作中未必用得上，学了也可能仅仅是为了应付面试而已。</p><h3 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h3><h4 id="范式理论"><a href="#范式理论" class="headerlink" title="范式理论"></a>范式理论</h4><p>范式理论是设计关系型数据库中二维表的指导思想。</p><ol><li>第一范式：数据表的每个列的值域都是由原子值组成的，不能够再分割。</li><li>第二范式：数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系。</li><li>第三范式：所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。</li></ol><blockquote><p><strong>说明</strong>：实际工作中，出于效率的考虑，我们在设计表时很有可能做出反范式设计，即故意降低方式级别，增加冗余数据来获得更好的操作性能。</p></blockquote><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><ol><li><p>实体完整性 - 每个实体都是独一无二的</p><ul><li>主键（<code>primary key</code>） / 唯一约束（<code>unique</code>）</li></ul></li><li><p>引用完整性（参照完整性）- 关系中不允许引用不存在的实体</p><ul><li>外键（<code>foreign key</code>）</li></ul></li><li><p>域（domain）完整性 - 数据是有效的</p><ul><li><p>数据类型及长度</p></li><li><p>非空约束（<code>not null</code>）</p></li><li><p>默认值约束（<code>default</code>）</p></li><li><p>检查约束（<code>check</code>）</p><blockquote><p><strong>说明</strong>：在 MySQL 8.x 以前，检查约束并不起作用。</p></blockquote></li></ul></li></ol><h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4><ol><li><p>事务：一系列对数据库进行读/写的操作，这些操作要么全都成功，要么全都失败。</p></li><li><p>事务的 ACID 特性</p><ul><li>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li><li>一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态</li><li>隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li><li>持久性：已被提交的事务对数据库的修改应该永久保存在数据库中</li></ul></li><li><p>MySQL 中的事务操作</p><ul><li><p>开启事务环境</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">start transaction<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>提交事务</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">commit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>回滚事务</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">rollback<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>查看事务隔离级别</p> <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show variables like 'transaction_isolation';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> <pre class="line-numbers language-none"><code class="language-none">+-----------------------+-----------------+| Variable_name         | Value           |+-----------------------+-----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+-----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以看出，MySQL 默认的事务隔离级别是<code>REPEATABLE-READ</code>。</p></li><li><p>修改（当前会话）事务隔离级别</p> <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">set session transaction isolation level read committed;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 重新查看事务隔离级别，结果如下所示。</p> <pre class="line-numbers language-none"><code class="language-none">+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>关系型数据库的事务是一个很大的话题，因为当存在多个并发事务访问数据时，就有可能出现三类读数据的问题（脏读、不可重复读、幻读）和两类更新数据的问题（第一类丢失更新、第二类丢失更新）。想了解这五类问题的，可以阅读我发布在 CSDN 网站上的<a href="https://blog.csdn.net/jackfrued/article/details/44921941">《Java面试题全集（上）》</a>一文的第80题。为了避免这些问题，关系型数据库底层是有对应的锁机制的，按锁定对象不同可以分为表级锁和行级锁，按并发事务锁定关系可以分为共享锁和独占锁。然而直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定适当的事务隔离级别，数据库就会通过分析 SQL 语句，然后为事务访问的资源加上合适的锁。此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的。想了解 MySQL 事务和锁的细节知识，推荐大家阅读进阶读物<a href="https://item.jd.com/11220393.html">《高性能MySQL》</a>，这也是数据库方面的经典书籍。</p><p>ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示。需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定到底使用哪种事务隔离级别，这个地方没有万能的原则。</p><img src="http://localhost/mypic/20211121225327.png" style="zoom:50%;"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于 MySQL 的知识肯定远远不止上面列出的这些，比如 MySQL 性能调优、MySQL 运维相关工具、MySQL 数据的备份和恢复、监控 MySQL 服务、部署高可用架构等，这一系列的问题在这里都没有办法逐一展开来讨论，那就留到有需要的时候再进行讲解吧，各位读者也可以自行探索。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第47课：MySQL新特性</title>
      <link href="/blog/irlyxfqi.html"/>
      <url>/blog/irlyxfqi.html</url>
      
        <content type="html"><![CDATA[<h2 id="第47课：MySQL-新特性"><a href="#第47课：MySQL-新特性" class="headerlink" title="第47课：MySQL 新特性"></a>第47课：MySQL 新特性</h2><h4 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h4><p>很多开发者在使用关系型数据库做数据持久化的时候，常常感到结构化的存储缺乏灵活性，因为必须事先设计好所有的列以及对应的数据类型。在业务发展和变化的过程中，如果需要修改表结构，这绝对是比较麻烦和难受的事情。从 MySQL 5.7 版本开始，MySQL引入了对 JSON 数据类型的支持（MySQL 8.0 解决了 JSON 的日志性能瓶颈问题），用好 JSON 类型，其实就是打破了关系型数据库和非关系型数据库之间的界限，为数据持久化操作带来了更多的便捷。</p><p>JSON 类型主要分为 JSON 对象和 JSON数组两种，如下所示。</p><ol><li>JSON 对象</li></ol><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{"name": "骆昊", "tel": "13122335566", "QQ": "957658"}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>JSON 数组</li></ol><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">[1, 2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">[{"name": "骆昊", "tel": "13122335566"}, {"name": "王大锤", "QQ": "123456"}]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>哪些地方需要用到JSON类型呢？举一个简单的例子，现在很多产品的用户登录都支持多种方式，例如手机号、微信、QQ、新浪微博等，但是一般情况下我们又不会要求用户提供所有的这些信息，那么用传统的设计方式，就需要设计多个列来对应多种登录方式，可能还需要允许这些列存在空值，这显然不是很好的选择；另一方面，如果产品又增加了一种登录方式，那么就必然要修改之前的表结构，这就更让人痛苦了。但是，有了 JSON 类型，刚才的问题就迎刃而解了，我们可以做出如下所示的设计。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table `tb_test`(`user_id` bigint unsigned,`login_info` json,primary key (`user_id`)) engine=innodb;insert into `tb_test` values     (1, '{"tel": "13122335566", "QQ": "654321", "wechat": "jackfrued"}'),    (2, '{"tel": "13599876543", "weibo": "wangdachui123"}');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要查询用户的手机和微信号，可以用如下所示的 SQL 语句。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select     `user_id`,    json_unquote(json_extract(`login_info`, '$.tel')) as 手机号,    json_unquote(json_extract(`login_info`, '$.wechat')) as 微信 from `tb_test`;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">+---------+-------------+-----------+| user_id | 手机号      | 微信       |+---------+-------------+-----------+|       1 | 13122335566 | jackfrued ||       2 | 13599876543 | NULL      |+---------+-------------+-----------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为支持 JSON 类型，MySQL 也提供了配套的处理 JSON 数据的函数，就像上面用到的<code>json_extract</code>和<code>json_unquote</code>。当然，上面的 SQL 还有更为便捷的写法，如下所示。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select `user_id`,    `login_info` -&gt;&gt; '$.tel' as 手机号,    `login_info` -&gt;&gt; '$.wechat' as 微信from `tb_test`;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再举个例子，如果我们的产品要实现用户画像功能（给用户打标签），然后基于用户画像给用户推荐平台的服务或消费品之类的东西，我们也可以使用 JSON 类型来保存用户画像数据，示意代码如下所示。</p><p>创建画像标签表。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table `tb_tags`(`tag_id` int unsigned not null comment '标签ID',`tag_name` varchar(20) not null comment '标签名',primary key (`tag_id`)) engine=innodb;insert into `tb_tags` (`tag_id`, `tag_name`) values    (1, '70后'),    (2, '80后'),    (3, '90后'),    (4, '00后'),    (5, '爱运动'),    (6, '高学历'),    (7, '小资'),    (8, '有房'),    (9, '有车'),    (10, '爱看电影'),    (11, '爱网购'),    (12, '常点外卖');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为用户打标签。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table `tb_users_tags`(`user_id` bigint unsigned not null comment '用户ID',`user_tags` json not null comment '用户标签') engine=innodb;insert into `tb_users_tags` values     (1, '[2, 6, 8, 10]'),    (2, '[3, 10, 12]'),    (3, '[3, 8, 9, 11]');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们通过一组查询来了解 JSON 类型的巧妙之处。</p><ol><li><p>查询爱看电影（有<code>10</code>这个标签）的用户ID。</p> <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select `user_id` from `tb_users_tags` where 10 member of (`user_tags`-&gt;'$');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询爱看电影（有<code>10</code>这个标签）的80后（有<code>2</code>这个标签）用户ID。</p> <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select `user_id` from `tb_users_tags` where json_contains(`user_tags`-&gt;'$', '[2, 10]');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询爱看电影或80后或90后的用户ID。</p> <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select `user_id` from `tb_users_tags` where json_overlaps(user_tags-&gt;'$', '[2, 3, 10]');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><blockquote><p><strong>说明</strong>：上面的查询用到了<code>member of</code>谓词和两个 JSON 函数，<code>json_contains</code>可以检查 JSON 数组是否包含了指定的元素，而<code>json_overlaps</code>可以检查 JSON 数组是否与指定的数组有重叠部分。</p></blockquote><h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><p>MySQL 从8.0开始支持窗口函数，大多数商业数据库和一些开源数据库早已提供了对窗口函数的支持，有的也将其称之为 OLAP（联机分析和处理）函数，听名字就知道跟统计和分析相关。为了帮助大家理解窗口函数，我们先说说窗口的概念。</p><p>窗口可以理解为记录的集合，窗口函数也就是在满足某种条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数。窗口函数和我们上面讲到的聚合函数比较容易混淆，二者的区别主要在于聚合函数是将多条记录聚合为一条记录，窗口函数是每条记录都会执行，执行后记录条数不会变。窗口函数不仅仅是几个函数，它是一套完整的语法，函数只是该语法的一部分，基本语法如下所示：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用户排序的列名&gt;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面语法中，窗口函数的位置可以放以下两种函数：</p><ol><li>专用窗口函数，包括：<code>lead</code>、<code>lag</code>、<code>first_value</code>、<code>last_value</code>、<code>rank</code>、<code>dense_rank</code>和<code>row_number</code>等。</li><li>聚合函数，包括：<code>sum</code>、<code>avg</code>、<code>max</code>、<code>min</code>和<code>count</code>等。</li></ol><p>下面为大家举几个使用窗口函数的简单例子，我们直接使用上一课创建的 hrs 数据库。</p><p>例子1：查询按月薪从高到低排在第4到第6名的员工的姓名和月薪。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select * from (select `ename`, `sal`,row_number() over (order by `sal` desc) as `rank`from `tb_emp`) `temp` where `rank` between 4 and 6;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面使用的函数<code>row_number()</code>可以为每条记录生成一个行号，在实际工作中可以根据需要将其替换为<code>rank()</code>或<code>dense_rank()</code>函数，三者的区别可以参考官方文档或阅读<a href="https://zhuanlan.zhihu.com/p/92654574">《通俗易懂的学会：SQL窗口函数》</a>进行了解。在MySQL 8以前的版本，我们可以通过下面的方式来完成类似的操作。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select `rank`, `ename`, `sal` from (       select @a:=@a+1 as `rank`, `ename`, `sal`        from `tb_emp`, (select @a:=0) as t1 order by `sal` desc) as `temp` where `rank` between 4 and 6;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>例子2：查询每个部门月薪最高的两名的员工的姓名和部门名称。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select `ename`, `sal`, `dname` from (    select         `ename`, `sal`, `dno`,        rank() over (partition by `dno` order by `sal` desc) as `rank`    from `tb_emp`) as `temp` natural join `tb_dept` where `rank`&lt;=2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>说明：在MySQL 8以前的版本，我们可以通过下面的方式来完成类似的操作。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select `ename`, `sal`, `dname` from `tb_emp` as `t1` natural join `tb_dept` where (       select count(*) from `tb_emp` as `t2`        where `t1`.`dno`=`t2`.`dno` and `t2`.`sal`&gt;`t1`.`sal` )&lt;2 order by `dno` asc, `sal` desc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第48课：Python程序接入MySQL数据库</title>
      <link href="/blog/xccatknt.html"/>
      <url>/blog/xccatknt.html</url>
      
        <content type="html"><![CDATA[<h2 id="第48课：Python程序接入MySQL数据库"><a href="#第48课：Python程序接入MySQL数据库" class="headerlink" title="第48课：Python程序接入MySQL数据库"></a>第48课：Python程序接入MySQL数据库</h2><p>在 Python3 中，我们可以使用<code>mysqlclient</code>或者<code>pymysql</code>三方库来接入 MySQL 数据库并实现数据持久化操作。二者的用法完全相同，只是导入的模块名不一样。我们推荐大家使用纯 Python 的三方库<code>pymysql</code>，因为它更容易安装成功。下面我们仍然以之前创建的名为<code>hrs</code>的数据库为例，为大家演示如何通过 Python 程序操作 MySQL 数据库实现数据持久化操作。</p><h3 id="接入MySQL"><a href="#接入MySQL" class="headerlink" title="接入MySQL"></a>接入MySQL</h3><p>首先，我们可以在命令行或者 PyCharm 的终端中通过下面的命令安装<code>pymysql</code>，如果需要接入 MySQL 8，还需要安装一个名为<code>cryptography</code>的三方库来支持 MySQL 8 的密码认证方式。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">pip install pymysql cryptography<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>pymysql</code>操作 MySQL 的步骤如下所示：</p><ol><li>创建连接。MySQL 服务器启动后，提供了基于 TCP （传输控制协议）的网络服务。我们可以通过<code>pymysql</code>模块的<code>connect</code>函数连接 MySQL 服务器。在调用<code>connect</code>函数时，需要指定主机（<code>host</code>）、端口（<code>port</code>）、用户名（<code>user</code>）、口令（<code>password</code>）、数据库（<code>database</code>）、字符集（<code>charset</code>）等参数，该函数会返回一个<code>Connection</code>对象。</li><li>获取游标。连接 MySQL 服务器成功后，接下来要做的就是向数据库服务器发送 SQL 语句，MySQL 会执行接收到的 SQL 并将执行结果通过网络返回。要实现这项操作，需要先通过连接对象的<code>cursor</code>方法获取游标（<code>Cursor</code>）对象。</li><li>发出 SQL。通过游标对象的<code>execute</code>方法，我们可以向数据库发出 SQL 语句。</li><li>如果执行<code>insert</code>、<code>delete</code>或<code>update</code>操作，需要根据实际情况提交或回滚事务。因为创建连接时，默认开启了事务环境，在操作完成后，需要使用连接对象的<code>commit</code>或<code>rollback</code>方法，实现事务的提交或回滚，<code>rollback</code>方法通常会放在异常捕获代码块<code>except</code>中。如果执行<code>select</code>操作，需要通过游标对象抓取查询的结果，对应的方法有三个，分别是：<code>fetchone</code>、<code>fetchmany</code>和<code>fetchall</code>。其中<code>fetchone</code>方法会抓取到一条记录，并以元组或字典的方式返回；<code>fetchmany</code>和<code>fetchall</code>方法会抓取到多条记录，以嵌套元组或列表装字典的方式返回。</li><li>关闭连接。在完成持久化操作后，请不要忘记关闭连接，释放外部资源。我们通常会在<code>finally</code>代码块中使用连接对象的<code>close</code>方法来关闭连接。</li></ol><h3 id="代码实操"><a href="#代码实操" class="headerlink" title="代码实操"></a>代码实操</h3><p>下面，我们通过代码实操的方式为大家演示上面说的五个步骤。</p><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import pymysqlno = int(input('部门编号: '))name = input('部门名称: ')location = input('部门所在地: ')# 1. 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4')try:    # 2. 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        affected_rows = cursor.execute(            'insert into `tb_dept` values (%s, %s, %s)',            (no, name, location)        )        if affected_rows == 1:            print('新增部门成功!!!')    # 4. 提交事务（transaction）    conn.commit()except pymysql.MySQLError as err:    # 4. 回滚事务    conn.rollback()    print(type(err), err)finally:    # 5. 关闭连接释放资源    conn.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面的<code>127.0.0.1</code>称为回环地址，它代表的是本机。下面的<code>guest</code>是我提前创建好的用户，该用户拥有对<code>hrs</code>数据库的<code>insert</code>、<code>delete</code>、<code>update</code>和<code>select</code>权限。我们不建议大家在项目中直接使用<code>root</code>超级管理员账号访问数据库，这样做实在是太危险了。我们可以使用下面的命令创建名为<code>guest</code>的用户并为其授权。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create user 'guest'@'%' identified by 'Guest.618';grant insert, delete, update, select on `hrs`.* to 'guest'@'%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p>如果要插入大量数据，建议使用游标对象的<code>executemany</code>方法做批处理（一个<code>insert</code>操作后面跟上多组数据），大家可以尝试向一张表插入10000条记录，然后看看不使用批处理一条条的插入和使用批处理有什么差别。游标对象的<code>executemany</code>方法第一个参数仍然是 SQL 语句，第二个参数可以是包含多组数据的列表或元组。</p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import pymysqlno = int(input('部门编号: '))# 1. 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4',                       autocommit=True)try:    # 2. 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        affected_rows = cursor.execute(            'delete from `tb_dept` where `dno`=%s',            (no, )        )        if affected_rows == 1:            print('删除部门成功!!!')finally:    # 5. 关闭连接释放资源    conn.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：如果不希望每次 SQL 操作之后手动提交或回滚事务，可以<code>connect</code>函数中加一个名为<code>autocommit</code>的参数并将它的值设置为<code>True</code>，表示每次执行 SQL 成功后自动提交。但是我们建议大家手动提交或回滚，这样可以根据实际业务需要来构造事务环境。如果不愿意捕获异常并进行处理，可以在<code>try</code>代码块后直接跟<code>finally</code>块，省略<code>except</code>意味着发生异常时，代码会直接崩溃并将异常栈显示在终端中。</p></blockquote><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import pymysqlno = int(input('部门编号: '))name = input('部门名称: ')location = input('部门所在地: ')# 1. 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4')try:    # 2. 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        affected_rows = cursor.execute(            'update `tb_dept` set `dname`=%s, `dloc`=%s where `dno`=%s',            (name, location, no)        )        if affected_rows == 1:            print('更新部门信息成功!!!')    # 4. 提交事务    conn.commit()except pymysql.MySQLError as err:    # 4. 回滚事务    conn.rollback()    print(type(err), err)finally:    # 5. 关闭连接释放资源    conn.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><ol><li>查询部门表的数据。</li></ol><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import pymysql# 1. 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4')try:    # 2. 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        cursor.execute('select `dno`, `dname`, `dloc` from `tb_dept`')        # 4. 通过游标对象抓取数据        row = cursor.fetchone()        while row:            print(row)            row = cursor.fetchone()except pymysql.MySQLError as err:    print(type(err), err)finally:    # 5. 关闭连接释放资源    conn.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：上面的代码中，我们通过构造一个<code>while</code>循环实现了逐行抓取查询结果的操作。这种方式特别适合查询结果有非常多行的场景。因为如果使用<code>fetchall</code>一次性将所有记录抓取到一个嵌套元组中，会造成非常大的内存开销，这在很多场景下并不是一个好主意。如果不愿意使用<code>while</code>循环，还可以考虑使用<code>iter</code>函数构造一个迭代器来逐行抓取数据，有兴趣的读者可以自行研究。</p></blockquote><ol start="2"><li>分页查询员工表的数据。</li></ol><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import pymysqlpage = int(input('页码: '))size = int(input('大小: '))# 1. 创建连接（Connection）con = pymysql.connect(host='127.0.0.1', port=3306,                      user='guest', password='Guest.618',                      database='hrs', charset='utf8')try:    # 2. 获取游标对象（Cursor）    with con.cursor(pymysql.cursors.DictCursor) as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        cursor.execute(            'select `eno`, `ename`, `job`, `sal` from `tb_emp` order by `sal` desc limit %s,%s',            ((page - 1) * size, size)        )        # 4. 通过游标对象抓取数据        for emp_dict in cursor.fetchall():            print(emp_dict)finally:    # 5. 关闭连接释放资源    con.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h3><p>下面我们为大家讲解一个将数据库表数据导出到 Excel 文件的例子，我们需要先安装<code>openpyxl</code>三方库，命令如下所示。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">pip install openpyxl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，我们通过下面的代码实现了将数据库<code>hrs</code>中所有员工的编号、姓名、职位、月薪、补贴和部门名称导出到一个 Excel 文件中。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import openpyxlimport pymysql# 创建工作簿对象workbook = openpyxl.Workbook()# 获得默认的工作表sheet = workbook.active# 修改工作表的标题sheet.title = '员工基本信息'# 给工作表添加表头sheet.append(('工号', '姓名', '职位', '月薪', '补贴', '部门'))# 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4')try:    # 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 通过游标对象执行SQL语句        cursor.execute(            'select `eno`, `ename`, `job`, `sal`, coalesce(`comm`, 0), `dname` '            'from `tb_emp` natural join `tb_dept`'        )        # 通过游标抓取数据        row = cursor.fetchone()        while row:            # 将数据逐行写入工作表中            sheet.append(row)            row = cursor.fetchone()    # 保存工作簿    workbook.save('hrs.xlsx')except pymysql.MySQLError as err:    print(err)finally:    # 关闭连接释放资源    conn.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家可以参考上面的例子，试一试把 Excel 文件的数据导入到指定数据库的指定表中，看看是否可以成功。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-Core-50-Courses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unix-makefile-tutorial-cn</title>
      <link href="/blog/d52a1661.html"/>
      <url>/blog/d52a1661.html</url>
      
        <content type="html"><![CDATA[<h1 id="Unix-Makefile-教程"><a href="#Unix-Makefile-教程" class="headerlink" title="Unix Makefile 教程"></a>Unix Makefile 教程</h1><p>Tutorials Point <a href="https://www.tutorialspoint.com/makefile/index.htm">Unix Makefile tutorial</a> 中文版翻译。</p><h1 id="Unix-Makefile-基本教程"><a href="#Unix-Makefile-基本教程" class="headerlink" title="Unix Makefile 基本教程"></a>Unix Makefile 基本教程</h1><p>Makefile是一个在Unix，Linux及其版本上运行的程序构建工具。它有助于简化可能需要各种模块的构建程序可执行文件。要确定模块需要如何编译或重新编译在一起，需要用户在 Makefile 中定义make的行为。本教程会增强你对 Makefile 的结构和实用的了解。</p><h2 id="听众"><a href="#听众" class="headerlink" title="听众"></a>听众</h2><p>Makefilemake在编译和链接程序模块时指导实用程序。任何想使用make工具编译程序并希望获得有关 makefile 知识的人都建议阅读本教程。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>本教程希望对编程语言（如C和C ++）有很好的理解。希望读者了解链接（link），加载概念（loading concepts），以及如何在Unix / Linux 环境下编译和执行程序。</p><h2 id="英文原文"><a href="#英文原文" class="headerlink" title="英文原文"></a>英文原文</h2><p><a href="https://www.tutorialspoint.com/makefile/index.htm">https://www.tutorialspoint.com/makefile/index.htm</a></p><h1 id="为什么我们需要-Makefile"><a href="#为什么我们需要-Makefile" class="headerlink" title="为什么我们需要 Makefile?"></a>为什么我们需要 Makefile?</h1><p>手动编译源代码文件很麻烦，特别是当你要编译多个源文件，并切每次编译都要重复输入编译命令的时候。而 Makefiles 正是为了简化这个过程的一个工具。</p><p>首先你需要了解 Makefiles 是一种特殊格式的文件，可帮助自动构建和管理项目。</p><p>例如，我们假设我们有以下源文件。</p><ul><li>main.cpp</li><li>hello.cpp</li><li>factorial.cpp</li><li>functions.h</li></ul><p><em>main.cpp中</em></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"functions.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">print_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The factorial of 5 is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>hello.cpp</em></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"functions.h"</span></span><span class="token keyword">void</span> <span class="token function">print_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>factorial.cpp</em></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"functions.h"</span></span><span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>functions.h</em></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编译文件并获取可执行文件的简单方法是运行命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc  main.cpp hello.cpp factorial.cpp <span class="token parameter variable">-o</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令生成 hello 二进制文件。在这个例子中，我们的项目里只有四个文件，同时我们也知道这些函数调用的顺序。因此，键入上述命令并准备最终二进制文件是可行的。但是，对于拥有数千个源代码文件的大型项目来说，想要维护这个二进制版本会变得非常困难。</p><p>不过没关系，make命令正是用来管理大型程序或程序组的。当你开始编写大型程序时，你会注意到重新编译大型程序比重新编译短程序需要更长的时间。此外，你也可能注意到通常情况下开发者只能在程序的一小部分（例如单个函数）上工作，其余大部分程序文件都没有变化。</p><p>在随后的部分中，我们看到如何为我们的项目准备一个 Makefile。</p><h1 id="Makefile-宏"><a href="#Makefile-宏" class="headerlink" title="Makefile - 宏"></a>Makefile - 宏</h1><p><code>make</code> 允许你使用类似变量的宏。宏在 Makefile 中使用 名称 = 值 的形式来定义。例如</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">MACROS  <span class="token operator">=</span> -mePSROFF  <span class="token operator">=</span> groff -TpsDITROFF <span class="token operator">=</span> groff -TdviCFLAGS  <span class="token operator">=</span> -O -systype bsd43LIBS    <span class="token operator">=</span> <span class="token string">"-lncurses -lm -lsdl"</span>MYFACE  <span class="token operator">=</span> <span class="token string">":*)"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特殊的宏"><a href="#特殊的宏" class="headerlink" title="特殊的宏"></a>特殊的宏</h2><p>在运行任何目标集（target rule set）中的指令之前，有一些预定义的特殊宏 -</p><ul><li><p><strong>$@</strong> 要创建的文件的名称。</p></li><li><p><strong>$?</strong> 是被更改的对应文件名。</p></li></ul><p>例如，在下列场景中我们可以使用如下规则：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">hello</span><span class="token punctuation">:</span> main.cpp hello.cpp factorial.cpp    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$?</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span>或者 −<span class="token target symbol">hello</span><span class="token punctuation">:</span> main.cpp hello.cpp factorial.cpp    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$@.cpp</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，像 $(CC) $(CFLAGS) $? $(LDFLAGS) -o $@ 这样的操作行应该在行首输入一个制表符 (\t) ，否则 make 会报错。 其中的 $@ 代表 hello 同时 $? 或者 $@.cpp 则代表所有已修改源文件。</p><p>同时默认规则中还有另外两个特殊的宏。他们分别是 -</p><ul><li><p><strong>$&lt;</strong> 触发操作的相关文件的名称。</p></li><li><p><strong>$*</strong> 由目标文件和依赖文件共享的前缀。</p></li></ul><p>常见的隐式规则是用于构建 .cpp（源文件）之外的 .o（对象）文件。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">.cpp.o</span><span class="token punctuation">:</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span>或者 −<span class="token target symbol">.cpp.o</span><span class="token punctuation">:</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$*.c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常规宏"><a href="#常规宏" class="headerlink" title="常规宏"></a>常规宏</h2><p>有各种默认的宏。你可以通过 “make -p” 命令看到他们。大多数的常规宏都是见名知意。</p><p>这些预定义变量（即隐式规则中使用的宏）分为两类 -</p><ul><li><p>作为程序名称的宏（如CC）</p></li><li><p>包含程序参数的宏（如CFLAGS）。</p></li></ul><p>以下是一些用作 Makefile 内置规则中程序名称的常用变量表。</p><table><thead><tr><th align="left">AR</th><th align="left">档案保存程序;默认是`ar’。</th></tr></thead><tbody><tr><td align="left">AS</td><td align="left">编译汇编文件的程序；默认是 `as’。</td></tr><tr><td align="left">CC</td><td align="left">编译 C 语言文件的程序；默认是 `cc’.</td></tr><tr><td align="left">CO</td><td align="left">Program for checking out files from RCS; default is `co’.</td></tr><tr><td align="left">CXX</td><td align="left">编译 C++ 文件的程序; 默认是 `g++’.</td></tr><tr><td align="left">CPP</td><td align="left">运行 C 预处理器并输出到当前输出流的程序; 默认是 `$(CC) -E’.</td></tr><tr><td align="left">FC</td><td align="left">Program for compiling or preprocessing Fortran and Ratfor programs; default is `f77’.</td></tr><tr><td align="left">GET</td><td align="left">Program for extracting a file from SCCS; default is `get’.</td></tr><tr><td align="left">LEX</td><td align="left">Program to use to turn Lex grammars into source code; default is `lex’.</td></tr><tr><td align="left">YACC</td><td align="left">Program to use to turn Yacc grammars into source code; default is `yacc’.</td></tr><tr><td align="left">LINT</td><td align="left">Program to use to run lint on source code; default is `lint’.</td></tr><tr><td align="left">M2C</td><td align="left">Program to use to compile Modula-2 source code; default is `m2c’.</td></tr><tr><td align="left">PC</td><td align="left">编译 Pascal 的程序；默认值是 `pc’。</td></tr><tr><td align="left">MAKEINFO</td><td align="left">Program to convert a Texinfo source file into an Info file; default is `makeinfo’.</td></tr><tr><td align="left">TEX</td><td align="left">Program to make TeX dvi files from TeX source; default is `tex’.</td></tr><tr><td align="left">TEXI2DVI</td><td align="left">Program to make TeX dvi files from Texinfo source; default is `texi2dvi’.</td></tr><tr><td align="left">WEAVE</td><td align="left">将 Web 转化为 TeX 的程序；默认值是 `weave’。</td></tr><tr><td align="left">CWEAVE</td><td align="left">将 C Web 转换为 TeX 的程序；默认值是 `cweave’。</td></tr><tr><td align="left">TANGLE</td><td align="left">将 Web 转化为 Pascal 的程序；默认值是 `tangle’。</td></tr><tr><td align="left">CTANGLE</td><td align="left">将 C Web 转换为 C 的程序；默认值是 `ctangle’。</td></tr><tr><td align="left">RM</td><td align="left">删除文件的命令；默认是 `rm -f’.</td></tr></tbody></table><p>这是一个变量表，其值是上述程序的附加参数。除非另有说明，否则所有这些变量的默认值都是空字符串。</p><table><thead><tr><th align="left">ARFLAGS</th><th align="left">Flags to give the archive-maintaining program; default is `rv’.</th></tr></thead><tbody><tr><td align="left">ASFLAGS</td><td align="left">Extra flags to give to the assembler when explicitly invoked on a `.s’ or `.S’ file.</td></tr><tr><td align="left">CFLAGS</td><td align="left">传递给 C 编译器的额外 flag。</td></tr><tr><td align="left">CXXFLAGS</td><td align="left">传递给 C 编译器 的额外 flag。</td></tr><tr><td align="left">COFLAGS</td><td align="left">Extra flags to give to the RCS co program.</td></tr><tr><td align="left">CPPFLAGS</td><td align="left">Extra flags to give to the C preprocessor and programs, which use it (such as C and Fortran compilers).</td></tr><tr><td align="left">FFLAGS</td><td align="left">Extra flags to give to the Fortran compiler.</td></tr><tr><td align="left">GFLAGS</td><td align="left">Extra flags to give to the SCCS get program.</td></tr><tr><td align="left">LDFLAGS</td><td align="left">Extra flags to give to compilers when they are supposed to invoke the linker, `ld’.</td></tr><tr><td align="left">LFLAGS</td><td align="left">Extra flags to give to Lex.</td></tr><tr><td align="left">YFLAGS</td><td align="left">Extra flags to give to Yacc.</td></tr><tr><td align="left">PFLAGS</td><td align="left">Extra flags to give to the Pascal compiler.</td></tr><tr><td align="left">RFLAGS</td><td align="left">Extra flags to give to the Fortran compiler for Ratfor programs.</td></tr><tr><td align="left">LINTFLAGS</td><td align="left">Extra flags to give to lint.</td></tr></tbody></table><p>**注 **- 你可以使用 ‘-R’ 或 ‘–no-builtin-variables’ 选项取消隐式规则使用的所有变量。</p><p>你也可以在命令行中定义宏，如下所示 -</p><pre class="line-numbers language-none"><code class="language-none">make CPP = /home/courses/cop4530/spring02<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Makefile-依赖关系"><a href="#Makefile-依赖关系" class="headerlink" title="Makefile - 依赖关系"></a>Makefile - 依赖关系</h1><p>最后构建得到的二进制文件依赖于各种源代码和头文件是很常见的。依赖关系很重要，因为它们让 <code>make</code> 知道的任何执行<strong>目标</strong>的依赖。考虑下面的例子 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">hello</span><span class="token punctuation">:</span> main.o factorial.o hello.o    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> main.o factorial.o hello.o -o hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，hello 为 make 的一个目标（target），而 hello 这个<strong>目标</strong>达成依赖于 main.o，factorial.o 和 hello.o 三个依赖（每个依赖都是另一个目标/文件）。因此，不论哪个依赖的目标发生了变化后， <code>make</code> 都会采取行动来重新（执行命令来）达到<strong>目标</strong>（即重新执行 <code>$(CC) main.o factorial.o hello.o -o hello</code>）。</p><p>同时，我们需要告诉 <code>make</code> 如何准备 .o 文件（即 hello 依赖的三个目标/文件）。因此我们需要定义这些依赖关系如下 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">main.o</span><span class="token punctuation">:</span> main.cpp functions.h    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c main.cpp<span class="token target symbol">factorial.o</span><span class="token punctuation">:</span> factorial.cpp functions.h    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c factorial.cpp<span class="token target symbol">hello.o</span><span class="token punctuation">:</span> hello.cpp functions.h    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c hello.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以 main.o 为例，在依赖中写上如 functions.h 的意义在于。即使 main.cpp 文件没有修改，但是 functions.h 修改了，那么 <code>$(CC) -c main.cpp</code> 也会重新执行。如果目标依赖的文件都没有修改，那么执行 <code>make</code> 的时候就不会重新去运行其目标下的命令，即不会重复编译已经编译好的代码。</p><h1 id="在-Makefile-中定义规则"><a href="#在-Makefile-中定义规则" class="headerlink" title="在 Makefile 中定义规则"></a>在 Makefile 中定义规则</h1><p>Makefile 目标规则的一般语法形式 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">target [target...]</span> <span class="token punctuation">:</span> [dependent ....]    [ command ...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>括号内的参数是可选的，省略号表示一个或多个。注意每个命令前面的标签是必需的。</p><p>下面给出一个简单的例子，您可以定义一个规则，使得 <code>make</code> 可以通过其他三个文件来达成目标 hello。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">hello</span><span class="token punctuation">:</span> main.o factorial.o hello.o    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> main.o factorial.o hello.o -o hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>**注 - **在这个例子中，你必须给出其他的规则来达成 main.o、factorial.o、hello.o 这三个目标。</p><p>依赖项比目标更新，则<code>make</code>执行一次一个命令（在宏替换之后）。如果任何依赖已经被创建，那么首先发生，所以你有一个递归根据当前目标，寻找目标的依赖以及递归查找依赖的依赖。</p><p>如果任何命令返回失败状态，则 <code>make</code>过程终止。这也是为什么你需要常备这种规则 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">clean</span><span class="token punctuation">:</span>    -rm *.o *~ core paper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>make</code>忽略以短划线开头的命令返回状态。Em，我想你可以把<code>-</code>当做是 Makefile 的行注释。</p><p><code>make</code>会输出宏替换之后的命令，来向你展示正在执行的情况。有时你可能想关闭它。例如 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">install</span><span class="token punctuation">:</span>    <span class="token operator">@</span>echo You must be root to install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 Makefiles 中有些约定俗成的目标，每次碰到 Makefile 你都可以先查看一下其中有没有。这些约定的目标分别是：all（直接 make 调用的入口目标），install 和 clean。</p><ul><li><p><strong>make all</strong> - (或者直接运行 make) 期望是：编译所有内容，以便在安装应用程序之前进行本地测试。</p></li><li><p><strong>make install</strong> - 这个目标通常期望为在适当的地方安装应用程序。但要注意事物安装在适合您系统的地方。</p></li><li><p>**make clean **- 清理应用程序，摆脱可执行文件，任何临时文件，目标文件等</p></li></ul><h1 id="在-Makefile-中定义自定义后缀规则"><a href="#在-Makefile-中定义自定义后缀规则" class="headerlink" title="在 Makefile 中定义自定义后缀规则"></a>在 Makefile 中定义自定义后缀规则</h1><p>就其本身而言，<code>make</code>已知为了创建 .o文件，它必须在相应的 .c 文件上使用 cc -c。这些规则是内置的，你可以利用他们的优势来缩短你的 Makefile。如果只在 Makefile 的依赖行中指出当前目标所依赖的.h文件，将知道相应的.c文件已经是必需的。你甚至不需要包含编译器的命令。</p><p>这进一步减少了 Makefile，如图所示 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">OBJECTS <span class="token operator">=</span> main.o hello.o factorial.o<span class="token target symbol">hello</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJECTS<span class="token punctuation">)</span>        cc <span class="token variable">$</span><span class="token punctuation">(</span>OBJECTS<span class="token punctuation">)</span> -o hello<span class="token target symbol">hellp.o</span><span class="token punctuation">:</span> functions.h<span class="token target symbol">main.o</span><span class="token punctuation">:</span> functions.h <span class="token target symbol">factorial.o</span><span class="token punctuation">:</span> functions.h <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>make</code> 使用名为 .SUFFIXES 的特殊目标来允许您定义自己的后缀。例如  -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.SUFFIXES</span><span class="token punctuation">:</span> .foo .bar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它通知<code>make</code>你将使用这些特殊的后缀来制定你自己的规则。</p><p>与<code>make</code>已知如何从 .c 文件创建 .o 文件类似，您可以按以下方式定义规则 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">.foo.bar</span><span class="token punctuation">:</span>        tr <span class="token string">'[A-Z][a-z]'</span> <span class="token string">'[N-Z][A-M][n-z][a-m]'</span> &lt; <span class="token variable">$&lt;</span> &gt; <span class="token variable">$@</span><span class="token target symbol">.c.o</span><span class="token punctuation">:</span>        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一条规则允许你从 .foo 文件创建一个 .bar 文件。（它基本上是对文件进行加密）。</p><p>第二个规则是从 .c 文件创建 .o 文件时 <code>make</code> 使用的默认规则。</p><h1 id="Makefile-指令"><a href="#Makefile-指令" class="headerlink" title="Makefile - 指令"></a>Makefile - 指令</h1><p>有许多可用于各种形式的指令（Directives）。你系统上的<code>make</code>程序可能不支持所有的指令。所以请检查你的<code>make</code>是否支持我们在这里解释的指令。本教程中的指令均源自 GNU<code>make</code>。</p><h2 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h2><p>条件指令是 -</p><ul><li><p>**ifeq **（if eqaul）指令。它包含两个参数，用逗号分隔并用圆括号包围。变量替换在两个参数上执行，然后进行比较。如果两个参数匹配，则遵循 ifeq 后面的命令行；否则会被忽略。</p></li><li><p>**ifneq **（if not eqaul）指令。它包含两个参数，用逗号分隔并用圆括号包围。变量替换在两个参数上执行，然后进行比较。如果两个参数不匹配，则遵循ifneq后面的makefile行;否则会被忽略。</p></li><li><p>**ifdef **（if defined）指令。它包含单个参数。如果给定的参数为真，则条件成立。</p></li><li><p>**ifndef **（if not defined）指令。它包含单个参数。如果给定的参数为假，则条件成立。</p></li><li><p>**else **指令导致如果之前的条件没有被遵守以下行。在上面的例子中，这意味着每当没有使用第一个替代方案时，就会使用第二个替代链接命令。在条件中有其他选项是可选的。</p></li><li><p>**endif **指令结束的语句，每个 if 条件必须以 endif 结尾。</p></li></ul><h3 id="条件指令的语法"><a href="#条件指令的语法" class="headerlink" title="条件指令的语法"></a>条件指令的语法</h3><p>最简单条件的语法如下 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">conditional-directive   text-if-true<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>text-if-true 可以是任何文本行，如果条件为真，则被视为 Makefile 的一部分。如果条件假，则不使用该内容。</p><p>复杂一点条件的语法如下 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">conditional-directive   text-if-true<span class="token keyword">else</span>   text-if-false<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果条件为真，则使用 text-if-true; 否则，使用 text-if-false。text-if-false 可以是任意数量的文本行。</p><p>无论条件简单还是复杂，条件指令的语法都是相同的。有四种不同的指令来测试各种条件。他们如同给出的 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifeq</span> <span class="token punctuation">(</span>arg1, arg2<span class="token punctuation">)</span><span class="token keyword">ifeq</span> <span class="token string">'arg1'</span> <span class="token string">'arg2'</span><span class="token keyword">ifeq</span> <span class="token string">"arg1"</span> <span class="token string">"arg2"</span><span class="token keyword">ifeq</span> <span class="token string">"arg1"</span> <span class="token string">'arg2'</span><span class="token keyword">ifeq</span> <span class="token string">'arg1'</span> <span class="token string">"arg2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上条件的相反指令如下 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifneq</span> <span class="token punctuation">(</span>arg1, arg2<span class="token punctuation">)</span><span class="token keyword">ifneq</span> <span class="token string">'arg1'</span> <span class="token string">'arg2'</span><span class="token keyword">ifneq</span> <span class="token string">"arg1"</span> <span class="token string">"arg2"</span><span class="token keyword">ifneq</span> <span class="token string">"arg1"</span> <span class="token string">'arg2'</span><span class="token keyword">ifneq</span> <span class="token string">'arg1'</span> <span class="token string">"arg2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条件指令示例"><a href="#条件指令示例" class="headerlink" title="条件指令示例"></a>条件指令示例</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">libs_for_gcc <span class="token operator">=</span> -lgnunormal_libs <span class="token operator">=</span><span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> ,gcc<span class="token punctuation">)</span>        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs_for_gcc<span class="token punctuation">)</span><span class="token keyword">else</span>        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>normal_libs<span class="token punctuation">)</span><span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="include-指令"><a href="#include-指令" class="headerlink" title="include 指令"></a>include 指令</h2><p>include 指令指示<code>make</code>在执行的过程中读取一个或多个其他 Makefile 到当前 Makefile。该指令是 Makefile 中的一行，看起来如下所示 -</p><pre class="line-numbers language-none"><code class="language-none">include filenames...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件名可以包含 shell 格式的文件名匹配。额外的空格是允许的，并且在行的开始处被忽略，但不允许使用制表符（\t）。例如，如果你有三个 `.mk’ 文件，即 `a.mk’，`b.mk’ 和 `c.mk’，以及 $(bar)，那么它将扩展到 bish bash，然后如下所示表达。</p><pre class="line-numbers language-none"><code class="language-none">include foo *.mk $(bar)等同于 −include foo a.mk b.mk c.mk bish bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当<code>make</code>处理一个 include 指令时，它会暂停并依次读取每个列出的文件到当前 Makefile。完成后，<code>make</code>继续读取执行当前的Makefile。</p><h2 id="override-指令"><a href="#override-指令" class="headerlink" title="override 指令"></a>override 指令</h2><p>如果一个变量已经设置了一个命令参数，那么 makefile 中的普通赋值就会被忽略。如果你想在 makefile 中继续修改变量，即使它是用一个命令参数设置的。那么你可以使用一个 override 指令，它是一条看起来如下所示的行：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">override</span> variable <span class="token operator">=</span> value或者<span class="token keyword">override</span> variable <span class="token operator">:=</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Makefile-重新编译"><a href="#Makefile-重新编译" class="headerlink" title="Makefile - 重新编译"></a>Makefile - 重新编译</h1><p>实际上<code>make</code>是一个智能的工具，它可以基于你在源文件中所做的更改而选择性的生效。如果你有四个文件 main.cpp、hello.cpp、factorial.cpp 和 functions.h，那么（由于顺序的原因）所有其余文件都依赖于 functions.h，而 main.cpp 依赖于 hello.cpp 和 factorial.cpp。因此，如果您在 functions.h 中进行了任何更改，则<code>make</code>会重新编译所有源文件以生成新的目标文件。但是，如果您在 main.cpp 中进行任何更改，因为它不被任何其他文件依赖，所以只会重新编译 main.cpp 文件，而 help.cpp 和 factorial.cpp 则不会。</p><p>其原理为，编译文件时<code>make</code>检查其目标文件并比较文件的更新时间戳。如果源文件比目标文件具有更新的时间戳，则假定源文件已更改，那么 make 会生成新的目标文件。</p><h2 id="避免反复编译"><a href="#避免反复编译" class="headerlink" title="避免反复编译"></a>避免反复编译</h2><p>可能有一个由数千个文件组成的项目。有时您可能更改了源文件，但您可能不想让所有依赖它的文件重新编译。例如，假设你添加一个宏或一个声明到其他文件所依赖的头文件中。通常<code>make</code>会保守地假定头文件中的任何变化都需要重新编译所有依赖于它文件，不过有时候你可能知道它们不需要重新编译，也不想浪费时间等待它们编译。</p><p>当你在更改头文件之前预见了该问题，则可以使用 “-t” 标志。该标志告诉<code>make</code>不用运行目标规则中的命令，而是通过修改目标文件的最后修改日期来标记它是最新的。你需要遵循这几个过程 -</p><ul><li><p>使用 “make” 命令重新编译真正需要重新编译的源文件。</p></li><li><p>在头文件中进行更改。</p></li><li><p>使用命令 `make -t’ 将所有对象文件标记为最新。下一次运行 make 时，头文件中的更改不会导致任何反复编译。</p></li></ul><p>如果你在某些文件需要重新编译时更改了头文件，那么再做这个操作就晚了（因为有需要编译的，不能全部重置，那么就需要全部重新编译了）。相反，你可以使用 `-o文件’ 标志，该标志将指定的文件标记为“旧”。这意味着，（相关的目标）文件本身不会被重新（编译）制作（目标文件），并且其他任何内容都不会在其（递归的）依赖链上重新（编译）制作（目标文件）。你需要遵循以下过程来实现该效果 -</p><ul><li><p>想要重新编译特定的源文件，其依赖于特定头文件修改的情况，可以使用 `make -o header file’。如果涉及到多个头文件，则为每个头文件前使用单独 “-o” 选项。</p></li><li><p>通过 `make -t’ 更新所有的目标文件。</p></li></ul><h2 id="Makefile-隐藏规则"><a href="#Makefile-隐藏规则" class="headerlink" title="Makefile 隐藏规则"></a>Makefile 隐藏规则</h2><p>这个命令应该可以在所有情况下使用，适用于我们从源文件 x.cpp 中构建可执行文件 x 作为输出，所以可以说是一个隐含的规则 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">.cpp</span><span class="token punctuation">:</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$@.cpp</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个隐藏规则说明如何通过 x.c 生成 x - 对 x.c 运行 cc 并调用输出 x。该规则是隐含的，因为没有提到特定的目标。它可以用于所有情况。</p><p>另一个常见的隐含规则是用 .cpp（源文件）构建 .o（对象）文件。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">.cpp.o</span><span class="token punctuation">:</span>        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span>或者 -<span class="token target symbol">.cpp.o</span><span class="token punctuation">:</span>        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$*.cpp</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Makefile-其他特性"><a href="#Makefile-其他特性" class="headerlink" title="Makefile - 其他特性"></a>Makefile - 其他特性</h1><h2 id="递归使用-make"><a href="#递归使用-make" class="headerlink" title="递归使用 make"></a>递归使用 make</h2><p>递归使用 <code>make</code> 的方式即在 Makefile 中将 <code>make</code> 用作命令。这个用法的主要用途是将一个大系统的拆成多个子系统i组合编译时。比如说，你有一个名为 `subdir’ 的子目录，它有自己的 Makefile，并且您希望在包含 Makefile 的子目录上运行 make。那么可以通过这个来做到这一点 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">subsystem</span><span class="token punctuation">:</span>        cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span>或者，等效的 −<span class="token target symbol">subsystem</span><span class="token punctuation">:</span>        <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C subdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以基于这个例子来编写递归<code>make</code>命令，但是你需要知道它们（每个子系统的 Makefile）是如何工作的、为什么它能工作，以及子 make 如何与顶层 make 相关联。</p><h2 id="将变量传达给子-make"><a href="#将变量传达给子-make" class="headerlink" title="将变量传达给子 make"></a>将变量传达给子 make</h2><p><code>make</code>通过明确的请求可以将顶层 make 的变量值传递给子 make 的环境。这些变量在子 make 中被定义为默认值。你不能重写被子 make 的 Makefile 所使用的变量（除非你执行的时候使用`-e’ 开关）。</p><p>为了传递或导出变量，<code>make</code>会将该变量和它的值添加到每个运行命令的环境中。而子 make 会顺序的根据环境来初始化它的变量表。</p><p>特殊变量 SHELL 和 MAKEFLAGS 总是被导出（除非你明确的阻止）。只要设置了 MAKEFILES 的内容，它就会被导出。</p><p>如果您想要将指定变量导出到子 make 中，请使用 <strong>export</strong> 指令，如图所示 -</p><pre class="line-numbers language-none"><code class="language-none">export variable ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果您想阻止变量被导出，请使用 <strong>unexport</strong> 指令，如图所示 -</p><pre class="line-numbers language-none"><code class="language-none">unexport variable ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="变量-MAKEFILES"><a href="#变量-MAKEFILES" class="headerlink" title="变量 MAKEFILES"></a>变量 MAKEFILES</h2><p>如果定义了环境变量MAKEFILES，则将<code>make</code>其值视为其他makefile的名称列表（以空格分隔），以便在其他makefile之前读取。这与include指令非常相似：搜索各种目录以查找这些文件。</p><p>MAKEFILES的主要用途是在递归调用之间进行通信<code>make</code>。</p><h2 id="引入不同目录的头文件"><a href="#引入不同目录的头文件" class="headerlink" title="引入不同目录的头文件"></a>引入不同目录的头文件</h2><p>如果你将头文件放在不同的目录中并且在在不同的目录中运行<code>make</code>，则需要提供头文件的路径。这可以在 Makefile 中使用 **-I **选项完成。假设 functions.h 文件在 <code>/home/tutorialspoint/</code>  头文件夹中可用，其余文件在 <code>/home/tutorialspoint/src/</code> 文件夹中可用，则 Makefile 可以按如下方式编写：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">INCLUDES <span class="token operator">=</span> -I <span class="token string">"/home/tutorialspoint/header"</span>CC <span class="token operator">=</span> gccLIBS <span class="token operator">=</span>  -lmCFLAGS <span class="token operator">=</span> -g -WallOBJ <span class="token operator">=</span>  main.o factorial.o hello.o<span class="token target symbol">hello</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJ<span class="token punctuation">}</span>   <span class="token variable">$</span><span class="token punctuation">{</span>CC<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>CFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>INCLUDES<span class="token punctuation">}</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>LIBS<span class="token punctuation">}</span><span class="token target symbol">.cpp.o</span><span class="token punctuation">:</span>   <span class="token variable">$</span><span class="token punctuation">{</span>CC<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>CFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>INCLUDES<span class="token punctuation">}</span> -c <span class="token variable">$&lt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将更多文本附加到变量"><a href="#将更多文本附加到变量" class="headerlink" title="将更多文本附加到变量"></a>将更多文本附加到变量</h2><p>对已经定义的变量的值添加更多文本通常很有用。你可以用 `+=’  来做到这一点，如下所示：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">+=</span> another.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它采用变量对象的值，并向其添加文本 “another.o”（前面有一个空格）。因此 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> main.o hello.o factorial.oobjects <span class="token operator">+=</span> another.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将对象设置为`main.o hello.o factorial.o another.o’。</p><p>使用 ‘+=’ 类似于：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> main.o hello.o factorial.oobjects <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> another.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Makefile-中的多行写法"><a href="#Makefile-中的多行写法" class="headerlink" title="Makefile 中的多行写法"></a>Makefile 中的多行写法</h2><p>如果你觉得 Makefile 中某一行太长，那么你可以使用反斜线 “\” 来分隔你的行，如下所示 -</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">OBJ <span class="token operator">=</span>  main.o factorial.o \    hello.o等同于OBJ <span class="token operator">=</span>  main.o factorial.o hello.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Makefile-别名"><a href="#Makefile-别名" class="headerlink" title="Makefile 别名"></a>Makefile 别名</h2><p>如果本地目录中已经有了名称为“Makefile” 的 Makefile，那么只需在命令行下输入 make 回车它就会运行 Makefile 文件。但是，如果你的 Makefile 是其他名字，可以使用以下命令来运行 -</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token parameter variable">-f</span> your-makefile-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Makefile-例子"><a href="#Makefile-例子" class="headerlink" title="Makefile - 例子"></a>Makefile - 例子</h1><p>这是用于编译 hello 程序的 Makefile 的一个完整例子。该程序由三个文件 main.cpp、factorial.cpp 和 hello.cpp 组成。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># 定义需要的宏</span>SHELL <span class="token operator">=</span> /bin/shOBJS <span class="token operator">=</span>  main.o factorial.o hello.oCFLAG <span class="token operator">=</span> -Wall -gCC <span class="token operator">=</span> gccINCLUDE <span class="token operator">=</span>LIBS <span class="token operator">=</span> -lm<span class="token target symbol">hello</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">{</span>OBJ<span class="token punctuation">}</span>   <span class="token variable">$</span><span class="token punctuation">{</span>CC<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>CFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>INCLUDES<span class="token punctuation">}</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>LIBS<span class="token punctuation">}</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>   -rm -f *.o core *.core<span class="token target symbol">.cpp.o</span><span class="token punctuation">:</span>   <span class="token variable">$</span><span class="token punctuation">{</span>CC<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>CFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>INCLUDES<span class="token punctuation">}</span> -c <span class="token variable">$&lt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，你可以使用<code>make</code>来构建的你的程序 <strong>hello</strong> 。如果运行<code>make clean</code>则会删除当前目录中所有的 .o 文件和 .core 文件。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile-Tutorial-zh-CN</title>
      <link href="/blog/1ba862a3.html"/>
      <url>/blog/1ba862a3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Makefiles-简介"><a href="#Makefiles-简介" class="headerlink" title="Makefiles 简介"></a>Makefiles 简介</h2><p>Makefiles 用于帮助决定一个大型程序的哪些部分需要重新编译。在绝大多数情况下，需要编译的只是 C 或 C++ 文件。其他语言通常有它们自己的一套与 Make 用途类似的工具。Make 的用途并不局限于编程，当你需要根据哪些文件发生了变更来运行一系列指令时也可以使用它。而本教程将只关注 C/C++ 编译用例。</p><p>这里有一个你可能会使用 Make 进行构建的依赖关系示例图。如有任何文件的依赖项发生了改变，那么该文件就会被重新编译。</p><p><img src="/../../../images/linux/make/dependency_graph.png"></p><h2 id="Make-的替代品"><a href="#Make-的替代品" class="headerlink" title="Make 的替代品"></a>Make 的替代品</h2><p>除了 Make，还有一些比较流行的构建系统可选，像 <a href="https://scons.org/">SCon</a>、<a href="https://cmake.org/">CMake</a>、<a href="https://bazel.build/">Bazel</a> 和 <a href="https://ninja-build.org/">Ninja</a> 等。一些代码编辑器，像 <a href="https://visualstudio.microsoft.com/">Microsoft Visual Studio</a>，内置了它们自己的构建工具。Java 语言的构建工具有 <a href="https://ant.apache.org/">Ant</a>、<a href="https://maven.apache.org/what-is-maven.html">Maven</a> 和 <a href="https://gradle.org/">Gradle</a> 可选，其他语言像 Go 和 Rust 则都有它们自己的构建工具。</p><p>像 Python、Ruby 和 JavaScript 这样的解释型语言是不需要类似 Makefiles 的东西的。Makefiles 的目标是基于哪些文件发生了变化来编译需要被编译的一切文件。但是，当解释型语言的文件发生了变化，是不需要重新编译的，程序运行时会使用最新版的源码文件。</p><h2 id="Make-的不同实现与版本"><a href="#Make-的不同实现与版本" class="headerlink" title="Make 的不同实现与版本"></a>Make 的不同实现与版本</h2><p>虽然 Make 有多种实现，但本指南的大部分内容都是版本间无差异的。然而，需要说明的是，本指南是专门为 GNU Make 编写的，这也是 Linux 与 macOS 平台上的标准实现。文中所有的例子在 Make 的版本 3 和版本 4 上都能很好地工作，除了一些细微的差别外，它们的行为表现也几乎一致。</p><h2 id="如何运行示例"><a href="#如何运行示例" class="headerlink" title="如何运行示例"></a>如何运行示例</h2><p>为了运行文中示例，你需要一个安装了 <code>make</code> 的终端。对于每一个例子，只需要把它的内容放在一个名为 <code>Makefile</code> 的文件中，再把该文件放在运行 <code>make</code> 命令的目录下就行了。让我们从最简单的一个 Makefile 开始吧：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">hello</span><span class="token punctuation">:</span>    echo <span class="token string">"hello world"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以下是运行上述示例的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span><span class="token builtin class-name">echo</span> <span class="token string">"hello world"</span>hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>是的，就是这样！如果你还心存困惑，这儿有一份介绍了完整步骤的视频，同时它还描述了 Makefiles 的基本结构。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/zeEMISsjO38" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><h2 id="Makefile-语法"><a href="#Makefile-语法" class="headerlink" title="Makefile 语法"></a>Makefile 语法</h2><p>Makefile 文件由一系列的 <em>规则 (rules)</em> 组成，一个规则类似下面这样：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">targets</span><span class="token punctuation">:</span> prerequisites    command    command    command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>targets</code> 指的是文件名称，多个文件名以空格分隔。通常，一个规则只对应一个文件。</li><li><code>commands</code> 通常是一系列用于制作（make）一个或多个目标（targets）的步骤。它们 _需要以一个制表符开头_，而不是空格。</li><li><code>prerequisites</code> 也是文件名称，多个文件名以空格分隔。在运行目标（targets）的 <code>commands</code> 之前，要确保这些文件是存在的。它们也被称为 _依赖_。</li></ul><h2 id="新手示例"><a href="#新手示例" class="headerlink" title="新手示例"></a>新手示例</h2><p>下面的 Makefile 有 3 个分离的 _规则 (rules)_。当你在终端运行 <code>make blah</code> 时，它会通过一系列的步骤构建一个名为 <code>blah</code> 的程序：</p><ul><li><code>blah</code> 给 <code>make</code> 提供了构建目标（target）的名称，所以它会在 makefile 中优先被 <code>make</code> 程序搜索</li><li>构建系统发现 <code>blah</code> 依赖 <code>blah.o</code>，所以 <code>make</code> 开始搜索 <code>blah.o</code> 这个目标</li><li><code>blah.o</code> 又依赖 <code>blah.c</code>，所以 <code>make</code> 又开始搜索 <code>blah.c</code> 这个目标</li><li><code>blah.c</code> 没有依赖，直接运行 <code>echo</code> 命令</li><li>接着运行 <code>cc -c</code> 命令，因为 <code>blah.o</code> 的依赖的所有 <code>commands</code> 都执行完了</li><li>同理，接着运行顶部的 <code>cc</code> 命令</li><li>就这样，一个编译好的 C 程序 <code>blah</code> 就诞生了</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">blah</span><span class="token punctuation">:</span> blah.o    cc blah.o -o blah <span class="token comment"># Runs third</span><span class="token target symbol">blah.o</span><span class="token punctuation">:</span> blah.c    cc -c blah.c -o blah.o <span class="token comment"># Runs second</span><span class="token target symbol">blah.c</span><span class="token punctuation">:</span>    echo <span class="token string">"int main() { return 0; }"</span> &gt; blah.c <span class="token comment"># Runs first</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><note type="tip" label="译者注"><p><code>-c</code> 选项只编译不链接，<code>-o file</code> 将其前面命令的输出内容放在文件 <em>file</em> 中。</p><p>详情可参阅：<a href="https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options">https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options</a></p></note><p>下面的这个 makefile 只有一个目标，叫作 <code>some_file</code>。因为默认的目标就是第一个目标，所以，在执行 <code>make</code> 命令时，<code>some_file</code> 目标下的命令会运行。👇</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">some_file</span><span class="token punctuation">:</span>    echo <span class="token string">"This line will always print"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若应用下面这个 makefile，在第一次构建时将创建文件 <em>some_file</em>，第二次系统就会注意到该目标文件已经创建过了，结果就会得到这样的提示信息：*make: ‘some_file’ is up to date.*。👇</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">some_file</span><span class="token punctuation">:</span>    echo <span class="token string">"This line will only print once"</span>    touch some_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>敲黑板！目标 <code>some_file</code> 依赖 <code>other_file</code>。当我们运行 <code>make</code> 时，默认目标（即 <code>some_file</code>，因为它是第一个）会被“召唤”。构建系统首先查看目标的 <em>依赖</em> 列表，若其中有旧的目标文件，构建系统首先会为这些依赖执行目标构建，此后才轮到默认目标。第二次执行 <code>make</code> 时，默认目标和依赖目标下的命令都不会再运行了，因为二者都存在了。👇</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">some_file</span><span class="token punctuation">:</span> other_file    echo <span class="token string">"This will run second, because it depends on other_file"</span>    touch some_file<span class="token target symbol">other_file</span><span class="token punctuation">:</span>    echo <span class="token string">"This will run first"</span>    touch other_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而下面这个 makefile 中的两个目标每次构建都会运行，因为 <code>some_file</code> 依赖的 <code>other_file</code> 从未被创建过。👇</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">some_file</span><span class="token punctuation">:</span> other_file    touch some_file<span class="token target symbol">other_file</span><span class="token punctuation">:</span>    echo <span class="token string">"nothing"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><note type="tip" label="译者注"><p>👆 类似上面 <code>other_file</code> 这样的目标就是俗称的 <em>伪目标</em> 或 _虚拟目标_。</p></note><p><code>clean</code> 经常被用来作为移除其他目标的输出的目标名称，但是在 <code>make</code> 看来它并非是一个特殊用词。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">some_file</span><span class="token punctuation">:</span>     touch some_file<span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -f some_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在 Makefile 中，变量的值类型只能是字符串。下面是一个使用变量的例子：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">files <span class="token operator">=</span> file1 file2<span class="token target symbol">some_file</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span>    echo <span class="token string">"Look at this variable: "</span> <span class="token variable">$</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span>    touch some_file<span class="token target symbol">file1</span><span class="token punctuation">:</span>    touch file1<span class="token target symbol">file2</span><span class="token punctuation">:</span>    touch file2<span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -f file1 file2 some_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用变量的语法是：<code>${}</code> 或 <code>$()</code>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x <span class="token operator">=</span> dude<span class="token target symbol">all</span><span class="token punctuation">:</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    echo <span class="token variable">$</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span>    <span class="token comment"># Bad practice, but works</span>    echo <span class="token variable">$x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><h2 id="目标-all"><a href="#目标-all" class="headerlink" title="目标 all"></a>目标 <code>all</code></h2><p>想制作多个目标，并且一次运行全部？那就使用 <code>all</code> 目标吧。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span> one two three<span class="token target symbol">one</span><span class="token punctuation">:</span>    touch one<span class="token target symbol">two</span><span class="token punctuation">:</span>    touch two<span class="token target symbol">three</span><span class="token punctuation">:</span>    touch three<span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -f one two three<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><note type="tip" label="译者注"><p>关于目标 <code>all</code> 的更多信息可参阅 <a href="https://stackoverflow.com/questions/2514903/what-does-all-stand-for-in-a-makefile">Stack Overflow - What does “all” stand for in a makefile?</a></p></note><h2 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h2><p>当一个规则（rule）有多个目标时，那么对于每个目标，这个规则下面的 commands 都会运行一次。</p><p><code>$@</code> 是一个指代目标名称的 <a href="automatic-variables-and-wildcards#%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F">自动变量</a>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span> f1.o f2.o<span class="token target symbol">f1.o f2.o</span><span class="token punctuation">:</span>    echo <span class="token variable">$@</span><span class="token comment"># Equivalent to:</span><span class="token comment"># f1.o</span><span class="token comment">#     echo $@</span><span class="token comment"># f2.o</span><span class="token comment">#     echo $@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="自动变量和通配符"><a href="#自动变量和通配符" class="headerlink" title="自动变量和通配符"></a>自动变量和通配符</h1><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符 *"></a>通配符 <code>*</code></h2><p>在 Make 中，<code>%</code> 和 <code>*</code> 都叫作通配符，但是它们是两个完全不同的东西。<code>*</code> 会搜索你的文件系统来匹配文件名。我建议你应该一直使用 <code>wildcard</code> 函数来包裹它，要不然你可能会掉入下述的常见陷阱中。真是搞不明白，不用 <code>wildcard</code> 包裹的 <code>*</code> 除了能给人徒增迷惑，还有什么可取之处。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Print out file information about every .c file</span><span class="token target symbol">print</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span>    ls -la  <span class="token variable">$?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>*</code> 可以用在 <code>targets</code>、<code>prerequisites</code> 以及 <code>wildcard</code> 函数中。</p><p><note type="danger"><code>*</code> 不能直接用在变量定义中。</note></p><p><note type="danger">当 <code>*</code> 匹配不到文件时，它将保持原样（除非被 <code>wildcard</code> 函数包裹）。</note></p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">thing_wrong <span class="token operator">:=</span> *.o <span class="token comment"># Don't do this! '*' will not get expanded</span>thing_right <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.o<span class="token punctuation">)</span><span class="token target symbol">all</span><span class="token punctuation">:</span> one two three four<span class="token comment"># Fails, because $(thing_wrong) is the string "*.o"</span><span class="token target symbol">one</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>thing_wrong<span class="token punctuation">)</span><span class="token comment"># Stays as *.o if there are no files that match this pattern :(</span><span class="token target symbol">two</span><span class="token punctuation">:</span> *.o <span class="token comment"># Works as you would expect! In this case, it does nothing.</span><span class="token target symbol">three</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>thing_right<span class="token punctuation">)</span><span class="token comment"># Same as rule three</span><span class="token target symbol">four</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通配符-1"><a href="#通配符-1" class="headerlink" title="通配符 %"></a>通配符 <code>%</code></h2><p>通配符 <code>%</code> 虽然确实很有用，但是由于它的可用场景多种多样，着实有点让人摸不着头脑。</p><ul><li>在“匹配”模式下使用时，它匹配字符串中的一个或多个字符，这种匹配被称为词干（stem）匹配。</li><li>在“替换”模式下使用时，它会替换匹配到的词干。</li><li><code>%</code> 大多用在规则定义以及一些特定函数中。</li></ul><p>有关它的用法示例可参阅以下章节：</p><ul><li><a href="fancy-rules#%E9%9D%99%E6%80%81%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99">静态模式规则</a></li><li><a href="fancy-rules#%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99">模式规则</a></li><li><a href="functions#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2">字符串替换</a></li><li><a href="other-features#vpath-%E6%8C%87%E4%BB%A4"><code>vpath</code> 指令</a></li></ul><h2 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h2><p>虽然存在很多 <a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">自动变量</a>，但是经常用到的没几个：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">hey</span><span class="token punctuation">:</span> one two    <span class="token comment"># Outputs "hey", since this is the first target</span>    echo <span class="token variable">$@</span>    <span class="token comment"># Outputs all prerequisites newer than the target</span>    echo <span class="token variable">$?</span>    <span class="token comment"># Outputs all prerequisites</span>    echo <span class="token variable">$^</span>    touch hey<span class="token target symbol">one</span><span class="token punctuation">:</span>    touch one<span class="token target symbol">two</span><span class="token punctuation">:</span>    touch two<span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -f hey one two<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="各种规则"><a href="#各种规则" class="headerlink" title="各种规则"></a>各种规则</h1><h2 id="隐式规则"><a href="#隐式规则" class="headerlink" title="隐式规则"></a>隐式规则</h2><p>Make 钟爱 C 编译，它每次表达爱意时，都会做出一些“迷惑行为”。其中最令人迷惑的部分可能就是它的那些魔法般的规则了，Make 称之为“隐式规则”。我个人不认同这个设计方案，也不推荐使用它们。然而即便如此，它们也被经常使用，所以了解一下它们也是很有用处的。下面列出了隐式规则：</p><ul><li>编译 C 程序时：使用 <code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code> 形式的命令，<code>n.o</code> 会由 <code>n.c</code> 自动生成。</li><li>编译 C++ 程序时：使用 <code>$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)</code> 形式的命令，<code>n.o</code> 会由 <code>n.cc</code> 或 <code>n.pp</code> 自动生成。</li><li>链接单个目标文件时：通过运行 <code>$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)</code> 命令，<code>n</code> 会由 <code>n.o</code> 自动生成。</li></ul><p>上述隐式规则使用的变量的含义如下所示：</p><ul><li><code>CC</code>：编译 C 程序的程序，默认是 <code>cc</code></li><li><code>CXX</code>：编译 C++ 程序的程序，默认是 <code>G++</code></li><li><code>CFLAGS</code>：提供给 C 编译器的额外标志</li><li><code>CXXFLAGS</code>：提供给 C++ 编译器的额外标志</li><li><code>CPPFLAGS</code>：提供给 C 预处理器的额外标志</li><li><code>LDFLAGS</code>：当编译器应该调用链接器时提供给编译器的额外标志</li></ul><p>现在就让我们来看一下如何在不明确告诉 Make 该如何进行编译的情况下构件一个 C 程序。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">CC <span class="token operator">=</span> gcc <span class="token comment"># Flag for implicit rules</span>CFLAGS <span class="token operator">=</span> -g <span class="token comment"># Flag for implicit rules. Turn on debug info</span><span class="token comment"># Implicit rule #1: blah is built via the C linker implicit rule</span><span class="token comment"># Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists</span><span class="token target symbol">blah</span><span class="token punctuation">:</span> blah.o<span class="token target symbol">blah.c</span><span class="token punctuation">:</span>    echo <span class="token string">"int main() { return 0; }"</span> &gt; blah.c<span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -f blah*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h2><p>静态模式规则是另一种可以在 Makefile 文件中“少废笔墨”的方式，但是我认为它更加有用且更容易让人理解。其语法如下：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">targets ...</span><span class="token punctuation">:</span> target-pattern<span class="token punctuation">:</span> prereq-patterns ...   commands<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它的本质是：给定的目标 <code>target</code> 由 <code>target-pattern</code> 在 <code>targets</code> 中匹配得到（利用通配符 <code>%</code>）。匹配到的内容被称为 _词干 (stem)_。然后，将词干替换到 <code>prereq-pattern</code> 中去，并以此生成目标的 <code>prerequisites</code> 部分。</p><p>静态模式规则的一个典型用例就是把 <code>.c</code> 文件编译为 <code>.o</code> 文件。下面是 <em>手动</em> 方式：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> foo.o bar.o all.o<span class="token target symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token comment"># These files compile via implicit rules</span><span class="token target symbol">foo.o</span><span class="token punctuation">:</span> foo.c<span class="token target symbol">bar.o</span><span class="token punctuation">:</span> bar.c<span class="token target symbol">all.o</span><span class="token punctuation">:</span> all.c<span class="token target symbol">all.c</span><span class="token punctuation">:</span>    echo <span class="token string">"int main() { return 0; }"</span> &gt; all.c<span class="token target symbol">%.c</span><span class="token punctuation">:</span>    touch <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -f *.c *.o all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面则是使用了静态模式的一种 _更加有效的方式_：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> foo.o bar.o all.o<span class="token target symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token comment"># These files compile via implicit rules</span><span class="token comment"># Syntax - targets ...: target-pattern: prereq-patterns ...</span><span class="token comment"># In the case of the first target, foo.o, the target-pattern matches foo.o and sets the "stem" to be "foo".</span><span class="token comment"># It then replaces the '%' in prereq-patterns with that stem</span><span class="token target symbol"><span class="token variable">$</span>(objects)</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c<span class="token target symbol">all.c</span><span class="token punctuation">:</span>    echo <span class="token string">"int main() { return 0; }"</span> &gt; all.c<span class="token target symbol">%.c</span><span class="token punctuation">:</span>    touch <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -f *.c *.o all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态模式规则与过滤器"><a href="#静态模式规则与过滤器" class="headerlink" title="静态模式规则与过滤器"></a>静态模式规则与过滤器</h2><p>虽然函数稍后才会介绍到，但是我会预先向你展示你可以用函数来做什么。函数 <code>filter</code> 可以用在静态模式规则中来匹配正确的文件。在下面这个例子中，我编造了 <code>.raw</code> 和 <code>.result</code> 文件扩展名。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">obj_files <span class="token operator">=</span> foo.result bar.o lose.osrc_files <span class="token operator">=</span> foo.raw bar.c lose.c<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> all<span class="token target symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj_files<span class="token punctuation">)</span><span class="token target symbol"><span class="token variable">$</span>(filter %.o,<span class="token variable">$</span>(obj_files))</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c    echo <span class="token string">"target: $@ prereq: $&lt;"</span><span class="token target symbol"><span class="token variable">$</span>(filter %.result,<span class="token variable">$</span>(obj_files))</span><span class="token punctuation">:</span> %.result<span class="token punctuation">:</span> %.raw    echo <span class="token string">"target: $@ prereq: $&lt;"</span> <span class="token target symbol">%.c %.raw</span><span class="token punctuation">:</span>    touch <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -f <span class="token variable">$</span><span class="token punctuation">(</span>src_files<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h2><p>模式规则虽然常用，但是很令人迷惑。你可以以两种方式来看待它们：</p><ul><li>一个定义你自己的隐式规则的方式</li><li>一个静态模式规则的简化形式</li></ul><p>先看个例子吧：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Define a pattern rule that compiles every .c file into a .o file</span><span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.c        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>模式规则在目标中包含了一个 <code>%</code>，这个 <code>%</code> 匹配任意非空字符串，其他字符匹配它们自己。一个模式规则的 <code>prerequisite</code> 中的 <code>%</code> 表示目标中 <code>%</code> 匹配到的同一个词干。</p><note type="tip" label="译者注"><p>自动变量 <code>$&lt;</code> 表示第一个 <code>prerequisite</code>。</p></note><p>另一个例子：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Define a pattern rule that has no pattern in the prerequisites.</span><span class="token comment"># This just creates empty .c files when needed.</span><span class="token target symbol">%.c</span><span class="token punctuation">:</span>   touch <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双冒号规则"><a href="#双冒号规则" class="headerlink" title="双冒号规则"></a>双冒号规则</h2><p>双冒号规则虽然很少用到，但是它能为同一个目标定义多个规则。如果换为单冒号的话，系统会输出警告，并且只有第 2 个规则定义的命令会运行。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span> blah<span class="token target symbol">blah</span><span class="token punctuation">:</span><span class="token punctuation">:</span>    echo <span class="token string">"hello"</span><span class="token target symbol">blah</span><span class="token punctuation">:</span><span class="token punctuation">:</span>    echo <span class="token string">"hello again"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="命令与执行"><a href="#命令与执行" class="headerlink" title="命令与执行"></a>命令与执行</h1><h2 id="回显-x2F-静默命令"><a href="#回显-x2F-静默命令" class="headerlink" title="回显/静默命令"></a>回显/静默命令</h2><p>在一个命令前添加一个 <code>@</code> 符号就会阻止该命令输出内容。</p><p>你也可以使用 <code>make -s</code> 在每个命令前添加 <code>@</code>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>     <span class="token operator">@</span>echo <span class="token string">"This make line will not be printed"</span>    echo <span class="token string">"But this will"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="变量（第-2-部分）"><a href="#变量（第-2-部分）" class="headerlink" title="变量（第 2 部分）"></a>变量（第 2 部分）</h1><h2 id="变量类型和修改"><a href="#变量类型和修改" class="headerlink" title="变量类型和修改"></a>变量类型和修改</h2><p>变量的类型有两种：</p><ul><li>递归变量（使用 <code>=</code>）- 只有在命令执行时才查找变量，而不是在定义时</li><li>简单的扩展变量（使用 <code>:=</code>）- 就像普通的命令式编程一样——只有当前已经定义的变量才会得到扩展</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Recursive variable. This will print "later" below</span>one <span class="token operator">=</span> one <span class="token variable">$</span><span class="token punctuation">{</span>later_variable<span class="token punctuation">}</span><span class="token comment"># Simply expanded variable. This will not print "later" below</span>two <span class="token operator">:=</span> two <span class="token variable">$</span><span class="token punctuation">{</span>later_variable<span class="token punctuation">}</span>later_variable <span class="token operator">=</span> later<span class="token target symbol">all</span><span class="token punctuation">:</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩展变量（使用 <code>:=</code>）使得你可以在一个变量的基础上追加内容，递归变量则会陷入死循环。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">one <span class="token operator">=</span> hello<span class="token comment"># one gets defined as a simply expanded variable (:=) and thus can handle appending</span>one <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>one<span class="token punctuation">}</span> there<span class="token target symbol">all</span><span class="token punctuation">:</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>?=</code> 用于当变量还没被设置值时给它设置值，反之则忽略。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">one <span class="token operator">=</span> helloone <span class="token operator">?=</span> will not be settwo <span class="token operator">?=</span> will be set<span class="token target symbol">all</span><span class="token punctuation">:</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量值尾部的空格不会被删除，但开头的空格会被删除。想要一个值为单个空格的变量请使用 <code>$(nullstring)</code>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">with_spaces <span class="token operator">=</span> hello   <span class="token comment"># with_spaces has many spaces after "hello"</span>after <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>with_spaces<span class="token punctuation">)</span>therenullstring <span class="token operator">=</span>space <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span> <span class="token comment"># Make a variable with a single space.</span><span class="token target symbol">all</span><span class="token punctuation">:</span>    echo <span class="token string">"$(after)"</span>    echo start<span class="token string">"$(space)"</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个未定义的变量实际上是一个空字符串。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>    <span class="token comment"># Undefined variables are just empty strings!</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>nowhere<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>+=</code> 用来追加变量的值：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> startfoo <span class="token operator">+=</span> more<span class="token target symbol">all</span><span class="token punctuation">:</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="functions#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2">字符串替换</a> 也是一个常见且有用的修改变量的方式。其他相关可参阅 <a href="https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions">文本函数</a> 与 <a href="https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions">文件名函数</a>。</p><h2 id="命令行参数与覆盖"><a href="#命令行参数与覆盖" class="headerlink" title="命令行参数与覆盖"></a>命令行参数与覆盖</h2><p>你可以通过 <code>override</code> 来覆盖来自命令行的变量。假使我们使用下面的 makefile 执行了这样一条命令 <code>make option_one=hi</code>，那么变量 <code>option_one</code> 的值就会被覆盖掉。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Overrides command line arguments</span><span class="token keyword">override</span> option_one <span class="token operator">=</span> did_override<span class="token comment"># Does not override command line arguments</span>option_two <span class="token operator">=</span> not_override<span class="token target symbol">all</span><span class="token punctuation">:</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>option_one<span class="token punctuation">)</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>option_two<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令列表与-define"><a href="#命令列表与-define" class="headerlink" title="命令列表与 define"></a>命令列表与 <code>define</code></h2><p><code>define</code> 实际上就是一个命令列表，它与函数 <code>define</code> 没有任何关系。这里请注意，它与用分号分隔多个命令的场景有点不同，因为前者如预期的那样，每条命令都是在一个单独的 shell 中运行的。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">one <span class="token operator">=</span> <span class="token keyword">export</span> blah<span class="token operator">=</span><span class="token string">"I was set!"</span><span class="token punctuation">;</span> echo <span class="token variable">$$blah</span><span class="token keyword">define</span> two<span class="token keyword">export</span> blah<span class="token operator">=</span>setecho <span class="token variable">$$blah</span><span class="token keyword">endef</span><span class="token comment"># One and two are different.</span><span class="token target symbol">all</span><span class="token punctuation">:</span>     <span class="token operator">@</span>echo <span class="token string">"This prints 'I was set'"</span>    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span>    <span class="token operator">@</span>echo <span class="token string">"This does not print 'I was set' because each command runs in a separate shell"</span>    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特定目标的变量"><a href="#特定目标的变量" class="headerlink" title="特定目标的变量"></a>特定目标的变量</h2><p>我们可以为特定目标分配变量。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span> one <span class="token operator">=</span> cool<span class="token target symbol">all</span><span class="token punctuation">:</span> <span class="token target symbol">    echo one is defined</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token target symbol">other</span><span class="token punctuation">:</span><span class="token target symbol">    echo one is nothing</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特定模式的变量"><a href="#特定模式的变量" class="headerlink" title="特定模式的变量"></a>特定模式的变量</h2><p>我们可以为特定的目标 <em>模式</em> 分配变量。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%.c</span><span class="token punctuation">:</span> one <span class="token operator">=</span> cool<span class="token target symbol">blah.c</span><span class="token punctuation">:</span> <span class="token target symbol">    echo one is defined</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token target symbol">other</span><span class="token punctuation">:</span><span class="token target symbol">    echo one is nothing</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h2><p>每个命令都运行在一个新的 shell 中（或者说运行效果等同于运行在一个新 shell 中）。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>     cd ..    <span class="token comment"># The cd above does not affect this line, because each command is effectively run in a new shell</span>    echo `pwd`    <span class="token comment"># This cd command affects the next because they are on the same line</span>    cd ..<span class="token punctuation">;</span>echo `pwd`    <span class="token comment"># Same as above</span>    cd ..<span class="token punctuation">;</span> \    echo `pwd`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="默认的-Shell"><a href="#默认的-Shell" class="headerlink" title="默认的 Shell"></a>默认的 Shell</h2><p>系统默认的 shell 是 <code>/bin/sh</code>，你可以通过改变 <code>SHELL</code> 变量的值来改变它：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">SHELL<span class="token operator">=</span>/bin/bash<span class="token target symbol">cool</span><span class="token punctuation">:</span>    echo <span class="token string">"Hello from bash"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="错误处理：-k，-i-和"><a href="#错误处理：-k，-i-和" class="headerlink" title="错误处理：-k，-i 和 -"></a>错误处理：<code>-k</code>，<code>-i</code> 和 <code>-</code></h2><p><code>make -k</code> 会使得即便遇到错误，构建也会继续执行下去。如果你想一次查看 Make 的所有错误，这会很有帮助。</p><p>在一个命令前添加 <code>-</code> 会抑制错误。</p><p><code>make -i</code> 等同于在每个命令前添加 <code>-</code>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">one</span><span class="token punctuation">:</span>    <span class="token comment"># This error will be printed but ignored, and make will continue to run</span>    -false    touch one<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="中断或杀死-make"><a href="#中断或杀死-make" class="headerlink" title="中断或杀死 make"></a>中断或杀死 <code>make</code></h2><p><note>如果你在 <code>make</code> 的过程中，使用了 <code>ctrl+c</code>，那么刚刚制作的新目标会被删除。</note></p><h2 id="make-的递归用法"><a href="#make-的递归用法" class="headerlink" title="make 的递归用法"></a><code>make</code> 的递归用法</h2><p>为了递归应用一个 makefile，请使用 <code>$(MAKE)</code> 而不是 <code>make</code>，因为它会为你传递构建标志，而使用了 <code>$(MAKE)</code> 变量的这一行命令不会应用这些标志。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">new_contents <span class="token operator">=</span> <span class="token string">"hello:\n\ttouch inside_file"</span><span class="token target symbol">all</span><span class="token punctuation">:</span>    mkdir -p subdir    printf <span class="token variable">$</span><span class="token punctuation">(</span>new_contents<span class="token punctuation">)</span> <span class="token operator">|</span> sed -e <span class="token string">'s/^ //'</span> &gt; subdir/makefile    cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -rf subdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在递归-make-中使用-export"><a href="#在递归-make-中使用-export" class="headerlink" title="在递归 make 中使用 export"></a>在递归 make 中使用 <code>export</code></h2><p>指令 <code>export</code> 携带了一个变量，并且对子 <code>make</code> 命令可见。在下面的例子中，变量 <code>cooly</code> 被导出以便在子目录中的 makefile 可以使用它。</p><p><note><code>export</code> 的语法与 sh 相同，但二者并不相关（虽然功能类似）。</note></p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">new_contents <span class="token operator">=</span> <span class="token string">"hello:\n\\techo \$$(cooly)"</span><span class="token target symbol">all</span><span class="token punctuation">:</span>    mkdir -p subdir    echo <span class="token variable">$</span><span class="token punctuation">(</span>new_contents<span class="token punctuation">)</span> <span class="token operator">|</span> sed -e <span class="token string">'s/^ //'</span> &gt; subdir/makefile    <span class="token operator">@</span>echo <span class="token string">"---MAKEFILE CONTENTS---"</span>    <span class="token operator">@</span>cd subdir &amp;&amp; cat makefile    <span class="token operator">@</span>echo <span class="token string">"---END MAKEFILE CONTENTS---"</span>    cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span><span class="token comment"># Note that variables and exports. They are set/affected globally.</span>cooly <span class="token operator">=</span> <span class="token string">"The subdirectory can see me!"</span><span class="token keyword">export</span> cooly<span class="token comment"># This would nullify the line above: unexport cooly</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -rf subdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 shell 中运行的变量也需要导出。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">one<span class="token operator">=</span>this will only work locally<span class="token keyword">export</span> two<span class="token operator">=</span>we can run subcommands with this<span class="token target symbol">all</span><span class="token punctuation">:</span>     <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span>    <span class="token operator">@</span>echo <span class="token variable">$$one</span>    <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span>    <span class="token operator">@</span>echo <span class="token variable">$$two</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>.EXPORT_ALL_VARIABLES</code> 可以为你导出所有变量。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.EXPORT_ALL_VARIABLES</span><span class="token punctuation">:</span>new_contents <span class="token operator">=</span> <span class="token string">"hello:\n\techo \$$(cooly)"</span>cooly <span class="token operator">=</span> <span class="token string">"The subdirectory can see me!"</span><span class="token comment"># This would nullify the line above: unexport cooly</span><span class="token target symbol">all</span><span class="token punctuation">:</span>    mkdir -p subdir    echo <span class="token variable">$</span><span class="token punctuation">(</span>new_contents<span class="token punctuation">)</span> <span class="token operator">|</span> sed -e <span class="token string">'s/^ //'</span> &gt; subdir/makefile    <span class="token operator">@</span>echo <span class="token string">"---MAKEFILE CONTENTS---"</span>    <span class="token operator">@</span>cd subdir &amp;&amp; cat makefile    <span class="token operator">@</span>echo <span class="token string">"---END MAKEFILE CONTENTS---"</span>    cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -rf subdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="给-make-传递参数"><a href="#给-make-传递参数" class="headerlink" title="给 make 传递参数"></a>给 <code>make</code> 传递参数</h2><p><a href="http://www.gnu.org/software/make/manual/make.html#Options-Summary">这里</a> 很好地列出了可以用于 <code>make</code> 的选项。看下 <code>--dry-run</code>，<code>--touch</code> 和 <code>--old-file</code> 选项吧。</p><p>你可以同时传递多个目标给 <code>make</code>，例如 <code>make clean run test</code> 会先后运行 <code>clean</code>、<code>run</code>、<code>test</code>。</p><h1 id="Makefiles-的条件判断"><a href="#Makefiles-的条件判断" class="headerlink" title="Makefiles 的条件判断"></a>Makefiles 的条件判断</h1><h2 id="if-x2F-else"><a href="#if-x2F-else" class="headerlink" title="if/else"></a>if/else</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">=</span> ok<span class="token target symbol">all</span><span class="token punctuation">:</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>, ok<span class="token punctuation">)</span>    echo <span class="token string">"foo equals ok"</span><span class="token keyword">else</span>    echo <span class="token string">"nope"</span><span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="检查一个变量是否为空"><a href="#检查一个变量是否为空" class="headerlink" title="检查一个变量是否为空"></a>检查一个变量是否为空</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">nullstring <span class="token operator">=</span>foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span> <span class="token comment"># end of line; there is a space here</span><span class="token target symbol">all</span><span class="token punctuation">:</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">strip</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span>,<span class="token punctuation">)</span>    echo <span class="token string">"foo is empty after being stripped"</span><span class="token keyword">endif</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span>,<span class="token punctuation">)</span>    echo <span class="token string">"nullstring doesn't even have spaces"</span><span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="检查一个变量是否定义"><a href="#检查一个变量是否定义" class="headerlink" title="检查一个变量是否定义"></a>检查一个变量是否定义</h2><p><code>ifdef</code> 不会扩展变量引用，它只会查看变量的内容究竟定义没。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">bar <span class="token operator">=</span>foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token target symbol">all</span><span class="token punctuation">:</span><span class="token keyword">ifdef</span> foo    echo <span class="token string">"foo is defined"</span><span class="token keyword">endif</span><span class="token keyword">ifdef</span> bar    echo <span class="token string">"but bar is not"</span><span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="makeflags"><a href="#makeflags" class="headerlink" title="$(makeflags)"></a><code>$(makeflags)</code></h2><p>此示例向你展示了如何使用 <code>findstring</code> 和 <code>MAKEFLAGS</code> 测试 <code>make</code> 标志。使用 <code>make -i</code> 来运行此例看下输出如何吧。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">bar <span class="token operator">=</span>foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token target symbol">all</span><span class="token punctuation">:</span><span class="token comment"># Search for the "-i" flag. MAKEFLAGS is just a list of single characters, one per flag. So look for "i" in this case.</span><span class="token keyword">ifneq</span> <span class="token punctuation">(</span>,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">findstring</span> i, <span class="token variable">$</span><span class="token punctuation">(</span>MAKEFLAGS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    echo <span class="token string">"i was passed to MAKEFLAGS"</span><span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="第-1-个函数"><a href="#第-1-个函数" class="headerlink" title="第 1 个函数"></a>第 1 个函数</h2><p><em>函数</em> 主要用于文本处理。函数调用的语法是 <code>$(fn, arguments)</code> 或 <code>${fn, arguments}</code>。你可以使用内置的函数 <a href="https://www.gnu.org/software/make/manual/html_node/Call-Function.html#Call-Function"><code>call</code></a> 来制作自己的函数。Make 拥有数量众多的 <a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>subst not, totally, <span class="token string">"I am not superman"</span><span class="token punctuation">}</span><span class="token target symbol">all</span><span class="token punctuation">:</span>     <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你想替换空格或逗号，请使用变量：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">comma <span class="token operator">:=</span> ,empty<span class="token operator">:=</span>space <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>foo <span class="token operator">:=</span> a b cbar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> <span class="token variable">$</span><span class="token punctuation">(</span>space<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>comma<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token target symbol">all</span><span class="token punctuation">:</span>     <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>不要</strong> 在第一个参数之后的参数中包含空格，这将被视为字符串的一部分。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">comma <span class="token operator">:=</span> ,empty<span class="token operator">:=</span>space <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>foo <span class="token operator">:=</span> a b cbar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> <span class="token variable">$</span><span class="token punctuation">(</span>space<span class="token punctuation">)</span>, <span class="token variable">$</span><span class="token punctuation">(</span>comma<span class="token punctuation">)</span> , <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token target symbol">all</span><span class="token punctuation">:</span>     <span class="token comment"># Output is ", a , b , c". Notice the spaces introduced</span>    <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p><code>$(patsubst pattern,replacement,text)</code> 做了下面这些事：</p><blockquote><p>“在文本中查找匹配的以空格分隔的单词，用 <code>replacement</code> 替换它们。这里的 <code>pattern</code> 可以包含一个 <code>%</code> 作为通配符以匹配单词中任意数量的任意字符。如果 <code>replacement</code> 中也包含了一个 <code>%</code>，那它表示的内容将被 <code>pattern</code> 中的 <code>%</code> 匹配的内容替换。只有 <code>pattern</code> 和 <code>replacement</code> 中的第一个 <code>%</code> 才会采取这种行为，随后的任何 <code>%</code> 都将保持不变。（摘自 <a href="https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions">GNU 文档</a>）”</p></blockquote><p><code>$(text:pattern=replacement)</code> 是一个简化写法。</p><p>还有一个仅替换后缀的简写形式：<code>$(text:suffix=replacement)</code>，这里没有使用通配符 <code>%</code>。</p><p><note>在简写形式中，不要添加额外的空格，它会被当作一个搜索或替换项。</note></p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> a.o b.o l.a c.oone <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.o,%.c,<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># This is a shorthand for the above</span>two <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span>%.o<span class="token operator">=</span>%.c<span class="token punctuation">)</span><span class="token comment"># This is the suffix-only shorthand, and is also equivalent to the above.</span>three <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span>.o<span class="token operator">=</span>.c<span class="token punctuation">)</span><span class="token target symbol">all</span><span class="token punctuation">:</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span>    echo <span class="token variable">$</span><span class="token punctuation">(</span>three<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数-foreach"><a href="#函数-foreach" class="headerlink" title="函数 foreach"></a>函数 <code>foreach</code></h2><p>函数 <code>foreach</code> 看起来像这样：<code>$(foreach var,list,text)</code>，它用于将一个单词列表（空格分隔）转换为另一个。<code>var</code> 表示循环中的每一个单词，<code>text</code> 用于扩展每个单词。</p><p>在每个单词后追加一个感叹号：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> who are you<span class="token comment"># For each "word" in foo, output that same word with an exclamation after</span>bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> wrd,<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>wrd<span class="token punctuation">)</span>!<span class="token punctuation">)</span><span class="token target symbol">all</span><span class="token punctuation">:</span>    <span class="token comment"># Output is "who! are! you!"</span>    <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数-if"><a href="#函数-if" class="headerlink" title="函数 if"></a>函数 <code>if</code></h2><p><code>if</code> 函数用来检查它的第 1 个参数是否非空。如果非空，则运行第 2 个参数，否则运行第 3 个。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">if</span> this-is-not-empty,then!,<span class="token keyword">else</span>!<span class="token punctuation">)</span>empty <span class="token operator">:=</span>bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">if</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>,then!,<span class="token keyword">else</span>!<span class="token punctuation">)</span><span class="token target symbol">all</span><span class="token punctuation">:</span>    <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>    <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数-call"><a href="#函数-call" class="headerlink" title="函数 call"></a>函数 <code>call</code></h2><p>Make 支持创建基本的函数。你只需通过创建变量来“定义”函数，只是会用到参数 <code>$(0)</code>、<code>$(1)</code> 等。然后，你就可以使用专门的函数 <code>call</code> 来调用它了，语法是 <code>$(call variable,param,param)</code>。<code>$(0)</code> 是变量名，而 <code>$(1)</code>、<code>$(1)</code> 等则是参数。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">sweet_new_fn <span class="token operator">=</span> Variable Name<span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span> First<span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span> Second<span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span> Empty Variable<span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token target symbol">all</span><span class="token punctuation">:</span>    <span class="token comment"># Outputs "Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:"</span>    <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">call</span> sweet_new_fn, go, tigers<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数-shell"><a href="#函数-shell" class="headerlink" title="函数 shell"></a>函数 <code>shell</code></h2><p><code>shell</code> - 调用 shell，但它在输出中会用空格替代换行。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>     <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> ls -la<span class="token punctuation">)</span> <span class="token comment"># Very ugly because the newlines are gone!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h1><h2 id="包含-Makefiles-文件"><a href="#包含-Makefiles-文件" class="headerlink" title="包含 Makefiles 文件"></a>包含 Makefiles 文件</h2><p><code>include</code> 指令告诉 <code>make</code> 去读取其他 makefiles 文件，它是 makefile 中的一行，如下所示：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">include</span> filenames...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当你使用像 <code>-M</code> 这样的编译器标志时，<code>include</code> 特别有用，它可以根据源代码创建 Makefile。例如，如果一些 c 文件包括一个头，这个头将被添加到由 gcc 编写的 Makefile 中。关于这一点，我在 <a href="makefile-cookbook">Makefile Cookbook</a> 一节中有更详细的讨论。</p><h2 id="vpath-指令"><a href="#vpath-指令" class="headerlink" title="vpath 指令"></a><code>vpath</code> 指令</h2><p><code>vpath</code> 指令用来指定某些 <code>prerequisites</code> 的位置，使用格式是 <code>vpath &lt;pattern&gt; &lt;directories, space/colon separated&gt;</code>。</p><p><code>&lt;pattern&gt;</code> 中可以使用 <code>%</code>，用来匹配 0 个或多个字符。</p><p>你也可以使用变量 <code>VPATH</code> 全局执行此操作。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">vpath</span> %.h ../headers ../other-directory<span class="token target symbol">some_binary</span><span class="token punctuation">:</span> ../headers blah.h    touch some_binary<span class="token target symbol">../headers</span><span class="token punctuation">:</span>    mkdir ../headers<span class="token target symbol">blah.h</span><span class="token punctuation">:</span>    touch ../headers/blah.h<span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -rf ../headers    rm -f some_binary<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多行处理"><a href="#多行处理" class="headerlink" title="多行处理"></a>多行处理</h2><p>当命令过长时，反斜杠（<code>\</code>）可以让我们使用多行编写形式。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">some_file</span><span class="token punctuation">:</span>     echo This line is too long, so \        it is broken up into multiple lines<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="PHONY"><a href="#PHONY" class="headerlink" title=".PHONY"></a><code>.PHONY</code></h2><p>向一个目标中添加 <code>.PHONY</code> 会避免把一个虚拟目标识别为一个文件名。在下面这个例子中，即便文件 <code>clean</code> 被创建了，<code>make clean</code> 仍会运行。<code>.PHONY</code> 非常好用，但是为了简洁起见，在其余示例中我会跳过它。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">some_file</span><span class="token punctuation">:</span>    touch some_file    touch clean<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean<span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -f some_file    rm -f clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="DELETE-ON-ERROR"><a href="#DELETE-ON-ERROR" class="headerlink" title=".DELETE_ON_ERROR"></a><code>.DELETE_ON_ERROR</code></h2><p>如果一个命令返回了一个非 0 的退出码，那么 <code>make</code> 会停止运行相应的规则（并会传播到它的依赖中）。</p><p>如果一个规则因为上述这种情况构建失败了，那么应用了 <code>.DELETE_ON_ERROR</code> 后，这个规则的目标文件就会被删除。不像 <code>.PHONY</code>，<code>.DELETE_ON_ERROR</code> 对所有的目标都有效。始终使用 <code>.DELETE_ON_ERROR</code> 是个不错的选择，即使由于历史原因，<code>make</code> 不支持它。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.DELETE_ON_ERROR</span><span class="token punctuation">:</span><span class="token target symbol">all</span><span class="token punctuation">:</span> one two<span class="token target symbol">one</span><span class="token punctuation">:</span>    touch one    false<span class="token target symbol">two</span><span class="token punctuation">:</span>    touch two    false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Makefile-Cookbook"><a href="#Makefile-Cookbook" class="headerlink" title="Makefile Cookbook"></a>Makefile Cookbook</h1><p>让我们来看一个真正生动有趣的例子吧，对于中型规模的项目，它能很好地工作。</p><p>这个 makefile 的巧妙之处在于它能自动为你确定依赖，你所要做的就是把你的 C/C++ 文件放到 <code>src/</code> 文件夹中。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Thanks to Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/)</span>TARGET_EXEC <span class="token operator">:=</span> final_programBUILD_DIR <span class="token operator">:=</span> ./buildSRC_DIRS <span class="token operator">:=</span> ./src<span class="token comment"># Find all the C and C++ files we want to compile</span><span class="token comment"># Note the single quotes around the * expressions. Make will incorrectly expand these otherwise.</span>SRCS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> find <span class="token variable">$</span><span class="token punctuation">(</span>SRC_DIRS<span class="token punctuation">)</span> -name <span class="token string">'*.cpp'</span> -or -name <span class="token string">'*.c'</span> -or -name <span class="token string">'*.s'</span><span class="token punctuation">)</span><span class="token comment"># String substitution for every C/C++ file.</span><span class="token comment"># As an example, hello.cpp turns into ./build/hello.cpp.o</span>OBJS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCS<span class="token punctuation">:</span>%<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/%.o<span class="token punctuation">)</span><span class="token comment"># String substitution (suffix version without %).</span><span class="token comment"># As an example, ./build/hello.cpp.o turns into ./build/hello.cpp.d</span>DEPS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">:</span>.o<span class="token operator">=</span>.d<span class="token punctuation">)</span><span class="token comment"># Every folder in ./src will need to be passed to GCC so that it can find header files</span>INC_DIRS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> find <span class="token variable">$</span><span class="token punctuation">(</span>SRC_DIRS<span class="token punctuation">)</span> -type d<span class="token punctuation">)</span><span class="token comment"># Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands this -I flag</span>INC_FLAGS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>addprefix -I,<span class="token variable">$</span><span class="token punctuation">(</span>INC_DIRS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># The -MMD and -MP flags together generate Makefiles for us!</span><span class="token comment"># These files will have .d instead of .o as the output.</span>CPPFLAGS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>INC_FLAGS<span class="token punctuation">)</span> -MMD -MP<span class="token comment"># The final build step.</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/<span class="token variable">$</span>(TARGET_EXEC)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span><span class="token comment"># Build step for C source</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/%.c.o</span><span class="token punctuation">:</span> %.c    mkdir -p <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment"># Build step for C++ source</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/%.cpp.o</span><span class="token punctuation">:</span> %.cpp    mkdir -p <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CXXFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean<span class="token target symbol">clean</span><span class="token punctuation">:</span>    rm -r <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token comment"># Include the .d makefiles. The - at the front suppresses the errors of missing</span><span class="token comment"># Makefiles. Initially, all the .d files will be missing, and we don't want those</span><span class="token comment"># errors to show up.</span><span class="token keyword">-include</span> <span class="token variable">$</span><span class="token punctuation">(</span>DEPS<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核自测</title>
      <link href="/blog/eef8a716.html"/>
      <url>/blog/eef8a716.html</url>
      
        <content type="html"><![CDATA[<p>kernel在<code>tools/testing/selftests/</code>目录下包含一组“selftests” 。这些旨在进行小型测试，以测试内核中的各个代码路径。测试旨在在构建、安装和引导内核之后运行。</p><p>来自master的 Kselftest 可以在较旧的稳定内核上运行。从主线运行测试提供了最好的覆盖率。几个测试环在稳定版本上运行主线 kselftest 套件。原因是当添加新测试来测试现有代码以对错误进行回归测试时，我们应该能够在旧内核上运行该测试。因此，重要的是保留仍然可以测试旧内核的代码，并确保它在新版本上优雅地跳过测试。</p><p>您可以在 Kselftest wiki 上找到有关 Kselftest 框架的其他信息，以及如何使用该框架编写新测试：</p><p><a href="https://kselftest.wiki.kernel.org/">https://kselftest.wiki.kernel.org/</a></p><p>在某些系统上，热插拔测试可能会永远挂起，等待 CPU 和内存准备好脱机。创建一个特殊的热插拔目标来运行全方位的热插拔测试。在默认模式下，热插拔测试在有限范围内以安全模式运行。在受限模式下，热插拔 测试在单个 cpu 上运行，而不是在所有支持热插拔的 cpu 上运行，内存热插拔测试在 2% 的支持热插拔的内存上运行，而不是 10%。</p><p>kselftest 作为用户空间进程运行。可以在用户空间中编写/运行的测试可能希望使用<a href="https://www.kernel.org/doc/html/latest/dev-tools/kselftest.html#test-harness">测试工具</a>。需要在内核空间中运行的测试可能希望使用<a href="https://www.kernel.org/doc/html/latest/dev-tools/kselftest.html#test-module">测试模块</a>。</p><h2 id="1-检查构建系统上的selftest构建依赖项"><a href="#1-检查构建系统上的selftest构建依赖项" class="headerlink" title="1 检查构建系统上的selftest构建依赖项"></a>1 检查构建系统上的selftest构建依赖项</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> tools/testing/selfteststkselftest_deps.sh <span class="token parameter variable">-p</span> gcc <span class="token comment">#检查gcc编译依赖项</span>tkselftest_deps.sh <span class="token parameter variable">-p</span> aarch64-linux-gnu-gcc <span class="token comment">#检查aarch64-linux-gnu-gcc编译依赖项</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>更多选项查看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  selftests git:<span class="token punctuation">(</span>master<span class="token punctuation">)</span> ✗ ./kselftest_deps.sh       Usage: ./kselftest_deps.sh -<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&lt;</span>compiler<span class="token operator">&gt;</span> <span class="token punctuation">[</span>test_name<span class="token punctuation">]</span>        kselftest_deps.sh <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> gcc        kselftest_deps.sh <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> gcc vm        kselftest_deps.sh <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> aarch64-linux-gnu-gcc        kselftest_deps.sh <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> aarch64-linux-gnu-gcc vm- Should be run <span class="token keyword">in</span> selftests directory <span class="token keyword">in</span> the kernel repo.- Checks <span class="token keyword">if</span> Kselftests can be built/cross-built on a system.- Parses all test/sub-test Makefile to <span class="token function">find</span> library dependencies.- Runs compile <span class="token builtin class-name">test</span> on a trivial C <span class="token function">file</span> with LDLIBS specified  <span class="token keyword">in</span> the <span class="token builtin class-name">test</span> Makefiles to identify missing library dependencies.- Prints suggested target list <span class="token keyword">for</span> a system filtering out tests  failed the build dependency check from the TARGETS <span class="token keyword">in</span> Selftests  main Makefile when optional <span class="token parameter variable">-p</span> is specified.- Prints pass/fail dependency check <span class="token keyword">for</span> each tests/sub-test.- Prints pass/fail targets and libraries.- Default: runs dependency checks on all tests.- Optional: <span class="token builtin class-name">test</span> name can be specified to check dependencies <span class="token keyword">for</span> it.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-运行selftests（热插拔测试在受限模式下运行）"><a href="#2-运行selftests（热插拔测试在受限模式下运行）" class="headerlink" title="2 运行selftests（热插拔测试在受限模式下运行）"></a>2 运行selftests（热插拔测试在受限模式下运行）</h2><ul><li>要构建测试，请执行以下操作：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token parameter variable">-C</span> tools/testing/selftests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> tools/testing/selftests<span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>要运行测试，请执行以下操作：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token parameter variable">-C</span> tools/testing/selftests run_tests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> tools/testing/selftests<span class="token function">make</span> run_tests<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>若要使用单个命令构建和运行测试，请使用：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> menuconfig <span class="token comment"># 根据需要配置</span><span class="token function">make</span> kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>请注意，在kernel根目录运行，某些测试需要根权限。</p></blockquote><p>Kselftest 支持将输出文件保存在单独的目录中，然后运行测试。要在单独的目录中定位输出文件，支持两种语法。在这两种情况下，工作目录都必须是内核 src 的根目录。这适用于下面的“运行自测子集”部分。</p><p>要构建，请使用 O= 将输出文件保存在单独的目录中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">O</span><span class="token operator">=</span>/tmp/kselftest kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>请注意，在kernel根目录运行，编译完成后，目标会生成在/tmp/kselftest目录下，并运行</p></blockquote><p>要构建，请使用 KBUILD_OUTPUT 将输出文件保存在单独的目录中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">KBUILD_OUTPUT</span><span class="token operator">=</span>/tmp/kselftest<span class="token punctuation">;</span> <span class="token function">make</span> kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>请注意，在kernel根目录运行，与上面的命令行等价</p></blockquote><p>O= 赋值优先于 KBUILD_OUTPUT 环境变量。</p><p>上面的命令默认运行测试并打印完整的通过/失败报告。Kselftest 支持“summary”选项，使测试结果更容易理解。当指定摘要选项时，请在 /tmp/testname 文件中找到每个测试的详细测试结果。这适用于下面的“Running a subset of selftests”部分。</p><p>在启用摘要选项的情况下运行 kselftest</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">summary</span><span class="token operator">=</span><span class="token number">1</span> kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令运行测试并打印通过/失败摘要以使 更容易理解测试结果。请找到详细的个人 /tmp/testname 文件中每个测试的测试结果。</p><h2 id="3-运行一部分selftest"><a href="#3-运行一部分selftest" class="headerlink" title="3 运行一部分selftest"></a>3 运行一部分selftest</h2><p>您可以使用 make 命令行上的 “TARGETS” 变量来指定 要运行的单个测试或要运行的测试列表。</p><p>要仅运行针对单个子系统的测试，请执行以下操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token parameter variable">-C</span> tools/testing/selftests <span class="token assign-left variable">TARGETS</span><span class="token operator">=</span>ptrace run_tests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> tools/testing/selftests<span class="token function">make</span> <span class="token assign-left variable">TARGETS</span><span class="token operator">=</span>ptrace <span class="token comment"># 只编译</span><span class="token function">make</span> <span class="token assign-left variable">TARGETS</span><span class="token operator">=</span>ptrace run_tests <span class="token comment"># 编译+运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以指定要生成和运行的多个测试：</p><p>直接调用根目录下的makefile</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">TARGETS</span><span class="token operator">=</span><span class="token string">"size timers"</span> kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> tools/testing/selftests<span class="token function">make</span> <span class="token assign-left variable">TARGETS</span><span class="token operator">=</span><span class="token string">'ptrace size'</span> <span class="token comment"># 只编译</span><span class="token function">make</span> <span class="token assign-left variable">TARGETS</span><span class="token operator">=</span><span class="token string">'ptrace size'</span> run_tests <span class="token comment"># 编译+运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从用户特定的对象目录构建和运行（使 O=dir）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">O</span><span class="token operator">=</span>/tmp/kselftest <span class="token assign-left variable">TARGETS</span><span class="token operator">=</span><span class="token string">"size timers"</span> kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构建并运行KBUILD_OUTPUT目录（make KBUILD_OUTPUT=）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">KBUILD_OUTPUT</span><span class="token operator">=</span>/tmp/kselftest <span class="token assign-left variable">TARGETS</span><span class="token operator">=</span><span class="token string">"size timers"</span> kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此外，您可以在 make 命令行上使用“SKIP_TARGETS”变量来指定一个或多个要从 TARGETS 列表中排除的目标。</p><p>要运行除单个子系统之外的所有测试：</p><pre class="line-numbers language-none"><code class="language-none">make -C tools/testing/selftests SKIP_TARGETS=ptrace run_tests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以指定要跳过的多个测试：</p><pre class="line-numbers language-none"><code class="language-none">make SKIP_TARGETS="size timers" kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您还可以指定要与专用跳过列表一起运行的受限测试列表：</p><pre class="line-numbers language-none"><code class="language-none">make TARGETS="bpf breakpoints size timers" SKIP_TARGETS=bpf kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请参阅<code>tools/testing/selftests/Makefile</code>以获取所有列表可能的targets。</p><h2 id="4-运行全范围热插拔selftests"><a href="#4-运行全范围热插拔selftests" class="headerlink" title="4 运行全范围热插拔selftests"></a>4 运行全范围热插拔selftests</h2><p>要构建热插拔测试，请执行以下操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token parameter variable">-C</span> tools/testing/selftests hotplug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要运行热插拔测试，请执行以下操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token parameter variable">-C</span> tools/testing/selftests run_hotplug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请注意，某些测试需要根权限。</p><h2 id="5-安装selftests"><a href="#5-安装selftests" class="headerlink" title="5 安装selftests"></a>5 安装selftests</h2><p>默认情况下，您可以使用<code>kselftest_install.sh</code>工具安装默认位置是<code>tools/testing/selftests/kselftest_install </code>或用户指定的位置。</p><p>要在默认位置安装selftests：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> tools/testing/selftests./kselftest_install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要在用户指定的位置安装selftests：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> tools/testing/selftests./kselftest_install.sh install_dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-运行已安装的selftests"><a href="#6-运行已安装的selftests" class="headerlink" title="6 运行已安装的selftests"></a>6 运行已安装的selftests</h2><p>Kselftest install以及Kselftest压缩包提供了一个脚本名为“run_kselftest.sh”以运行测试。</p><p>您只需执行以下操作即可运行已安装的 Kselftests。请注意某些测试需要根权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> install_dir./run_kselftest.sh <span class="token comment"># 运行所有已编译的测试集</span>./run_kselftest.sh <span class="token parameter variable">-c</span> timers <span class="token comment"># 运行所有已编译的测试集</span>./run_kselftest.sh <span class="token parameter variable">-t</span> timers:nanosleep <span class="token comment"># 运行所有已编译的测试集</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>要查看可用测试列表，可以使用-l选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./run_kselftest.sh <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-c选项可用于运行测试集合中的所有测试，或用于特定单个测试的-t选项。两者都可以多次使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./run_kselftest.sh <span class="token parameter variable">-c</span> bpf <span class="token parameter variable">-c</span> seccomp <span class="token parameter variable">-t</span> timers:posix_timers <span class="token parameter variable">-t</span> timer:nanosleep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更多选项参考</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  selftests git:<span class="token punctuation">(</span>master<span class="token punctuation">)</span> ✗ ./run_kselftest.sh <span class="token parameter variable">-h</span>                      Usage: ./run_kselftest.sh <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>  <span class="token parameter variable">-s</span> <span class="token operator">|</span> <span class="token parameter variable">--summary</span>                Print summary with detailed log <span class="token keyword">in</span> output.log  <span class="token parameter variable">-t</span> <span class="token operator">|</span> <span class="token parameter variable">--test</span> COLLECTION:TEST   Run TEST from COLLECTION  <span class="token parameter variable">-c</span> <span class="token operator">|</span> <span class="token parameter variable">--collection</span> COLLECTION  Run all tests from COLLECTION  <span class="token parameter variable">-l</span> <span class="token operator">|</span> <span class="token parameter variable">--list</span>                   List the available collection:test entries  <span class="token parameter variable">-d</span> <span class="token operator">|</span> --dry-run                Don't actually run any tests  <span class="token parameter variable">-h</span> <span class="token operator">|</span> <span class="token parameter variable">--help</span>                   Show this usage info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-打包selftests"><a href="#7-打包selftests" class="headerlink" title="7 打包selftests"></a>7 打包selftests</h2><p>在某些情况下需要打包，例如当测试需要在不同的系统上运行时。要打包自检，请运行：</p><pre class="line-numbers language-none"><code class="language-none">make -C tools/testing/selftests gen_tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会在INSTALL_PATH/kselftest-packages目录中生成一个 tarball 。默认情况下，使用.gz格式。可以通过指定FORMAT make 变量来覆盖 tar 压缩格式。<a href="https://www.gnu.org/software/tar/manual/html_node/gzip.html#auto_002dcompress">支持tar 的自动压缩</a>选项识别的任何值 ，例如：</p><pre class="line-numbers language-none"><code class="language-none">make -C tools/testing/selftests gen_tar FORMAT=.xz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>make gen_tar调用make install以便您可以使用它来打包测试子集，方法是使用在<a href="https://www.kernel.org/doc/html/latest/dev-tools/kselftest.html#running-a-subset-of-selftests">运行自测试子集部分</a>中指定的变量 ：</p><pre class="line-numbers language-none"><code class="language-none">make -C tools/testing/selftests gen_tar TARGETS="bpf" FORMAT=.xz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-贡献新的测试"><a href="#8-贡献新的测试" class="headerlink" title="8 贡献新的测试"></a>8 贡献新的测试</h2><p>一般来说，自测的规则是</p><ul><li>如果您不是管理员，请尽可能多地做；</li><li>不要花太长时间；</li><li>不要破坏任何架构上的构建，并且</li><li>如果您的功能未配置，请不要导致顶级“make run_tests”失败。</li></ul><h2 id="9-贡献新测试（详情）"><a href="#9-贡献新测试（详情）" class="headerlink" title="9 贡献新测试（详情）"></a>9 贡献新测试（详情）</h2><ul><li>在您的 Makefile 中，通过包含它而不是重新发明轮子来使用 lib.mk 中的设施。在包含 lib.mk 之前，根据需要指定标志和二进制文件生成标志。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CFLAGS <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>KHDR_INCLUDES<span class="token variable">)</span></span>TEST_GEN_PROGS :<span class="token operator">=</span> close_range_testinclude <span class="token punctuation">..</span>/lib.mk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>如果在编译期间生成此类二进制文件或文件，请使用 TEST_GEN_XXX。</p><p>  TEST_PROGS、TEST_GEN_PROGS 表示它是默认测试的可执行文件。</p><p>  TEST_CUSTOM_PROGS 应该由需要自定义构建规则并防止使用常见构建规则的测试使用。</p><p>  TEST_PROGS 用于测试 shell 脚本。请确保 shell 脚本已设置其 exec 位。否则，lib.mk run_tests 将生成警告。</p><p>  TEST_CUSTOM_PROGS 和 TEST_PROGS 将由公共 run_tests 运行。</p><p>  TEST_PROGS_EXTENDED、TEST_GEN_PROGS_EXTENDED 表示它是默认未测试的可执行文件。TEST_FILES、TEST_GEN_FILES 表示它是测试使用的文件。</p></li><li><p>首先使用内核源代码和/或 git repo 中的标头，然后使用系统标头。与发行版在系统上安装的标头相反，内核版本的标头应该是能够找到回归的主要焦点。在 Makefile 中使用 KHDR_INCLUDES 来包含来自内核源代码的标头。</p></li><li><p>如果测试需要启用特定的内核配置选项，请在测试目录中添加配置文件以启用它们。</p><p>  例如：工具/测试/selftests/android/config</p></li><li><p>在测试目录中创建一个 .gitignore 文件并在其中添加所有生成的对象。</p></li><li><p>在 selftests/Makefile 的 TARGETS 中添加新的测试名称：</p>  <pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGETS <span class="token operator">+=</span> android<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>所有更改都应该通过：</p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kselftest-<span class="token punctuation">{</span>all,install,clean,gen_tar<span class="token punctuation">}</span>kselftest-<span class="token punctuation">{</span>all,install,clean,gen_tar<span class="token punctuation">}</span> <span class="token assign-left variable">O</span><span class="token operator">=</span>abo_pathkselftest-<span class="token punctuation">{</span>all,install,clean,gen_tar<span class="token punctuation">}</span> <span class="token assign-left variable">O</span><span class="token operator">=</span>rel_path<span class="token function">make</span> <span class="token parameter variable">-C</span> tools/testing/selftests <span class="token punctuation">{</span>all,install,clean,gen_tar<span class="token punctuation">}</span><span class="token function">make</span> <span class="token parameter variable">-C</span> tools/testing/selftests <span class="token punctuation">{</span>all,install,clean,gen_tar<span class="token punctuation">}</span> <span class="token assign-left variable">O</span><span class="token operator">=</span>abs_path<span class="token function">make</span> <span class="token parameter variable">-C</span> tools/testing/selftests <span class="token punctuation">{</span>all,install,clean,gen_tar<span class="token punctuation">}</span> <span class="token assign-left variable">O</span><span class="token operator">=</span>rel_path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="10-测试模块"><a href="#10-测试模块" class="headerlink" title="10 测试模块"></a>10 测试模块</h2><p>Kselftest 从用户空间测试内核。有时需要从内核内部进行测试，一种方法是创建一个测试模块。我们可以使用 shell 脚本测试运行器将模块绑定到 kselftest 框架中。 <code>kselftest/module.sh</code>旨在促进这一过程。还提供了一个头文件来帮助编写与 kselftest 一起使用的内核模块：</p><ul><li><code>tools/testing/selftests/kselftest_module.h</code></li><li><code>tools/testing/selftests/kselftest/module.sh</code></li></ul><p>请注意，测试模块应该使用 TAINT_TEST 污染内核。对于目录中的模块<code>tools/testing/</code> 或使用<code>kselftest_module.h</code>上述标头的模块，这将自动发生。否则，您将需要添加到您的模块源。不加载模块的自测试通常不应污染内核，但在加载非测试模块的情况下，可以通过写入.<code>MODULE_INFO(test, "Y")``/proc/sys/kernel/tainted</code></p><h3 id="10-1-如何使用"><a href="#10-1-如何使用" class="headerlink" title="10.1 如何使用"></a>10.1 如何使用</h3><p>这里我们展示了创建测试模块并将其绑定到 kselftest 的典型步骤。我们以 lib/ 的 kselftests 为例。</p><ol><li>创建测试模块</li><li>创建将运行（加载/卸载）模块的测试脚本，例如<code>tools/testing/selftests/lib/printf.sh</code></li><li>将行添加到配置文件，例如<code>tools/testing/selftests/lib/config</code></li><li>将测试脚本添加到 makefile 例如<code>tools/testing/selftests/lib/Makefile</code></li><li>验证它是否有效：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Assumes you have booted a fresh build of this kernel tree</span><span class="token builtin class-name">cd</span> /path/to/linux/tree<span class="token function">make</span> kselftest-merge<span class="token function">make</span> modules<span class="token function">sudo</span> <span class="token function">make</span> modules_install<span class="token function">make</span> <span class="token assign-left variable">TARGETS</span><span class="token operator">=</span>lib kselftest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-2-示例模块"><a href="#10-2-示例模块" class="headerlink" title="10.2 示例模块"></a>10.2 示例模块</h3><p>一个简单的测试模块可能看起来像这样：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">// SPDX-License-Identifier: GPL-2.0+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt#include "../tools/testing/selftests/kselftest_module.h"KSTM_MODULE_GLOBALS();/* * Kernel module for testing the foobinator */static int __init test_function(){        ...}static void __init selftest(void){        KSTM_CHECK_ZERO(do_test_case("", 0));}KSTM_MODULE_LOADERS(test_foo);MODULE_AUTHOR("John Developer &lt;jd@fooman.org&gt;");MODULE_LICENSE("GPL");MODULE_INFO(test, "Y");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-3-示例测试脚本"><a href="#10-3-示例测试脚本" class="headerlink" title="10.3 示例测试脚本"></a>10.3 示例测试脚本</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># SPDX-License-Identifier: GPL-2.0+</span><span class="token variable"><span class="token variable">$(</span><span class="token function">dirname</span> $0<span class="token variable">)</span></span>/<span class="token punctuation">..</span>/kselftest/module.sh <span class="token string">"foo"</span> test_foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="10-4-测试约束"><a href="#10-4-测试约束" class="headerlink" title="10.4 测试约束"></a>10.4 测试约束</h3><p>kselftest_harness.h 文件包含用于构建测试的有用帮助程序。测试工具用于用户空间测试，内核空间测试参见上面的<a href="https://www.kernel.org/doc/html/latest/dev-tools/kselftest.html#test-module">测试模块</a>。</p><p>tools/testing/selftests/seccomp/seccomp_bpf.c 中的测试可以用作示例。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include "../kselftest_harness.h"TEST(standalone_test) {  do_some_stuff;  EXPECT_GT(10, stuff) {     stuff_state_t state;     enumerate_stuff_state(&amp;state);     TH_LOG("expectation failed with state: %s", state.msg);  }  more_stuff;  ASSERT_NE(some_stuff, NULL) TH_LOG("how did it happen?!");  last_stuff;  EXPECT_EQ(0, last_stuff);}FIXTURE(my_fixture) {  mytype_t *data;  int awesomeness_level;};FIXTURE_SETUP(my_fixture) {  self-&gt;data = mytype_new();  ASSERT_NE(NULL, self-&gt;data);}FIXTURE_TEARDOWN(my_fixture) {  mytype_free(self-&gt;data);}TEST_F(my_fixture, data_is_good) {  EXPECT_EQ(1, is_my_data_good(self-&gt;data));}TEST_HARNESS_MAIN <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-帮助"><a href="#11-帮助" class="headerlink" title="11 帮助"></a>11 帮助</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">TH_LOG<span class="token punctuation">(</span>fmt, <span class="token punctuation">..</span>.<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：fmt格式字符串...可选参数描述：TH_LOG(format, ...)可在测试中使用的可选调试日志记录功能。通过定义TH_LOG_ENABLED可以启用或禁用日志记录。E.g.,#define TH_LOG_ENABLED 1如果未提供定义，则默认情况下启用日志记录。如果无法为运行测试的进程打印错误消息（例如，不允许写入stderr），则仍然有可能获得测试失败的ASSERT_*号。可以通过编写_metadata-&gt;no_print = true来启用此行为；在无法打印的检查序列之前。当发生错误时，测试过程将使用断言编号作为参数来调用_exit（2），而不是打印错误消息并调用abort（3），然后由父进程打印。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TEST</span><span class="token punctuation">(</span>test_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义测试功能并创建注册存根</p><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：test_nametest name描述：TEST(name) { implementation }通过名称定义测试。名称必须唯一，并且测试不能并行运行。包含block的实现是一个函数，作用域应这样对待。尽早返回可能只是简单的“返回”；声明。EXPECT_* 和ASSERT_* 在 TEST() { } 中是有效的.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TEST_SIGNAL</span><span class="token punctuation">(</span>test_name<span class="token punctuation">,</span> signal<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：test_nametest namesignalsignal number描述：TEST_SIGNAL(name, signal) { implementation }通过名称和期望的术语信号定义测试。名称必须唯一，并且测试不能并行运行。包含block的实现是一个函数，作用域应这样对待。尽早返回可能只是简单的“返回”；声明。EXPECT_* 和ASSERT_* 在 TEST() { } 中是有效的.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">FIXTURE_DATA</span><span class="token punctuation">(</span>datatype_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>包装结构名称，以便我们少传递一个参数</p><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：datatype_namedatatype name描述：FIXTURE_DATA(datatype name)当需要数据的类型时，可以使用此调用。通常，除非将自身直接传递给帮助者，否则不需要这样做。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">FIXTURE</span><span class="token punctuation">(</span>fixture_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每个灯具调用一次以设置数据并注册</p><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：fixture_namefixture name描述：FIXTURE(datatype name) {  type property1;  ...};将提供给TEST_F（）定义的测试的数据定义为self。应该使用FIXTURE_SETUP（）和FIXTURE_TEARDOWN（）进行填充和清理。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">FIXTURE_SETUP</span><span class="token punctuation">(</span>fixture_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>准备test的设置功能。包含_metadata，以便ASSERT_*方便使用</p><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：fixture_namefixture name描述：FIXTURE_SETUP(fixture name) { implementation }填充固件所需的“设置”功能。使用FIXTURE_DATA（）定义的数据类型的实例将作为实现公开给自己。ASSERT_ *在此上下文中有效，并且会阻止执行任何相关的夹具测试。裸露的“return”；语句可能用于提早返回。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">FIXTURE_TEARDOWN</span><span class="token punctuation">(</span>fixture_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：fixture_namefixture name描述：FIXTURE_TEARDOWN(fixture name) { implementation }填充夹具所需的“teardown”功能。用FIXTURE_DATA（）定义的数据类型的实例将作为自身公开，以供实现清除。裸露的“return”；语句可能用于提早返回。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TEST_F</span><span class="token punctuation">(</span>fixture_name<span class="token punctuation">,</span> test_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为基于夹具的测试用例发出测试注册和帮助程序</p><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：fixture_namefixture nametest_nametest name描述：TEST_F(fixture, name) { implementation }定义依赖夹具的测试（例如，属于测试用例的一部分）。与TEST（）极为相似，不同的是self是暴露给夹具以供实现使用的数据类型的设置实例。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TEST_HARNESS_MAIN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简单的包装程序即可运行测试工具</p><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：描述：TEST_HARNESS_MAIN使用一次即可将main（）附加到测试文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在TEST() 和TEST_F（）中使用的运算符。 ASSERT_ *调用将立即停止测试执行。 EXPECT_ *调用将发出失败警告，请注意并继续。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_EQ</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：ASSERT_EQ(expected, measured): expected == measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_NE</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：ASSERT_NE(expected, measured): expected != measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_LT</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：ASSERT_LT(expected, measured): expected &lt; measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_LE</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：ASSERT_LE(expected, measured): expected &lt;= measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_GT</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：ASSERT_GT(expected, measured): expected &gt; measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_GE</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：ASSERT_GE(expected, measured): expected &gt;= measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_NULL</span><span class="token punctuation">(</span>seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：seenmeasured value  被检测值描述：ASSERT_NULL(measured): NULL == measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span>seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：seenmeasured value  被检测值描述：ASSERT_TRUE(measured): measured != 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_FALSE</span><span class="token punctuation">(</span>seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：seenmeasured value  被检测值描述：ASSERT_FALSE(measured): measured == 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_STREQ</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：ASSERT_STREQ(expected, measured): !strcmp(expected, measured)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT_STRNE</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：ASSERT_STRNE(expected, measured): strcmp(expected, measured)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_EQ(expected, measured): expected == measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_NE</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_NE(expected, measured): expected != measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_LT</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_LT(expected, measured): expected &lt; measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_LE</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_LE(expected, measured): expected &lt;= measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_GT</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_GT(expected, measured): expected &gt; measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_GE</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_GE(expected, measured): expected &gt;= measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_NULL</span><span class="token punctuation">(</span>seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_NULL(measured): NULL == measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_TRUE</span><span class="token punctuation">(</span>seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_TRUE(measured): 0 != measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_FALSE</span><span class="token punctuation">(</span>seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_FALSE(measured): 0 == measured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_STREQ</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_STREQ(expected, measured): !strcmp(expected, measured)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">EXPECT_STRNE</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-handlebars" data-language="handlebars"><code class="language-handlebars">参数：expectedexpected value  期望值seenmeasured value  被检测值描述：EXPECT_STRNE(expected, measured): strcmp(expected, measured)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Qemu </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用qemu搭建ARM64调试环境,支持文件共享,支持gdb调试</title>
      <link href="/blog/1a3d20c9.html"/>
      <url>/blog/1a3d20c9.html</url>
      
        <content type="html"><![CDATA[<p>主机<a href="https://so.csdn.net/so/search?q=ubuntu&amp;spm=1001.2101.3001.7020">ubuntu</a>版本: 22.04</p><p>qemu模拟处理器：ARM64</p><p>Linux内核版本：<a href="https://www.kernel.org/">https://www.kernel.org/</a> 最新版</p><h1 id="1-安装编译工具链"><a href="#1-安装编译工具链" class="headerlink" title="1 安装编译工具链"></a>1 安装编译工具链</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> gcc-aarch64-linux-gnu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看版本号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  ~ aarch64-linux-gnu-gcc <span class="token parameter variable">-v</span>Using built-in specs.<span class="token assign-left variable">COLLECT_GCC</span><span class="token operator">=</span>aarch64-linux-gnu-gcc<span class="token assign-left variable">COLLECT_LTO_WRAPPER</span><span class="token operator">=</span>/usr/lib/gcc-cross/aarch64-linux-gnu/11/lto-wrapperTarget: aarch64-linux-gnuConfigured with: <span class="token punctuation">..</span>/src/configure <span class="token parameter variable">-v</span> --with-pkgversion<span class="token operator">=</span><span class="token string">'Ubuntu 11.2.0-17ubuntu1'</span> --with-bugurl<span class="token operator">=</span>file:///usr/share/doc/gcc-11/README.Bugs --enable-languages<span class="token operator">=</span>c,ada,c++,go,d,fortran,objc,obj-c++,m2 <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr --with-gcc-major-version-only --program-suffix<span class="token operator">=</span>-11 --enable-shared --enable-linker-build-id <span class="token parameter variable">--libexecdir</span><span class="token operator">=</span>/usr/lib --without-included-gettext --enable-threads<span class="token operator">=</span>posix <span class="token parameter variable">--libdir</span><span class="token operator">=</span>/usr/lib --enable-nls --with-sysroot<span class="token operator">=</span>/ --enable-clocale<span class="token operator">=</span>gnu --enable-libstdcxx-debug --enable-libstdcxx-time<span class="token operator">=</span>yes --with-default-libstdcxx-abi<span class="token operator">=</span>new --enable-gnu-unique-object --disable-libquadmath --disable-libquadmath-support --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking<span class="token operator">=</span>release --without-target-system-zlib --enable-multiarch --enable-fix-cortex-a53-843419 --disable-werror --enable-checking<span class="token operator">=</span>release <span class="token parameter variable">--build</span><span class="token operator">=</span>x86_64-linux-gnu <span class="token parameter variable">--host</span><span class="token operator">=</span>x86_64-linux-gnu <span class="token parameter variable">--target</span><span class="token operator">=</span>aarch64-linux-gnu --program-prefix<span class="token operator">=</span>aarch64-linux-gnu- <span class="token parameter variable">--includedir</span><span class="token operator">=</span>/usr/aarch64-linux-gnu/include --with-build-config<span class="token operator">=</span>bootstrap-lto-lean --enable-link-serialization<span class="token operator">=</span><span class="token number">2</span>Thread model: posixSupported LTO compression algorithms: zlib zstdgcc version <span class="token number">11.2</span>.0 <span class="token punctuation">(</span>Ubuntu <span class="token number">11.2</span>.0-17ubuntu1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-安装qemu"><a href="#2-安装qemu" class="headerlink" title="2 安装qemu"></a>2 安装qemu</h1><h2 id="2-1-命令行安装"><a href="#2-1-命令行安装" class="headerlink" title="2.1 命令行安装"></a>2.1 命令行安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qemu-system-arm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  ~ qemu-system-aarch64 <span class="token parameter variable">--version</span>QEMU emulator version <span class="token number">6.2</span>.0 <span class="token punctuation">(</span>Debian <span class="token number">1</span>:6.2+dfsg-2ubuntu6.6<span class="token punctuation">)</span>Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2003</span>-2021 Fabrice Bellard and the QEMU Project developers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-2-源码安装"><a href="#2-2-源码安装" class="headerlink" title="2.2 源码安装"></a>2.2 源码安装</h2><ol><li>QEMU依赖库安装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> re2c <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ninja-build <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> build-essential zlib1g-dev pkg-config libglib2.0-dev <span class="token parameter variable">-y</span><span class="token function">sudo</span> aptinstall binutils-dev libboost-all-dev autoconf libtool libssl-dev libpixman-1-dev libpython-dev python-pip python-capstone virtualenv <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libpixman-1-dev <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> bison flex <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> meson <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libpixman-1-dev <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libpcap-dev libnids-dev libnet1-dev <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libattr1-dev <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libcap-ng-dev <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>下载busybox源码</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://download.qemu.org/qemu-7.2.0.tar.xz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>解压</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> xvJf qemu-7.2.0.tar.xz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>配置</li></ol><p>支持配置项</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  qemu-7.2.0 ./configure <span class="token parameter variable">--help</span>Using <span class="token string">'./build'</span> as the directory <span class="token keyword">for</span> build outputUsage: configure <span class="token punctuation">[</span>options<span class="token punctuation">]</span>Options: <span class="token punctuation">[</span>defaults <span class="token keyword">in</span> brackets after descriptions<span class="token punctuation">]</span>Standard options:  <span class="token parameter variable">--help</span>                   print this message  <span class="token parameter variable">--prefix</span><span class="token operator">=</span>PREFIX          <span class="token function">install</span> <span class="token keyword">in</span> PREFIX <span class="token punctuation">[</span>/usr/local<span class="token punctuation">]</span>  --target-list<span class="token operator">=</span>LIST       <span class="token builtin class-name">set</span> target list <span class="token punctuation">(</span>default: build all<span class="token punctuation">)</span>                           Available targets: aarch64-softmmu alpha-softmmu                           arm-softmmu avr-softmmu cris-softmmu hppa-softmmu                           i386-softmmu loongarch64-softmmu m68k-softmmu                           microblaze-softmmu microblazeel-softmmu mips-softmmu                           mips64-softmmu mips64el-softmmu mipsel-softmmu                           nios2-softmmu or1k-softmmu ppc-softmmu ppc64-softmmu                           riscv32-softmmu riscv64-softmmu rx-softmmu                           s390x-softmmu sh4-softmmu sh4eb-softmmu                           sparc-softmmu sparc64-softmmu tricore-softmmu                           x86_64-softmmu xtensa-softmmu xtensaeb-softmmu                           aarch64-linux-user aarch64_be-linux-user                           alpha-linux-user arm-linux-user armeb-linux-user                           cris-linux-user hexagon-linux-user hppa-linux-user                           i386-linux-user loongarch64-linux-user                           m68k-linux-user microblaze-linux-user                           microblazeel-linux-user mips-linux-user                           mips64-linux-user mips64el-linux-user                           mipsel-linux-user mipsn32-linux-user                           mipsn32el-linux-user nios2-linux-user                           or1k-linux-user ppc-linux-user ppc64-linux-user                           ppc64le-linux-user riscv32-linux-user                           riscv64-linux-user s390x-linux-user sh4-linux-user                           sh4eb-linux-user sparc-linux-user                           sparc32plus-linux-user sparc64-linux-user                           x86_64-linux-user xtensa-linux-user                           xtensaeb-linux-user  --target-list-exclude<span class="token operator">=</span>LIST exclude a <span class="token builtin class-name">set</span> of targets from the default target-listAdvanced options <span class="token punctuation">(</span>experts only<span class="token punctuation">)</span>:  --cross-prefix<span class="token operator">=</span>PREFIX    use PREFIX <span class="token keyword">for</span> compile tools, PREFIX can be blank <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token parameter variable">--cc</span><span class="token operator">=</span>CC                  use C compiler CC <span class="token punctuation">[</span>cc<span class="token punctuation">]</span>  --host-cc<span class="token operator">=</span>CC             use C compiler CC <span class="token punctuation">[</span>cc<span class="token punctuation">]</span> <span class="token keyword">for</span> code run at                           build <span class="token function">time</span>  <span class="token parameter variable">--cxx</span><span class="token operator">=</span>CXX                use C++ compiler CXX <span class="token punctuation">[</span>c++<span class="token punctuation">]</span>  <span class="token parameter variable">--objcc</span><span class="token operator">=</span>OBJCC            use Objective-C compiler OBJCC <span class="token punctuation">[</span>cc<span class="token punctuation">]</span>  --extra-cflags<span class="token operator">=</span>CFLAGS    append extra C compiler flags CFLAGS  --extra-cxxflags<span class="token operator">=</span>CXXFLAGS append extra C++ compiler flags CXXFLAGS  --extra-objcflags<span class="token operator">=</span>OBJCFLAGS append extra Objective C compiler flags OBJCFLAGS  --extra-ldflags<span class="token operator">=</span>LDFLAGS  append extra linker flags LDFLAGS  --cross-cc-ARCH<span class="token operator">=</span>CC       use compiler when building ARCH guest <span class="token builtin class-name">test</span> cases  --cross-cc-cflags-ARCH<span class="token operator">=</span>  use compiler flags when building ARCH guest tests  --cross-prefix-ARCH<span class="token operator">=</span>PREFIX cross compiler prefix when building ARCH guest <span class="token builtin class-name">test</span> cases  <span class="token parameter variable">--make</span><span class="token operator">=</span>MAKE              use specified <span class="token function">make</span> <span class="token punctuation">[</span>make<span class="token punctuation">]</span>  <span class="token parameter variable">--python</span><span class="token operator">=</span>PYTHON          use specified python <span class="token punctuation">[</span>/usr/bin/python3<span class="token punctuation">]</span>  <span class="token parameter variable">--meson</span><span class="token operator">=</span>MESON            use specified meson <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token parameter variable">--ninja</span><span class="token operator">=</span>NINJA            use specified ninja <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token parameter variable">--smbd</span><span class="token operator">=</span>SMBD              use specified smbd <span class="token punctuation">[</span><span class="token punctuation">]</span>  --with-git<span class="token operator">=</span>GIT           use specified <span class="token function">git</span> <span class="token punctuation">[</span>git<span class="token punctuation">]</span>  --with-git-submodules<span class="token operator">=</span>update   update <span class="token function">git</span> submodules <span class="token punctuation">(</span>default <span class="token keyword">if</span> .git <span class="token function">dir</span> exists<span class="token punctuation">)</span>  --with-git-submodules<span class="token operator">=</span>validate fail <span class="token keyword">if</span> <span class="token function">git</span> submodules are not up to <span class="token function">date</span>  --with-git-submodules<span class="token operator">=</span>ignore   <span class="token keyword">do</span> not update or check <span class="token function">git</span> submodules <span class="token punctuation">(</span>default <span class="token keyword">if</span> no .git <span class="token function">dir</span><span class="token punctuation">)</span>  <span class="token parameter variable">--static</span>                 <span class="token builtin class-name">enable</span> static build <span class="token punctuation">[</span>no<span class="token punctuation">]</span>  <span class="token parameter variable">--bindir</span><span class="token operator">=</span><span class="token environment constant">PATH</span>            <span class="token function">install</span> binaries <span class="token keyword">in</span> <span class="token environment constant">PATH</span>  --with-suffix<span class="token operator">=</span>SUFFIX     suffix <span class="token keyword">for</span> QEMU data inside datadir/libdir/sysconfdir/docdir <span class="token punctuation">[</span>qemu<span class="token punctuation">]</span>  --without-default-features default all --enable-* options to <span class="token string">"disabled"</span>  --without-default-devices  <span class="token keyword">do</span> not include any device that is not needed to                           start the emulator <span class="token punctuation">(</span>only use <span class="token keyword">if</span> you are including                           desired devices <span class="token keyword">in</span> configs/devices/<span class="token punctuation">)</span>  --with-devices-ARCH<span class="token operator">=</span>NAME override default configs/devices  --enable-debug           <span class="token builtin class-name">enable</span> common debug build options  --enable-sanitizers      <span class="token builtin class-name">enable</span> default sanitizers  --enable-tsan            <span class="token builtin class-name">enable</span> thread sanitizer  --disable-werror         disable compilation abort on warning  --disable-stack-protector disable compiler-provided stack protection  <span class="token parameter variable">--cpu</span><span class="token operator">=</span>CPU                Build <span class="token keyword">for</span> <span class="token function">host</span> CPU <span class="token punctuation">[</span>x86_64<span class="token punctuation">]</span>  --with-coroutine<span class="token operator">=</span>BACKEND coroutine backend. Supported options:                           ucontext, sigaltstack, windows  --enable-plugins                           <span class="token builtin class-name">enable</span> plugins via shared library loading  --disable-containers     don't use containers <span class="token keyword">for</span> cross-building  <span class="token parameter variable">--gdb</span><span class="token operator">=</span>GDB-path           gdb to use <span class="token keyword">for</span> gdbstub tests <span class="token punctuation">[</span>/usr/bin/gdb<span class="token punctuation">]</span>  --audio-drv-list<span class="token operator">=</span>CHOICES Set audio driver list <span class="token punctuation">[</span>default<span class="token punctuation">]</span> <span class="token punctuation">(</span>choices: alsa/co                           reaudio/default/dsound/jack/oss/pa/sdl/sndio<span class="token punctuation">)</span>  --block-drv-ro-whitelist<span class="token operator">=</span>VALUE                           <span class="token builtin class-name">set</span> block driver read-only whitelist <span class="token punctuation">(</span>by default                           affects only QEMU, not tools like qemu-img<span class="token punctuation">)</span>  --block-drv-rw-whitelist<span class="token operator">=</span>VALUE                           <span class="token builtin class-name">set</span> block driver read-write whitelist <span class="token punctuation">(</span>by default                           affects only QEMU, not tools like qemu-img<span class="token punctuation">)</span>  <span class="token parameter variable">--datadir</span><span class="token operator">=</span>VALUE          Data <span class="token function">file</span> directory <span class="token punctuation">[</span>share<span class="token punctuation">]</span>  --disable-coroutine-pool coroutine freelist <span class="token punctuation">(</span>better performance<span class="token punctuation">)</span>  --disable-install-blobs  <span class="token function">install</span> provided firmware blobs  <span class="token parameter variable">--docdir</span><span class="token operator">=</span>VALUE           Base directory <span class="token keyword">for</span> documentation installation                           <span class="token punctuation">(</span>can be empty<span class="token punctuation">)</span> <span class="token punctuation">[</span>share/doc<span class="token punctuation">]</span>  --enable-block-drv-whitelist-in-tools                           use block whitelist also <span class="token keyword">in</span> tools instead of only                           QEMU  --enable-cfi             Control-Flow Integrity <span class="token punctuation">(</span>CFI<span class="token punctuation">)</span>  --enable-cfi-debug       Verbose errors <span class="token keyword">in</span> <span class="token keyword">case</span> of CFI violation  --enable-debug-mutex     mutex debugging support  --enable-debug-stack-usage                           measure coroutine stack usage  --enable-fdt<span class="token punctuation">[</span><span class="token operator">=</span>CHOICE<span class="token punctuation">]</span>    Whether and how to <span class="token function">find</span> the libfdt library                           <span class="token punctuation">(</span>choices: auto/disabled/enabled/internal/system<span class="token punctuation">)</span>  --enable-fuzzing         build fuzzing targets  --enable-gcov            Enable coverage tracking.  --enable-gprof           QEMU profiling with gprof  --enable-lto             Use <span class="token function">link</span> <span class="token function">time</span> optimization  --enable-malloc<span class="token operator">=</span>CHOICE   choose memory allocator to use <span class="token punctuation">[</span>system<span class="token punctuation">]</span> <span class="token punctuation">(</span>choices:                           jemalloc/system/tcmalloc<span class="token punctuation">)</span>  --enable-module-upgrades try to load modules from alternate paths <span class="token keyword">for</span>                           upgrades  --enable-profiler        profiler support  --enable-qom-cast-debug  cast debugging support  --enable-rng-none        dummy RNG, avoid using /dev/<span class="token punctuation">(</span>u<span class="token punctuation">)</span>random and                           getrandom<span class="token punctuation">(</span><span class="token punctuation">)</span>  --enable-strip           Strip targets on <span class="token function">install</span>  --enable-tcg-interpreter TCG with bytecode interpreter <span class="token punctuation">(</span>slow<span class="token punctuation">)</span>  --enable-trace-backends<span class="token operator">=</span>CHOICES                           Set available tracing backends <span class="token punctuation">[</span>log<span class="token punctuation">]</span> <span class="token punctuation">(</span>choices:                           dtrace/ftrace/log/nop/simple/syslog/ust<span class="token punctuation">)</span>  <span class="token parameter variable">--firmwarepath</span><span class="token operator">=</span>VALUES    search <span class="token environment constant">PATH</span> <span class="token keyword">for</span> firmware files <span class="token punctuation">[</span>share/qemu-firmware<span class="token punctuation">]</span>  <span class="token parameter variable">--iasl</span><span class="token operator">=</span>VALUE             Path to ACPI disassembler  <span class="token parameter variable">--includedir</span><span class="token operator">=</span>VALUE       Header <span class="token function">file</span> directory <span class="token punctuation">[</span>include<span class="token punctuation">]</span>  --interp-prefix<span class="token operator">=</span>VALUE    where to <span class="token function">find</span> shared libraries etc., use %M <span class="token keyword">for</span>                           cpu name <span class="token punctuation">[</span>/usr/gnemul/qemu-%M<span class="token punctuation">]</span>  <span class="token parameter variable">--libdir</span><span class="token operator">=</span>VALUE           Library directory <span class="token punctuation">[</span>lib64<span class="token punctuation">]</span>  <span class="token parameter variable">--libexecdir</span><span class="token operator">=</span>VALUE       Library executable directory <span class="token punctuation">[</span>libexec<span class="token punctuation">]</span>  <span class="token parameter variable">--localedir</span><span class="token operator">=</span>VALUE        Locale data directory <span class="token punctuation">[</span>share/locale<span class="token punctuation">]</span>  <span class="token parameter variable">--localstatedir</span><span class="token operator">=</span>VALUE    Localstate data directory <span class="token punctuation">[</span>/var/local<span class="token punctuation">]</span>  <span class="token parameter variable">--mandir</span><span class="token operator">=</span>VALUE           Manual page directory <span class="token punctuation">[</span>share/man<span class="token punctuation">]</span>  --sphinx-build<span class="token operator">=</span>VALUE     Use specified sphinx-build <span class="token keyword">for</span> building document  <span class="token parameter variable">--sysconfdir</span><span class="token operator">=</span>VALUE       Sysconf data directory <span class="token punctuation">[</span>etc<span class="token punctuation">]</span>  --tls-priority<span class="token operator">=</span>VALUE     Default TLS protocol/cipher priority string                           <span class="token punctuation">[</span>NORMAL<span class="token punctuation">]</span>  --with-pkgversion<span class="token operator">=</span>VALUE  use specified string as sub-version of the                           package  --with-trace-file<span class="token operator">=</span>VALUE  Trace <span class="token function">file</span> prefix <span class="token keyword">for</span> simple backend <span class="token punctuation">[</span>trace<span class="token punctuation">]</span>Optional features, enabled with --enable-FEATURE anddisabled with --disable-FEATURE, default is enabled <span class="token keyword">if</span> available<span class="token punctuation">(</span>unless built with --without-default-features<span class="token punctuation">)</span>:  alsa            ALSA sound support  attr            attr/xattr support  auth-pam        PAM access control  avx2            AVX2 optimizations  avx512f         AVX512F optimizations  blkio           libblkio block device driver  bochs           bochs image <span class="token function">format</span> support  bpf             eBPF support  brlapi          brlapi character device driver  <span class="token function">bzip2</span>           <span class="token function">bzip2</span> support <span class="token keyword">for</span> DMG images  canokey         CanoKey support  cap-ng          cap_ng support  capstone        Whether and how to <span class="token function">find</span> the capstone library  cloop           cloop image <span class="token function">format</span> support  cocoa           Cocoa user interface <span class="token punctuation">(</span>macOS only<span class="token punctuation">)</span>  coreaudio       CoreAudio sound support  crypto-afalg    Linux AF_ALG crypto backend driver  <span class="token function">curl</span>            CURL block device driver  curses          curses UI  dbus-display    <span class="token parameter variable">-display</span> dbus support  dmg             dmg image <span class="token function">format</span> support  docs            Documentations build support  dsound          DirectSound sound support  fuse            FUSE block device <span class="token builtin class-name">export</span>  fuse-lseek      SEEK_HOLE/SEEK_DATA support <span class="token keyword">for</span> FUSE exports  gcrypt          libgcrypt cryptography support  gettext         Localization of the GTK+ user interface  gio             use libgio <span class="token keyword">for</span> D-Bus support  glusterfs       Glusterfs block device driver  gnutls          GNUTLS cryptography support  gtk             GTK+ user interface  gtk-clipboard   clipboard support <span class="token keyword">for</span> GTK <span class="token punctuation">(</span>EXPERIMENTAL, MAY HANG<span class="token punctuation">)</span>  guest-agent     Build QEMU Guest Agent  guest-agent-msi Build MSI package <span class="token keyword">for</span> the QEMU Guest Agent  hax             HAX acceleration support  hvf             HVF acceleration support  <span class="token function">iconv</span>           Font glyph conversion support  jack            JACK sound support  keyring         Linux keyring support  kvm             KVM acceleration support  l2tpv3          l2tpv3 network backend support  libdaxctl       libdaxctl support  libiscsi        libiscsi userspace initiator  libnfs          libnfs block device driver  libpmem         libpmem support  libssh          <span class="token function">ssh</span> block device support  libudev         Use libudev to enumerate <span class="token function">host</span> devices  libusb          libusb support <span class="token keyword">for</span> USB passthrough  libvduse        build VDUSE Library  linux-aio       Linux AIO support  linux-io-uring  Linux io_uring support  live-block-migration                  block migration <span class="token keyword">in</span> the main migration stream  lzfse           lzfse support <span class="token keyword">for</span> DMG images  lzo             lzo compression support  malloc-trim     <span class="token builtin class-name">enable</span> libc malloc_trim<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> memory optimization  membarrier      membarrier system call <span class="token punctuation">(</span>for Linux <span class="token number">4.14</span>+ or Windows  mpath           Multipath persistent reservation passthrough  multiprocess    Out of process device emulation support  netmap          netmap network backend support  nettle          nettle cryptography support  numa            libnuma support  nvmm            NVMM acceleration support  opengl          OpenGL support  oss             OSS sound support  pa              PulseAudio sound support  parallels       parallels image <span class="token function">format</span> support  png             PNG support with libpng  pvrdma          Enable PVRDMA support  qcow1           qcow1 image <span class="token function">format</span> support  qed             qed image <span class="token function">format</span> support  qga-vss         build QGA VSS support <span class="token punctuation">(</span>broken with MinGW<span class="token punctuation">)</span>  rbd             Ceph block device driver  rdma            Enable RDMA-based migration  replication     replication support  sdl             SDL user interface  sdl-image       SDL Image support <span class="token keyword">for</span> icons  seccomp         seccomp support  selinux         SELinux support <span class="token keyword">in</span> qemu-nbd  slirp           libslirp user mode network backend support  slirp-smbd      use smbd <span class="token punctuation">(</span>at path <span class="token parameter variable">--smbd</span><span class="token operator">=</span>*<span class="token punctuation">)</span> <span class="token keyword">in</span> slirp networking  smartcard       CA smartcard emulation support  snappy          snappy compression support  sndio           sndio sound support  sparse          sparse checker  spice           Spice server support  spice-protocol  Spice protocol support  tcg             TCG support  tools           build support utilities that come with QEMU  tpm             TPM support  u2f             U2F emulation support  usb-redir       libusbredir support  vde             vde network backend support  vdi             vdi image <span class="token function">format</span> support  vfio-user-server                  vfio-user server support  vhost-crypto    vhost-user crypto backend support  vhost-kernel    vhost kernel backend support  vhost-net       vhost-net kernel acceleration support  vhost-user      vhost-user backend support  vhost-user-blk-server                  build vhost-user-blk server  vduse-blk-export                  VDUSE block <span class="token builtin class-name">export</span> support  vhost-vdpa      vhost-vdpa kernel backend support  virglrenderer   virgl rendering support  virtfs          virtio-9p support  virtiofsd       build virtiofs daemon <span class="token punctuation">(</span>virtiofsd<span class="token punctuation">)</span>  vmnet           vmnet.framework network backend support  vnc             VNC server  vnc-jpeg        JPEG lossy compression <span class="token keyword">for</span> VNC server  vnc-sasl        SASL authentication <span class="token keyword">for</span> VNC server  vte             vte support <span class="token keyword">for</span> the gtk UI  vvfat           vvfat image <span class="token function">format</span> support  whpx            WHPX acceleration support  xen             Xen backend support  xen-pci-passthrough                  Xen PCI passthrough support  xkbcommon       xkbcommon support  zstd            zstd compression support  system          all system emulation targets  user            supported user emulation targets  linux-user      all linux usermode emulation targets  bsd-user        all BSD usermode emulation targets  pie             Position Independent Executables  modules         modules support <span class="token punctuation">(</span>non-Windows<span class="token punctuation">)</span>  debug-tcg       TCG debugging <span class="token punctuation">(</span>default is disabled<span class="token punctuation">)</span>  debug-info      debugging information  safe-stack      SafeStack Stack Smash Protection. Depends on                  clang/llvm <span class="token operator">&gt;=</span> <span class="token number">3.7</span> and requires coroutine backend ucontext.NOTE: The object files are built at the place where configure is launched<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>全量配置如下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> qemu-7.2.0➜  qemu-7.2.0 ./configureUsing <span class="token string">'./build'</span> as the directory <span class="token keyword">for</span> build outputThe Meson build systemVersion: <span class="token number">0.61</span>.5Source dir: /home/jack/Desktop/linux/qemu-7.2.0Build dir: /home/jack/Desktop/linux/qemu-7.2.0/buildBuild type: native buildProject name: qemuProject version: <span class="token number">7.2</span>.0C compiler <span class="token keyword">for</span> the <span class="token function">host</span> machine: cc <span class="token parameter variable">-m64</span> <span class="token parameter variable">-mcx16</span> <span class="token punctuation">(</span>gcc <span class="token number">11.3</span>.0 <span class="token string">"cc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0"</span><span class="token punctuation">)</span>C linker <span class="token keyword">for</span> the <span class="token function">host</span> machine: cc <span class="token parameter variable">-m64</span> <span class="token parameter variable">-mcx16</span> ld.bfd <span class="token number">2.38</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>Found ninja-1.10.1 at /usr/bin/ninjaRunning postconf script <span class="token string">'/usr/bin/python3 /home/jack/Desktop/linux/qemu-7.2.0/scripts/symlink-install-tree.py'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>全量配置编译比较耗费时间，如果只需要模拟arm环境，可以使用如下配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 32位arm配置</span>./configure --target-list<span class="token operator">=</span>arm-softmmu --audio-drv-list<span class="token operator">=</span><span class="token comment"># aarch64配置</span>./configure --target-list<span class="token operator">=</span>aarch64-softmmu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>make</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  qemu-7.2.0 <span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token number">64</span>changing <span class="token function">dir</span> to build <span class="token keyword">for</span> <span class="token function">make</span> <span class="token string">""</span><span class="token punctuation">..</span>.make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/jack/Desktop/linux/qemu-7.2.0/build'</span>/usr/bin/ninja  build.ninja <span class="token operator">&amp;&amp;</span> <span class="token function">touch</span> build.ninja.stampninja: no work to do./usr/bin/python3 <span class="token parameter variable">-B</span> /home/jack/Desktop/linux/qemu-7.2.0/meson/meson.py introspect <span class="token parameter variable">--targets</span> <span class="token parameter variable">--tests</span> <span class="token parameter variable">--benchmarks</span> <span class="token operator">|</span> /usr/bin/python3 <span class="token parameter variable">-B</span> scripts/mtest2make.py <span class="token operator">&gt;</span> Makefile.mtest<span class="token punctuation">[</span><span class="token number">1</span>/9860<span class="token punctuation">]</span> Compiling C object subprojects/libvhost-user/link-test.p/link-test.c.o<span class="token punctuation">[</span><span class="token number">2</span>/9860<span class="token punctuation">]</span> Compiling C object libfdt.a.p/dtc_libfdt_fdt_wip.c.o<span class="token punctuation">[</span><span class="token number">3</span>/9860<span class="token punctuation">]</span> Compiling C object libfdt.a.p/dtc_libfdt_fdt_strerror.c.o<span class="token punctuation">[</span><span class="token number">4</span>/9860<span class="token punctuation">]</span> Compiling C object libfdt.a.p/dtc_libfdt_fdt_empty_tree.c.o<span class="token punctuation">[</span><span class="token number">5</span>/9860<span class="token punctuation">]</span> Compiling C object libfdt.a.p/dtc_libfdt_fdt_addresses.c.o<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">[</span><span class="token number">9858</span>/9860<span class="token punctuation">]</span> Linking target qemu-xtensa<span class="token punctuation">[</span><span class="token number">9859</span>/9860<span class="token punctuation">]</span> Compiling C object libqemu-xtensaeb-linux-user.fa.p/target_xtensa_core-dsp3400.c.o<span class="token punctuation">[</span><span class="token number">9860</span>/9860<span class="token punctuation">]</span> Linking target qemu-xtensaebmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/jack/Desktop/linux/qemu-7.2.0/build'</span>changing <span class="token function">dir</span> to build <span class="token keyword">for</span> <span class="token function">make</span> <span class="token string">""</span><span class="token punctuation">..</span>.make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/jack/Desktop/linux/qemu-7.2.0/build'</span><span class="token punctuation">[</span><span class="token number">1</span>/150<span class="token punctuation">]</span> Generating tests/include/QAPI <span class="token builtin class-name">test</span> <span class="token punctuation">(</span>include<span class="token punctuation">)</span> with a custom <span class="token builtin class-name">command</span><span class="token punctuation">[</span><span class="token number">2</span>/118<span class="token punctuation">]</span> Generating qemu-version.h with a custom <span class="token builtin class-name">command</span> <span class="token punctuation">(</span>wrapped by meson to capture output<span class="token punctuation">)</span>make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/jack/Desktop/linux/qemu-7.2.0/build'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>安装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  qemu-7.2.0 <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> jack:changing <span class="token function">dir</span> to build <span class="token keyword">for</span> <span class="token function">make</span> <span class="token string">"install"</span><span class="token punctuation">..</span>.make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/jack/Desktop/linux/qemu-7.2.0/build'</span><span class="token punctuation">[</span><span class="token number">1</span>/118<span class="token punctuation">]</span> Generating qemu-version.h with a custom <span class="token builtin class-name">command</span> <span class="token punctuation">(</span>wrapped by meson to capture output<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span>/2<span class="token punctuation">]</span> Installing files.Installing trace/trace-events-all to /usr/local/share/qemuInstalling fsdev/virtfs-proxy-helper to /usr/local/libexecInstalling qemu-system-aarch64 to /usr/local/binInstalling qemu-system-alpha to /usr/local/binInstalling qemu-system-arm to /usr/local/binInstalling qemu-system-avr to /usr/local/bin<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>Installing /home/jack/Desktop/linux/qemu-7.2.0/pc-bios/keymaps/tr to /usr/local/share/qemu/keymapsInstalling /home/jack/Desktop/linux/qemu-7.2.0/pc-bios/keymaps/sl to /usr/local/share/qemu/keymapsInstalling /home/jack/Desktop/linux/qemu-7.2.0/pc-bios/keymaps/sv to /usr/local/share/qemu/keymapsmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/jack/Desktop/linux/qemu-7.2.0/build'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  qemu-7.2.0 /usr/local/bin/qemu-system-aarch64 <span class="token parameter variable">--version</span>QEMU emulator version <span class="token number">7.2</span>.0Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2003</span>-2022 Fabrice Bellard and the QEMU Project developers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="3-制作根文件系统rootfs"><a href="#3-制作根文件系统rootfs" class="headerlink" title="3 制作根文件系统rootfs"></a>3 制作根文件系统rootfs</h1><h3 id="3-1-下载busybox源码："><a href="#3-1-下载busybox源码：" class="headerlink" title="3.1 下载busybox源码："></a>3.1 下载busybox源码：</h3><p><a href="http://busybox.net/downloads/">官网</a></p><ol><li>依赖库安装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libncurses5-dev libncursesw5-dev <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>下载源码</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://busybox.net/downloads/busybox-1.36.0.tar.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>解压</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> jxvf busybox-1.36.0.tar.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-配置busybox"><a href="#3-2-配置busybox" class="headerlink" title="3.2 配置busybox"></a>3.2 配置busybox</h3><p>指定编译工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> busybox-1.36.0/<span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm64<span class="token builtin class-name">export</span> <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>aarch64-linux-gnu-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>打开静态库编译选项,保存后退出</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> menuconfigSettings ---<span class="token operator">&gt;</span> <span class="token punctuation">[</span>*<span class="token punctuation">]</span> Build static binary <span class="token punctuation">(</span>no shared libs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../../../images/linux/%E4%BD%BF%E7%94%A8qemu%E6%90%AD%E5%BB%BAARM64%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20230320205448996.png" alt="image-20230320205448996"></p><h3 id="3-3-编译"><a href="#3-3-编译" class="headerlink" title="3.3 编译"></a>3.3 编译</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  busybox-1.36.0 <span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token number">64</span>  SPLIT   include/autoconf.h -<span class="token operator">&gt;</span> include/config/*  GEN     include/bbconfigopts.h  GEN     include/common_bufsiz.h  GEN     include/embedded_scripts.h  HOSTCC  applets/usage  HOSTCC  applets/applet_tablesapplets/usage.c: In <span class="token keyword">function</span> ‘main’:<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>Static linking against glibc, can<span class="token string">'t use --gc-sectionsTrying libraries: m resolv rt Library m is needed, can'</span>t exclude it <span class="token punctuation">(</span>yet<span class="token punctuation">)</span> Library resolv is needed, can<span class="token string">'t exclude it (yet) Library rt is not needed, excluding it Library m is needed, can'</span>t exclude it <span class="token punctuation">(</span>yet<span class="token punctuation">)</span> Library resolv is needed, can't exclude it <span class="token punctuation">(</span>yet<span class="token punctuation">)</span>Final <span class="token function">link</span> with: m resolv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  busybox-1.36.0 <span class="token function">make</span> <span class="token function">install</span>  ./_install//bin/arch -<span class="token operator">&gt;</span> busybox  ./_install//bin/ash -<span class="token operator">&gt;</span> busybox  ./_install//bin/base32 -<span class="token operator">&gt;</span> busybox  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>    ./_install//usr/sbin/tftpd -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin/busybox  ./_install//usr/sbin/ubiattach -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin/busybox  ./_install//usr/sbin/ubidetach -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin/busybox  ./_install//usr/sbin/ubimkvol -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin/busybox  ./_install//usr/sbin/ubirename -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin/busybox  ./_install//usr/sbin/ubirmvol -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin/busybox  ./_install//usr/sbin/ubirsvol -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin/busybox  ./_install//usr/sbin/ubiupdatevol -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin/busybox  ./_install//usr/sbin/udhcpd -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin/busybox--------------------------------------------------You will probably need to <span class="token function">make</span> your busybox binarysetuid root to ensure all configured applets willwork properly.--------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>编译过程报错的话，把相应项去掉即可；编译完成，在busybox生成_install目录</p></blockquote><h3 id="3-4-补充rootfs目录结构"><a href="#3-4-补充rootfs目录结构" class="headerlink" title="3.4 补充rootfs目录结构"></a>3.4 补充rootfs目录结构</h3><p>1 根目录添加etc、dev和lib目录</p><p>etc目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  busybox-1.36.0 <span class="token builtin class-name">cd</span> _install➜  _install <span class="token builtin class-name">pwd</span>/home/jack/Desktop/linux/busybox-1.36.0/_install➜  _install <span class="token function">ls</span> bin   linuxrc   sbin   usr➜  _install <span class="token function">mkdir</span> etc dev lib➜  _install <span class="token function">ls</span> bin   dev   etc   lib   linuxrc   sbin   usr➜  _install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在etc分别创建文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  _install cat<span class="token operator">&gt;</span>etc/profile <span class="token operator">&lt;&lt;</span> <span class="token string">EOFexport HOSTNAME=myQEMUexport USER=rootexport HOME=/homeexport PS1="[<span class="token environment constant">$USER</span>@<span class="token environment constant">$HOSTNAME</span> \W]\# "PATH=/bin:/sbin:/usr/bin:/usr/sbinLD_LIBRARY_PATH=/lib:/usr/lib:<span class="token variable">$LD_LIBRARY_PATH</span>export PATH LD_LIBRARY_PATHEOF</span>➜  _install <span class="token function">cat</span> etc/profile<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">HOSTNAME</span></span><span class="token operator">=</span>myQEMU<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span>root<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span>/home<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">"[jack@ \W]\# "</span><span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin<span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>/lib:/usr/lib:<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span> LD_LIBRARY_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  _install cat<span class="token operator">&gt;</span>etc/fstab <span class="token operator">&lt;&lt;</span> <span class="token string">EOFproc /proc proc defaults 0 0tmpfs /tmp tmpfs defaults 0 0sysfs /sys sysfs defaults 0 0tmpfs /dev tmpfs defaults 0 0debugfs /sys/kernel/debug debugfs defaults 0 0kmod_mount /mnt 9p trans=virtio 0 0EOF</span>➜  _install <span class="token function">cat</span> etc/fstabproc /proc proc defaults <span class="token number">0</span> <span class="token number">0</span>tmpfs /tmp tmpfs defaults <span class="token number">0</span> <span class="token number">0</span>sysfs /sys sysfs defaults <span class="token number">0</span> <span class="token number">0</span>tmpfs /dev tmpfs defaults <span class="token number">0</span> <span class="token number">0</span>debugfs /sys/kernel/debug debugfs defaults <span class="token number">0</span> <span class="token number">0</span>kmod_mount /mnt 9p <span class="token assign-left variable">trans</span><span class="token operator">=</span>virtio <span class="token number">0</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  _install cat<span class="token operator">&gt;</span>etc/inittab <span class="token operator">&lt;&lt;</span> <span class="token string">EOF::sysinit:/etc/init.d/rcS::respawn:-/bin/sh::respawn:-/bin/sh::ctrlaltdel:/bin/umount -a -rEOF</span>➜  _install <span class="token function">cat</span> etc/inittab::sysinit:/etc/init.d/rcS::respawn:-/bin/sh::askfirst:-/bin/sh::ctrlaltdel:/bin/umount <span class="token parameter variable">-a</span> <span class="token parameter variable">-r</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定挂载的文件系统</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  _install <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> etc/init.d➜  _install cat<span class="token operator">&gt;</span>etc/init.d/rcS <span class="token operator">&lt;&lt;</span> <span class="token string">EOFmkdir -p /sysmkdir -p /tmpmkdir -p /procmkdir -p /mnt/bin/mount -amkdir -p /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -sEOF</span>➜  _install <span class="token function">chmod</span> +x etc/init.d/rcS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dev目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  _install <span class="token builtin class-name">cd</span> dev➜  dev <span class="token function">sudo</span> <span class="token function">mknod</span> console c <span class="token number">5</span> <span class="token number">1</span>➜  dev <span class="token function">sudo</span> <span class="token function">mknod</span> null c <span class="token number">1</span> <span class="token number">3</span>➜  dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>lib目录：拷贝lib库，支持动态编译的应用程序运行</p><pre class="line-numbers language-none"><code class="language-none">➜  dev cd ../lib➜  lib cp /usr/aarch64-linux-gnu/lib/*.so*  -a .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="4-编译内核"><a href="#4-编译内核" class="headerlink" title="4 编译内核"></a>4 编译内核</h1><h2 id="4-1-下载代码"><a href="#4-1-下载代码" class="headerlink" title="4.1 下载代码"></a>4.1 下载代码</h2><p><a href="https://www.kernel.org/">官网下载</a>,或者使用下列方法下载</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/luteresa/linux.git <span class="token comment"># 方法1</span><span class="token function">git</span> clone https://gitee.com/mirrors/linux_old1.git <span class="token comment"># 方法2</span><span class="token function">wget</span> https://mirrors.aliyun.com/linux-kernel/v6.x/linux-6.2.tar.gz <span class="token comment"># 方法3</span><span class="token function">wget</span> https://mirrors.edge.kernel.org/pub/linux/kernel/v6.x/linux-6.2.tar.gz <span class="token comment">#方法4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-指定编译工具"><a href="#4-2-指定编译工具" class="headerlink" title="4.2 指定编译工具"></a>4.2 指定编译工具</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> linux➜  linux git:<span class="token punctuation">(</span>master<span class="token punctuation">)</span> <span class="token function">git</span> checkout v6.2➜  linux git:<span class="token punctuation">(</span>v6.2<span class="token punctuation">)</span> <span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm64➜  linux git:<span class="token punctuation">(</span>v6.2<span class="token punctuation">)</span> <span class="token builtin class-name">export</span> <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>aarch64-linux-gnu-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-配置内核"><a href="#4-3-配置内核" class="headerlink" title="4.3 配置内核"></a>4.3 配置内核</h2><p>这里采用ARM公司提供的arm64 a57；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  linux git:<span class="token punctuation">(</span>v6.2<span class="token punctuation">)</span> <span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-ra</span> <span class="token punctuation">..</span>/busybox-1.36.0/_install ./_install_arm64➜  linux git:<span class="token punctuation">(</span>v6.2<span class="token punctuation">)</span> <span class="token function">cp</span> arch/arm64/configs/defconfig .config➜  linux git:<span class="token punctuation">(</span>v6.2<span class="token punctuation">)</span> <span class="token function">make</span> menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-1-添加hotplug支持："><a href="#4-3-1-添加hotplug支持：" class="headerlink" title="4.3.1 添加hotplug支持："></a>4.3.1 添加hotplug支持：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Device Drivers                                                                                             -<span class="token operator">&gt;</span> Generic Driver Options                                                                                    -<span class="token operator">&gt;</span> Support <span class="token keyword">for</span> uevent helper                                                                                                                <span class="token punctuation">(</span>/sbin/hotplug<span class="token punctuation">)</span> path to uevent helper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../../../images/linux/%E4%BD%BF%E7%94%A8qemu%E6%90%AD%E5%BB%BAARM64%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20230320221529703.png" alt="image-20230320221529703"></p><h3 id="4-3-2-添加initramfs的支持："><a href="#4-3-2-添加initramfs的支持：" class="headerlink" title="4.3.2 添加initramfs的支持："></a>4.3.2 添加initramfs的支持：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">General setup ---<span class="token operator">&gt;</span><span class="token punctuation">[</span>*<span class="token punctuation">]</span>Initial RAM filesystem and RAM disk<span class="token punctuation">(</span>initramfs/initrd<span class="token punctuation">)</span> support<span class="token punctuation">(</span>_install_arm64<span class="token punctuation">)</span> Initramfs souce file<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../../../images/linux/%E4%BD%BF%E7%94%A8qemu%E6%90%AD%E5%BB%BAARM64%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20230320221728590.png" alt="image-20230320221728590"></p><h3 id="4-3-3-内核页配"><a href="#4-3-3-内核页配" class="headerlink" title="4.3.3 内核页配"></a>4.3.3 内核页配</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Kernel Features  ---<span class="token operator">&gt;</span>Page size<span class="token punctuation">(</span>4KB<span class="token punctuation">)</span>  ---<span class="token operator">&gt;</span>Virtual address space size<span class="token punctuation">(</span><span class="token number">48</span>-bit<span class="token punctuation">)</span>---<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-4-文件系统配置："><a href="#4-3-4-文件系统配置：" class="headerlink" title="4.3.4 文件系统配置："></a>4.3.4 文件系统配置：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Kernel hacking  ---<span class="token operator">&gt;</span>  Generic Kernel Debugging Instruments  ---<span class="token operator">&gt;</span>    <span class="token punctuation">[</span>*<span class="token punctuation">]</span> Debug Filesystem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../../../images/linux/%E4%BD%BF%E7%94%A8qemu%E6%90%AD%E5%BB%BAARM64%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20230320221954863.png" alt="image-20230320221954863"></p><h2 id="4-4-编译"><a href="#4-4-编译" class="headerlink" title="4.4 编译"></a>4.4 编译</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> all <span class="token parameter variable">-j64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内核根目录下添加共享目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> kmodules<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-5-2启动Linux"><a href="#4-5-2启动Linux" class="headerlink" title="4.5 2启动Linux"></a>4.5 2启动Linux</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-aarch64 <span class="token parameter variable">-machine</span> virt <span class="token parameter variable">-cpu</span> cortex-a57 <span class="token parameter variable">-machine</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>virt <span class="token parameter variable">-m</span> <span class="token number">1024</span> <span class="token parameter variable">-smp</span> <span class="token number">4</span> <span class="token parameter variable">-kernel</span> arch/arm64/boot/Image <span class="token parameter variable">--append</span> <span class="token string">"rdinit=/linuxrc root=/dev/vda rw console=ttyAMA0 loglevel=8"</span>  <span class="token parameter variable">-nographic</span> <span class="token parameter variable">--fsdev</span> local,id<span class="token operator">=</span>kmod_dev,path<span class="token operator">=</span><span class="token environment constant">$PWD</span>/kmodules,security_model<span class="token operator">=</span>none <span class="token parameter variable">-device</span> virtio-9p-device,fsdev<span class="token operator">=</span>kmod_dev,mount_tag<span class="token operator">=</span>kmod_mount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>-cpu指定模拟的cpu为 cortex-a57，</p></li><li><p>-m 1024 指定内存大小为１Ｇ,</p></li><li><p>-smp4指定模拟的系统为４核处理器 ，</p></li><li><p>-kernel指定启动的内核镜像，</p></li><li><p>–append指定传递的命令行参数，</p></li><li><p>后面的选项指定共享目录已经使用的9P协议。</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  linux-6.2 qemu-system-aarch64 <span class="token parameter variable">-machine</span> virt <span class="token parameter variable">-cpu</span> cortex-a57 <span class="token parameter variable">-machine</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>virt <span class="token parameter variable">-m</span> <span class="token number">1024</span> <span class="token parameter variable">-smp</span> <span class="token number">4</span> <span class="token parameter variable">-kernel</span> arch/arm64/boot/Image <span class="token parameter variable">--append</span> <span class="token string">"rdinit=/linuxrc root=/dev/vda rw console=ttyAMA0 loglevel=8"</span>  <span class="token parameter variable">-nographic</span> <span class="token parameter variable">--fsdev</span> local,id<span class="token operator">=</span>kmod_dev,path<span class="token operator">=</span><span class="token environment constant">$PWD</span>/kmodules,security_model<span class="token operator">=</span>none <span class="token parameter variable">-device</span> virtio-9p-device,fsdev<span class="token operator">=</span>kmod_dev,mount_tag<span class="token operator">=</span>kmod_mount<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Booting Linux on physical CPU 0x0000000000 <span class="token punctuation">[</span>0x411fd070<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Linux version <span class="token number">6.2</span>.0 <span class="token punctuation">(</span>jack@jack-HP<span class="token punctuation">)</span> <span class="token punctuation">(</span>aarch64-linux-gnu-gcc <span class="token punctuation">(</span>Ubuntu <span class="token number">11.3</span>.0-1ubuntu1~22.04<span class="token punctuation">)</span> <span class="token number">11.3</span>.0, GNU ld <span class="token punctuation">(</span>GNU Binutils <span class="token keyword">for</span> Ubuntu<span class="token punctuation">)</span> <span class="token number">2.38</span><span class="token punctuation">)</span> <span class="token comment">#1 SMP PREEMPT Tue Mar 21 21:27:39 CST 2023</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> random: crng init <span class="token keyword">done</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Machine model: linux,dummy-virt<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> efi: UEFI not found.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> NUMA: No NUMA configuration found<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> NUMA: Faking a <span class="token function">node</span> at <span class="token punctuation">[</span>mem 0x0000000040000000-0x000000007fffffff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> NUMA: NODE_DATA <span class="token punctuation">[</span>mem 0x7fdeea00-0x7fdf0fff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Zone ranges:<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span>   DMA      <span class="token punctuation">[</span>mem 0x0000000040000000-0x000000007fffffff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span>   DMA32    empty<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span>   Normal   empty<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Movable zone start <span class="token keyword">for</span> each <span class="token function">node</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Early memory <span class="token function">node</span> ranges<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span>   <span class="token function">node</span>   <span class="token number">0</span>: <span class="token punctuation">[</span>mem 0x0000000040000000-0x000000007fffffff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Initmem setup <span class="token function">node</span> <span class="token number">0</span> <span class="token punctuation">[</span>mem 0x0000000040000000-0x000000007fffffff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> cma: Reserved <span class="token number">32</span> MiB at 0x000000007cc00000<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> psci: probing <span class="token keyword">for</span> conduit method from DT.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> psci: PSCIv1.1 detected <span class="token keyword">in</span> firmware.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> psci: Using standard PSCI v0.2 <span class="token keyword">function</span> IDs<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> psci: Trusted OS migration not required<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> psci: SMC Calling Convention v1.0<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> percpu: Embedded <span class="token number">21</span> pages/cpu s45672 r8192 d32152 u86016<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> pcpu-alloc: s45672 r8192 d32152 u86016 <span class="token assign-left variable">alloc</span><span class="token operator">=</span><span class="token number">21</span>*4096<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> pcpu-alloc: <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token number">2</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token number">3</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Detected PIPT I-cache on CPU0<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: detected: Spectre-v2<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: detected: Spectre-v3a<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: detected: Spectre-v4<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: detected: Spectre-BHB<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: kernel page table isolation forced ON by KASLR<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: detected: Kernel page table isolation <span class="token punctuation">(</span>KPTI<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: detected: ARM erratum <span class="token number">834220</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: detected: ARM erratum <span class="token number">1742098</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: detected: ARM erratum <span class="token number">832075</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> CPU features: detected: ARM errata <span class="token number">1165522</span>, <span class="token number">1319367</span>, or <span class="token number">1530923</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> alternatives: applying boot alternatives<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Fallback order <span class="token keyword">for</span> Node <span class="token number">0</span>: <span class="token number">0</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Built <span class="token number">1</span> zonelists, mobility grouping on.  Total pages: <span class="token number">258048</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Policy zone: DMA<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Kernel <span class="token builtin class-name">command</span> line: <span class="token assign-left variable">rdinit</span><span class="token operator">=</span>/linuxrc <span class="token assign-left variable">root</span><span class="token operator">=</span>/dev/vda rw <span class="token assign-left variable">console</span><span class="token operator">=</span>ttyAMA0 <span class="token assign-left variable">loglevel</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Dentry cache <span class="token builtin class-name">hash</span> table entries: <span class="token number">131072</span> <span class="token punctuation">(</span>order: <span class="token number">8</span>, <span class="token number">1048576</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Inode-cache <span class="token builtin class-name">hash</span> table entries: <span class="token number">65536</span> <span class="token punctuation">(</span>order: <span class="token number">7</span>, <span class="token number">524288</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> mem auto-init: stack:off, heap alloc:off, heap free:off<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Memory: 943660K/1048576K available <span class="token punctuation">(</span>16256K kernel code, 3884K rwdata, 9552K rodata, 20224K init, 608K bss, 72148K reserved, 32768K cma-reserved<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> SLUB: <span class="token assign-left variable">HWalign</span><span class="token operator">=</span><span class="token number">64</span>, <span class="token assign-left variable">Order</span><span class="token operator">=</span><span class="token number">0</span>-3, <span class="token assign-left variable">MinObjects</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">CPUs</span><span class="token operator">=</span><span class="token number">4</span>, <span class="token assign-left variable">Nodes</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> rcu: Preemptible hierarchical RCU implementation.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> rcu: RCU event tracing is enabled.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> rcu: RCU restricting CPUs from <span class="token assign-left variable">NR_CPUS</span><span class="token operator">=</span><span class="token number">256</span> to <span class="token assign-left variable">nr_cpu_ids</span><span class="token operator">=</span><span class="token number">4</span>.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Trampoline variant of Tasks RCU enabled.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Tracing variant of Tasks RCU enabled.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> rcu: RCU calculated value of scheduler-enlistment delay is <span class="token number">25</span> jiffies.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> rcu: Adjusting geometry <span class="token keyword">for</span> <span class="token assign-left variable">rcu_fanout_leaf</span><span class="token operator">=</span><span class="token number">16</span>, <span class="token assign-left variable">nr_cpu_ids</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> NR_IRQS: <span class="token number">64</span>, nr_irqs: <span class="token number">64</span>, preallocated irqs: <span class="token number">0</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Root IRQ handler: gic_handle_irq<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> GICv2m: range<span class="token punctuation">[</span>mem 0x08020000-0x08020fff<span class="token punctuation">]</span>, SPI<span class="token punctuation">[</span><span class="token number">80</span>:143<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> rcu: srcu_init: Setting srcu_struct sizes based on contention.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> arch_timer: cp15 timer<span class="token punctuation">(</span>s<span class="token punctuation">)</span> running at <span class="token number">62</span>.50MHz <span class="token punctuation">(</span>virt<span class="token punctuation">)</span>.<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> clocksource: arch_sys_counter: mask: 0x1ffffffffffffff max_cycles: 0x1cd42e208c, max_idle_ns: <span class="token number">881590405314</span> ns<span class="token punctuation">[</span>    <span class="token number">0.000107</span><span class="token punctuation">]</span> sched_clock: <span class="token number">57</span> bits at 63MHz, resolution 16ns, wraps every 4398046511096ns<span class="token punctuation">[</span>    <span class="token number">0.011187</span><span class="token punctuation">]</span> Console: colour dummy device 80x25<span class="token punctuation">[</span>    <span class="token number">0.013991</span><span class="token punctuation">]</span> Calibrating delay loop <span class="token punctuation">(</span>skipped<span class="token punctuation">)</span>, value calculated using timer frequency<span class="token punctuation">..</span> <span class="token number">125.00</span> BogoMIPS <span class="token punctuation">(</span>lpj<span class="token operator">=</span><span class="token number">250000</span><span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.014168</span><span class="token punctuation">]</span> pid_max: default: <span class="token number">32768</span> minimum: <span class="token number">301</span><span class="token punctuation">[</span>    <span class="token number">0.015504</span><span class="token punctuation">]</span> LSM: initializing <span class="token assign-left variable">lsm</span><span class="token operator">=</span>capability,integrity<span class="token punctuation">[</span>    <span class="token number">0.018576</span><span class="token punctuation">]</span> Mount-cache <span class="token builtin class-name">hash</span> table entries: <span class="token number">2048</span> <span class="token punctuation">(</span>order: <span class="token number">2</span>, <span class="token number">16384</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.018636</span><span class="token punctuation">]</span> Mountpoint-cache <span class="token builtin class-name">hash</span> table entries: <span class="token number">2048</span> <span class="token punctuation">(</span>order: <span class="token number">2</span>, <span class="token number">16384</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.053625</span><span class="token punctuation">]</span> cacheinfo: Unable to detect cache hierarchy <span class="token keyword">for</span> CPU <span class="token number">0</span><span class="token punctuation">[</span>    <span class="token number">0.061482</span><span class="token punctuation">]</span> cblist_init_generic: Setting adjustable number of callback queues.<span class="token punctuation">[</span>    <span class="token number">0.061700</span><span class="token punctuation">]</span> cblist_init_generic: Setting <span class="token builtin class-name">shift</span> to <span class="token number">2</span> and lim to <span class="token number">1</span>.<span class="token punctuation">[</span>    <span class="token number">0.062121</span><span class="token punctuation">]</span> cblist_init_generic: Setting <span class="token builtin class-name">shift</span> to <span class="token number">2</span> and lim to <span class="token number">1</span>.<span class="token punctuation">[</span>    <span class="token number">0.064514</span><span class="token punctuation">]</span> rcu: Hierarchical SRCU implementation.<span class="token punctuation">[</span>    <span class="token number">0.064582</span><span class="token punctuation">]</span> rcu: Max phase no-delay instances is <span class="token number">1000</span>.<span class="token punctuation">[</span>    <span class="token number">0.071040</span><span class="token punctuation">]</span> EFI services will not be available.<span class="token punctuation">[</span>    <span class="token number">0.073826</span><span class="token punctuation">]</span> smp: Bringing up secondary CPUs <span class="token punctuation">..</span>.<span class="token punctuation">[</span>    <span class="token number">0.079401</span><span class="token punctuation">]</span> Detected PIPT I-cache on CPU1<span class="token punctuation">[</span>    <span class="token number">0.080875</span><span class="token punctuation">]</span> cacheinfo: Unable to detect cache hierarchy <span class="token keyword">for</span> CPU <span class="token number">1</span><span class="token punctuation">[</span>    <span class="token number">0.081736</span><span class="token punctuation">]</span> CPU1: Booted secondary processor 0x0000000001 <span class="token punctuation">[</span>0x411fd070<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.088068</span><span class="token punctuation">]</span> Detected PIPT I-cache on CPU2<span class="token punctuation">[</span>    <span class="token number">0.088573</span><span class="token punctuation">]</span> cacheinfo: Unable to detect cache hierarchy <span class="token keyword">for</span> CPU <span class="token number">2</span><span class="token punctuation">[</span>    <span class="token number">0.089033</span><span class="token punctuation">]</span> CPU2: Booted secondary processor 0x0000000002 <span class="token punctuation">[</span>0x411fd070<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.091308</span><span class="token punctuation">]</span> Detected PIPT I-cache on CPU3<span class="token punctuation">[</span>    <span class="token number">0.091565</span><span class="token punctuation">]</span> cacheinfo: Unable to detect cache hierarchy <span class="token keyword">for</span> CPU <span class="token number">3</span><span class="token punctuation">[</span>    <span class="token number">0.091766</span><span class="token punctuation">]</span> CPU3: Booted secondary processor 0x0000000003 <span class="token punctuation">[</span>0x411fd070<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.092614</span><span class="token punctuation">]</span> smp: Brought up <span class="token number">1</span> node, <span class="token number">4</span> CPUs<span class="token punctuation">[</span>    <span class="token number">0.092669</span><span class="token punctuation">]</span> SMP: Total of <span class="token number">4</span> processors activated.<span class="token punctuation">[</span>    <span class="token number">0.092776</span><span class="token punctuation">]</span> CPU features: detected: <span class="token number">32</span>-bit EL0 Support<span class="token punctuation">[</span>    <span class="token number">0.092805</span><span class="token punctuation">]</span> CPU features: detected: <span class="token number">32</span>-bit EL1 Support<span class="token punctuation">[</span>    <span class="token number">0.092886</span><span class="token punctuation">]</span> CPU features: detected: CRC32 instructions<span class="token punctuation">[</span>    <span class="token number">0.096187</span><span class="token punctuation">]</span> CPU: All CPU<span class="token punctuation">(</span>s<span class="token punctuation">)</span> started at EL1<span class="token punctuation">[</span>    <span class="token number">0.096404</span><span class="token punctuation">]</span> alternatives: applying system-wide alternatives<span class="token punctuation">[</span>    <span class="token number">0.136078</span><span class="token punctuation">]</span> devtmpfs: initialized<span class="token punctuation">[</span>    <span class="token number">0.154495</span><span class="token punctuation">]</span> clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: <span class="token number">7645041785100000</span> ns<span class="token punctuation">[</span>    <span class="token number">0.154957</span><span class="token punctuation">]</span> futex <span class="token builtin class-name">hash</span> table entries: <span class="token number">1024</span> <span class="token punctuation">(</span>order: <span class="token number">4</span>, <span class="token number">65536</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.160467</span><span class="token punctuation">]</span> pinctrl core: initialized pinctrl subsystem<span class="token punctuation">[</span>    <span class="token number">0.174737</span><span class="token punctuation">]</span> DMI not present or invalid.<span class="token punctuation">[</span>    <span class="token number">0.185657</span><span class="token punctuation">]</span> NET: Registered PF_NETLINK/PF_ROUTE protocol family<span class="token punctuation">[</span>    <span class="token number">0.199069</span><span class="token punctuation">]</span> DMA: preallocated <span class="token number">128</span> KiB GFP_KERNEL pool <span class="token keyword">for</span> atomic allocations<span class="token punctuation">[</span>    <span class="token number">0.200753</span><span class="token punctuation">]</span> DMA: preallocated <span class="token number">128</span> KiB GFP_KERNEL<span class="token operator">|</span>GFP_DMA pool <span class="token keyword">for</span> atomic allocations<span class="token punctuation">[</span>    <span class="token number">0.201157</span><span class="token punctuation">]</span> DMA: preallocated <span class="token number">128</span> KiB GFP_KERNEL<span class="token operator">|</span>GFP_DMA32 pool <span class="token keyword">for</span> atomic allocations<span class="token punctuation">[</span>    <span class="token number">0.201527</span><span class="token punctuation">]</span> audit: initializing netlink subsys <span class="token punctuation">(</span>disabled<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.204521</span><span class="token punctuation">]</span> audit: <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token number">2000</span> audit<span class="token punctuation">(</span><span class="token number">0.172</span>:1<span class="token punctuation">)</span>: <span class="token assign-left variable">state</span><span class="token operator">=</span>initialized <span class="token assign-left variable">audit_enabled</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">res</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">[</span>    <span class="token number">0.210761</span><span class="token punctuation">]</span> thermal_sys: Registered thermal governor <span class="token string">'step_wise'</span><span class="token punctuation">[</span>    <span class="token number">0.210828</span><span class="token punctuation">]</span> thermal_sys: Registered thermal governor <span class="token string">'power_allocator'</span><span class="token punctuation">[</span>    <span class="token number">0.211435</span><span class="token punctuation">]</span> cpuidle: using governor menu<span class="token punctuation">[</span>    <span class="token number">0.213098</span><span class="token punctuation">]</span> hw-breakpoint: found <span class="token number">6</span> breakpoint and <span class="token number">4</span> watchpoint registers.<span class="token punctuation">[</span>    <span class="token number">0.214321</span><span class="token punctuation">]</span> ASID allocator initialised with <span class="token number">32768</span> entries<span class="token punctuation">[</span>    <span class="token number">0.222126</span><span class="token punctuation">]</span> Serial: AMBA PL011 UART driver<span class="token punctuation">[</span>    <span class="token number">0.266208</span><span class="token punctuation">]</span> <span class="token number">9000000</span>.pl011: ttyAMA0 at MMIO 0x9000000 <span class="token punctuation">(</span>irq <span class="token operator">=</span> <span class="token number">13</span>, base_baud <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> is a PL011 rev1<span class="token punctuation">[</span>    <span class="token number">0.267591</span><span class="token punctuation">]</span> printk: console <span class="token punctuation">[</span>ttyAMA0<span class="token punctuation">]</span> enabled<span class="token punctuation">[</span>    <span class="token number">0.311499</span><span class="token punctuation">]</span> KASLR enabled<span class="token punctuation">[</span>    <span class="token number">0.318457</span><span class="token punctuation">]</span> HugeTLB: registered <span class="token number">1.00</span> GiB page size, pre-allocated <span class="token number">0</span> pages<span class="token punctuation">[</span>    <span class="token number">0.318885</span><span class="token punctuation">]</span> HugeTLB: <span class="token number">16380</span> KiB vmemmap can be freed <span class="token keyword">for</span> a <span class="token number">1.00</span> GiB page<span class="token punctuation">[</span>    <span class="token number">0.319737</span><span class="token punctuation">]</span> HugeTLB: registered <span class="token number">32.0</span> MiB page size, pre-allocated <span class="token number">0</span> pages<span class="token punctuation">[</span>    <span class="token number">0.320164</span><span class="token punctuation">]</span> HugeTLB: <span class="token number">508</span> KiB vmemmap can be freed <span class="token keyword">for</span> a <span class="token number">32.0</span> MiB page<span class="token punctuation">[</span>    <span class="token number">0.320586</span><span class="token punctuation">]</span> HugeTLB: registered <span class="token number">2.00</span> MiB page size, pre-allocated <span class="token number">0</span> pages<span class="token punctuation">[</span>    <span class="token number">0.321008</span><span class="token punctuation">]</span> HugeTLB: <span class="token number">28</span> KiB vmemmap can be freed <span class="token keyword">for</span> a <span class="token number">2.00</span> MiB page<span class="token punctuation">[</span>    <span class="token number">0.321412</span><span class="token punctuation">]</span> HugeTLB: registered <span class="token number">64.0</span> KiB page size, pre-allocated <span class="token number">0</span> pages<span class="token punctuation">[</span>    <span class="token number">0.321918</span><span class="token punctuation">]</span> HugeTLB: <span class="token number">0</span> KiB vmemmap can be freed <span class="token keyword">for</span> a <span class="token number">64.0</span> KiB page<span class="token punctuation">[</span>    <span class="token number">0.337378</span><span class="token punctuation">]</span> ACPI: Interpreter disabled.<span class="token punctuation">[</span>    <span class="token number">0.347007</span><span class="token punctuation">]</span> iommu: Default domain type: Translated<span class="token punctuation">[</span>    <span class="token number">0.347873</span><span class="token punctuation">]</span> iommu: DMA domain TLB invalidation policy: strict mode<span class="token punctuation">[</span>    <span class="token number">0.351114</span><span class="token punctuation">]</span> SCSI subsystem initialized<span class="token punctuation">[</span>    <span class="token number">0.353370</span><span class="token punctuation">]</span> libata version <span class="token number">3.00</span> loaded.<span class="token punctuation">[</span>    <span class="token number">0.356232</span><span class="token punctuation">]</span> usbcore: registered new interface driver usbfs<span class="token punctuation">[</span>    <span class="token number">0.357030</span><span class="token punctuation">]</span> usbcore: registered new interface driver hub<span class="token punctuation">[</span>    <span class="token number">0.357861</span><span class="token punctuation">]</span> usbcore: registered new device driver usb<span class="token punctuation">[</span>    <span class="token number">0.362416</span><span class="token punctuation">]</span> pps_core: LinuxPPS API ver. <span class="token number">1</span> registered<span class="token punctuation">[</span>    <span class="token number">0.362800</span><span class="token punctuation">]</span> pps_core: Software ver. <span class="token number">5.3</span>.6 - Copyright <span class="token number">2005</span>-2007 Rodolfo Giometti <span class="token operator">&lt;</span>giometti@linux.it<span class="token operator">&gt;</span><span class="token punctuation">[</span>    <span class="token number">0.363567</span><span class="token punctuation">]</span> PTP clock support registered<span class="token punctuation">[</span>    <span class="token number">0.365001</span><span class="token punctuation">]</span> EDAC MC: Ver: <span class="token number">3.0</span>.0<span class="token punctuation">[</span>    <span class="token number">0.375621</span><span class="token punctuation">]</span> FPGA manager framework<span class="token punctuation">[</span>    <span class="token number">0.377753</span><span class="token punctuation">]</span> Advanced Linux Sound Architecture Driver Initialized.<span class="token punctuation">[</span>    <span class="token number">0.393917</span><span class="token punctuation">]</span> vgaarb: loaded<span class="token punctuation">[</span>    <span class="token number">0.398474</span><span class="token punctuation">]</span> clocksource: Switched to clocksource arch_sys_counter<span class="token punctuation">[</span>    <span class="token number">0.401041</span><span class="token punctuation">]</span> VFS: Disk quotas dquot_6.6.0<span class="token punctuation">[</span>    <span class="token number">0.401583</span><span class="token punctuation">]</span> VFS: Dquot-cache <span class="token builtin class-name">hash</span> table entries: <span class="token number">512</span> <span class="token punctuation">(</span>order <span class="token number">0</span>, <span class="token number">4096</span> bytes<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.405623</span><span class="token punctuation">]</span> pnp: PnP ACPI: disabled<span class="token punctuation">[</span>    <span class="token number">0.448179</span><span class="token punctuation">]</span> NET: Registered PF_INET protocol family<span class="token punctuation">[</span>    <span class="token number">0.450797</span><span class="token punctuation">]</span> IP idents <span class="token builtin class-name">hash</span> table entries: <span class="token number">16384</span> <span class="token punctuation">(</span>order: <span class="token number">5</span>, <span class="token number">131072</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.459361</span><span class="token punctuation">]</span> tcp_listen_portaddr_hash <span class="token builtin class-name">hash</span> table entries: <span class="token number">512</span> <span class="token punctuation">(</span>order: <span class="token number">1</span>, <span class="token number">8192</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.459820</span><span class="token punctuation">]</span> Table-perturb <span class="token builtin class-name">hash</span> table entries: <span class="token number">65536</span> <span class="token punctuation">(</span>order: <span class="token number">6</span>, <span class="token number">262144</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.460258</span><span class="token punctuation">]</span> TCP established <span class="token builtin class-name">hash</span> table entries: <span class="token number">8192</span> <span class="token punctuation">(</span>order: <span class="token number">4</span>, <span class="token number">65536</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.460860</span><span class="token punctuation">]</span> TCP <span class="token builtin class-name">bind</span> <span class="token builtin class-name">hash</span> table entries: <span class="token number">8192</span> <span class="token punctuation">(</span>order: <span class="token number">6</span>, <span class="token number">262144</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.461457</span><span class="token punctuation">]</span> TCP: Hash tables configured <span class="token punctuation">(</span>established <span class="token number">8192</span> <span class="token builtin class-name">bind</span> <span class="token number">8192</span><span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.463692</span><span class="token punctuation">]</span> UDP <span class="token builtin class-name">hash</span> table entries: <span class="token number">512</span> <span class="token punctuation">(</span>order: <span class="token number">2</span>, <span class="token number">16384</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.464408</span><span class="token punctuation">]</span> UDP-Lite <span class="token builtin class-name">hash</span> table entries: <span class="token number">512</span> <span class="token punctuation">(</span>order: <span class="token number">2</span>, <span class="token number">16384</span> bytes, linear<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.466512</span><span class="token punctuation">]</span> NET: Registered PF_UNIX/PF_LOCAL protocol family<span class="token punctuation">[</span>    <span class="token number">0.471516</span><span class="token punctuation">]</span> RPC: Registered named UNIX socket transport module.<span class="token punctuation">[</span>    <span class="token number">0.471936</span><span class="token punctuation">]</span> RPC: Registered udp transport module.<span class="token punctuation">[</span>    <span class="token number">0.472161</span><span class="token punctuation">]</span> RPC: Registered tcp transport module.<span class="token punctuation">[</span>    <span class="token number">0.472369</span><span class="token punctuation">]</span> RPC: Registered tcp NFSv4.1 backchannel transport module.<span class="token punctuation">[</span>    <span class="token number">0.472825</span><span class="token punctuation">]</span> PCI: CLS <span class="token number">0</span> bytes, default <span class="token number">64</span><span class="token punctuation">[</span>    <span class="token number">0.482416</span><span class="token punctuation">]</span> hw perfevents: enabled with armv8_pmuv3 PMU driver, <span class="token number">7</span> counters available<span class="token punctuation">[</span>    <span class="token number">0.484841</span><span class="token punctuation">]</span> kvm <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: HYP mode not available<span class="token punctuation">[</span>    <span class="token number">0.495161</span><span class="token punctuation">]</span> Initialise system trusted keyrings<span class="token punctuation">[</span>    <span class="token number">0.498689</span><span class="token punctuation">]</span> workingset: <span class="token assign-left variable">timestamp_bits</span><span class="token operator">=</span><span class="token number">42</span> <span class="token assign-left variable">max_order</span><span class="token operator">=</span><span class="token number">18</span> <span class="token assign-left variable">bucket_order</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">[</span>    <span class="token number">0.501968</span><span class="token punctuation">]</span> squashfs: version <span class="token number">4.0</span> <span class="token punctuation">(</span><span class="token number">2009</span>/01/31<span class="token punctuation">)</span> Phillip Lougher<span class="token punctuation">[</span>    <span class="token number">0.505377</span><span class="token punctuation">]</span> NFS: Registering the id_resolver key <span class="token builtin class-name">type</span><span class="token punctuation">[</span>    <span class="token number">0.505844</span><span class="token punctuation">]</span> Key <span class="token builtin class-name">type</span> id_resolver registered<span class="token punctuation">[</span>    <span class="token number">0.506776</span><span class="token punctuation">]</span> Key <span class="token builtin class-name">type</span> id_legacy registered<span class="token punctuation">[</span>    <span class="token number">0.507705</span><span class="token punctuation">]</span> nfs4filelayout_init: NFSv4 File Layout Driver Registering<span class="token punctuation">..</span>.<span class="token punctuation">[</span>    <span class="token number">0.508232</span><span class="token punctuation">]</span> nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering<span class="token punctuation">..</span>.<span class="token punctuation">[</span>    <span class="token number">0.511093</span><span class="token punctuation">]</span> 9p: Installing v9fs 9p2000 <span class="token function">file</span> system support<span class="token punctuation">[</span>    <span class="token number">0.561320</span><span class="token punctuation">]</span> Key <span class="token builtin class-name">type</span> asymmetric registered<span class="token punctuation">[</span>    <span class="token number">0.562183</span><span class="token punctuation">]</span> Asymmetric key parser <span class="token string">'x509'</span> registered<span class="token punctuation">[</span>    <span class="token number">0.563477</span><span class="token punctuation">]</span> Block layer SCSI generic <span class="token punctuation">(</span>bsg<span class="token punctuation">)</span> driver version <span class="token number">0.4</span> loaded <span class="token punctuation">(</span>major <span class="token number">245</span><span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.565031</span><span class="token punctuation">]</span> io scheduler mq-deadline registered<span class="token punctuation">[</span>    <span class="token number">0.565751</span><span class="token punctuation">]</span> io scheduler kyber registered<span class="token punctuation">[</span>    <span class="token number">0.642221</span><span class="token punctuation">]</span> pl061_gpio <span class="token number">9030000</span>.pl061: PL061 GPIO chip registered<span class="token punctuation">[</span>    <span class="token number">0.664236</span><span class="token punctuation">]</span> pci-host-generic <span class="token number">4010000000</span>.pcie: <span class="token function">host</span> bridge /pcie@10000000 ranges:<span class="token punctuation">[</span>    <span class="token number">0.667113</span><span class="token punctuation">]</span> pci-host-generic <span class="token number">4010000000</span>.pcie:       IO 0x003eff0000<span class="token punctuation">..</span>0x003effffff -<span class="token operator">&gt;</span> 0x0000000000<span class="token punctuation">[</span>    <span class="token number">0.669630</span><span class="token punctuation">]</span> pci-host-generic <span class="token number">4010000000</span>.pcie:      MEM 0x0010000000<span class="token punctuation">..</span>0x003efeffff -<span class="token operator">&gt;</span> 0x0010000000<span class="token punctuation">[</span>    <span class="token number">0.670999</span><span class="token punctuation">]</span> pci-host-generic <span class="token number">4010000000</span>.pcie:      MEM 0x8000000000<span class="token punctuation">..</span>0xffffffffff -<span class="token operator">&gt;</span> 0x8000000000<span class="token punctuation">[</span>    <span class="token number">0.672606</span><span class="token punctuation">]</span> pci-host-generic <span class="token number">4010000000</span>.pcie: Memory resource size exceeds max <span class="token keyword">for</span> <span class="token number">32</span> bits<span class="token punctuation">[</span>    <span class="token number">0.674647</span><span class="token punctuation">]</span> pci-host-generic <span class="token number">4010000000</span>.pcie: ECAM at <span class="token punctuation">[</span>mem 0x4010000000-0x401fffffff<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token punctuation">[</span>bus 00-ff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.678818</span><span class="token punctuation">]</span> pci-host-generic <span class="token number">4010000000</span>.pcie: PCI <span class="token function">host</span> bridge to bus 0000:00<span class="token punctuation">[</span>    <span class="token number">0.679499</span><span class="token punctuation">]</span> pci_bus 0000:00: root bus resource <span class="token punctuation">[</span>bus 00-ff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.679843</span><span class="token punctuation">]</span> pci_bus 0000:00: root bus resource <span class="token punctuation">[</span>io  0x0000-0xffff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.680176</span><span class="token punctuation">]</span> pci_bus 0000:00: root bus resource <span class="token punctuation">[</span>mem 0x10000000-0x3efeffff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.680473</span><span class="token punctuation">]</span> pci_bus 0000:00: root bus resource <span class="token punctuation">[</span>mem 0x8000000000-0xffffffffff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.683207</span><span class="token punctuation">]</span> pci 0000:00:00.0: <span class="token punctuation">[</span>1b36:0008<span class="token punctuation">]</span> <span class="token builtin class-name">type</span> 00 class 0x060000<span class="token punctuation">[</span>    <span class="token number">0.689317</span><span class="token punctuation">]</span> pci 0000:00:01.0: <span class="token punctuation">[</span>1af4:1000<span class="token punctuation">]</span> <span class="token builtin class-name">type</span> 00 class 0x020000<span class="token punctuation">[</span>    <span class="token number">0.690302</span><span class="token punctuation">]</span> pci 0000:00:01.0: reg 0x10: <span class="token punctuation">[</span>io  0x0000-0x001f<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.690656</span><span class="token punctuation">]</span> pci 0000:00:01.0: reg 0x14: <span class="token punctuation">[</span>mem 0x00000000-0x00000fff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.691027</span><span class="token punctuation">]</span> pci 0000:00:01.0: reg 0x20: <span class="token punctuation">[</span>mem 0x00000000-0x00003fff 64bit pref<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.691459</span><span class="token punctuation">]</span> pci 0000:00:01.0: reg 0x30: <span class="token punctuation">[</span>mem 0x00000000-0x0003ffff pref<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.696646</span><span class="token punctuation">]</span> pci 0000:00:01.0: BAR <span class="token number">6</span>: assigned <span class="token punctuation">[</span>mem 0x10000000-0x1003ffff pref<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.697543</span><span class="token punctuation">]</span> pci 0000:00:01.0: BAR <span class="token number">4</span>: assigned <span class="token punctuation">[</span>mem 0x8000000000-0x8000003fff 64bit pref<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.698459</span><span class="token punctuation">]</span> pci 0000:00:01.0: BAR <span class="token number">1</span>: assigned <span class="token punctuation">[</span>mem 0x10040000-0x10040fff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.698783</span><span class="token punctuation">]</span> pci 0000:00:01.0: BAR <span class="token number">0</span>: assigned <span class="token punctuation">[</span>io  0x1000-0x101f<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">0.718682</span><span class="token punctuation">]</span> EINJ: ACPI disabled.<span class="token punctuation">[</span>    <span class="token number">0.884711</span><span class="token punctuation">]</span> virtio-pci 0000:00:01.0: enabling device <span class="token punctuation">(</span>0000 -<span class="token operator">&gt;</span> 0003<span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">0.932982</span><span class="token punctuation">]</span> Serial: <span class="token number">8250</span>/16550 driver, <span class="token number">4</span> ports, IRQ sharing enabled<span class="token punctuation">[</span>    <span class="token number">0.954887</span><span class="token punctuation">]</span> SuperH <span class="token punctuation">(</span>H<span class="token punctuation">)</span>SCI<span class="token punctuation">(</span>F<span class="token punctuation">)</span> driver initialized<span class="token punctuation">[</span>    <span class="token number">0.958849</span><span class="token punctuation">]</span> msm_serial: driver initialized<span class="token punctuation">[</span>    <span class="token number">0.974654</span><span class="token punctuation">]</span> cacheinfo: Unable to detect cache hierarchy <span class="token keyword">for</span> CPU <span class="token number">0</span><span class="token punctuation">[</span>    <span class="token number">1.015829</span><span class="token punctuation">]</span> loop: module loaded<span class="token punctuation">[</span>    <span class="token number">1.030271</span><span class="token punctuation">]</span> megasas: 07.719.03.00-rc1<span class="token punctuation">[</span>    <span class="token number">1.047200</span><span class="token punctuation">]</span> physmap-flash <span class="token number">0</span>.flash: physmap platform flash device: <span class="token punctuation">[</span>mem 0x00000000-0x03ffffff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">1.049404</span><span class="token punctuation">]</span> <span class="token number">0</span>.flash: Found <span class="token number">2</span> x16 devices at 0x0 <span class="token keyword">in</span> <span class="token number">32</span>-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000<span class="token punctuation">[</span>    <span class="token number">1.050782</span><span class="token punctuation">]</span> Intel/Sharp Extended Query Table at 0x0031<span class="token punctuation">[</span>    <span class="token number">1.052283</span><span class="token punctuation">]</span> Using buffer <span class="token function">write</span> method<span class="token punctuation">[</span>    <span class="token number">1.052891</span><span class="token punctuation">]</span> erase region <span class="token number">0</span>: <span class="token assign-left variable">offset</span><span class="token operator">=</span>0x0,size<span class="token operator">=</span>0x40000,blocks<span class="token operator">=</span><span class="token number">256</span><span class="token punctuation">[</span>    <span class="token number">1.053495</span><span class="token punctuation">]</span> physmap-flash <span class="token number">0</span>.flash: physmap platform flash device: <span class="token punctuation">[</span>mem 0x04000000-0x07ffffff<span class="token punctuation">]</span><span class="token punctuation">[</span>    <span class="token number">1.055128</span><span class="token punctuation">]</span> <span class="token number">0</span>.flash: Found <span class="token number">2</span> x16 devices at 0x0 <span class="token keyword">in</span> <span class="token number">32</span>-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000<span class="token punctuation">[</span>    <span class="token number">1.055665</span><span class="token punctuation">]</span> Intel/Sharp Extended Query Table at 0x0031<span class="token punctuation">[</span>    <span class="token number">1.056650</span><span class="token punctuation">]</span> Using buffer <span class="token function">write</span> method<span class="token punctuation">[</span>    <span class="token number">1.056875</span><span class="token punctuation">]</span> erase region <span class="token number">0</span>: <span class="token assign-left variable">offset</span><span class="token operator">=</span>0x0,size<span class="token operator">=</span>0x40000,blocks<span class="token operator">=</span><span class="token number">256</span><span class="token punctuation">[</span>    <span class="token number">1.057302</span><span class="token punctuation">]</span> Concatenating MTD devices:<span class="token punctuation">[</span>    <span class="token number">1.057494</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>: <span class="token string">"0.flash"</span><span class="token punctuation">[</span>    <span class="token number">1.057632</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>: <span class="token string">"0.flash"</span><span class="token punctuation">[</span>    <span class="token number">1.057787</span><span class="token punctuation">]</span> into device <span class="token string">"0.flash"</span><span class="token punctuation">[</span>    <span class="token number">1.769909</span><span class="token punctuation">]</span> tun: Universal TUN/TAP device driver, <span class="token number">1.6</span><span class="token punctuation">[</span>    <span class="token number">1.799892</span><span class="token punctuation">]</span> thunder_xcv, ver <span class="token number">1.0</span><span class="token punctuation">[</span>    <span class="token number">1.801331</span><span class="token punctuation">]</span> thunder_bgx, ver <span class="token number">1.0</span><span class="token punctuation">[</span>    <span class="token number">1.803667</span><span class="token punctuation">]</span> nicpf, ver <span class="token number">1.0</span><span class="token punctuation">[</span>    <span class="token number">1.820402</span><span class="token punctuation">]</span> hns3: Hisilicon Ethernet Network Driver <span class="token keyword">for</span> Hip08 Family - version<span class="token punctuation">[</span>    <span class="token number">1.821282</span><span class="token punctuation">]</span> hns3: Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2017</span> Huawei Corporation.<span class="token punctuation">[</span>    <span class="token number">1.822624</span><span class="token punctuation">]</span> hclge is initializing<span class="token punctuation">[</span>    <span class="token number">1.823014</span><span class="token punctuation">]</span> e1000: Intel<span class="token punctuation">(</span>R<span class="token punctuation">)</span> PRO/1000 Network Driver<span class="token punctuation">[</span>    <span class="token number">1.823381</span><span class="token punctuation">]</span> e1000: Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">1999</span>-2006 Intel Corporation.<span class="token punctuation">[</span>    <span class="token number">1.823928</span><span class="token punctuation">]</span> e1000e: Intel<span class="token punctuation">(</span>R<span class="token punctuation">)</span> PRO/1000 Network Driver<span class="token punctuation">[</span>    <span class="token number">1.824423</span><span class="token punctuation">]</span> e1000e: Copyright<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">1999</span> - <span class="token number">2015</span> Intel Corporation.<span class="token punctuation">[</span>    <span class="token number">1.825247</span><span class="token punctuation">]</span> igb: Intel<span class="token punctuation">(</span>R<span class="token punctuation">)</span> Gigabit Ethernet Network Driver<span class="token punctuation">[</span>    <span class="token number">1.825717</span><span class="token punctuation">]</span> igb: Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2007</span>-2014 Intel Corporation.<span class="token punctuation">[</span>    <span class="token number">1.827861</span><span class="token punctuation">]</span> igbvf: Intel<span class="token punctuation">(</span>R<span class="token punctuation">)</span> Gigabit Virtual Function Network Driver<span class="token punctuation">[</span>    <span class="token number">1.828364</span><span class="token punctuation">]</span> igbvf: Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2009</span> - <span class="token number">2012</span> Intel Corporation.<span class="token punctuation">[</span>    <span class="token number">1.832453</span><span class="token punctuation">]</span> sky2: driver version <span class="token number">1.30</span><span class="token punctuation">[</span>    <span class="token number">1.845694</span><span class="token punctuation">]</span> VFIO - User Level meta-driver version: <span class="token number">0.3</span><span class="token punctuation">[</span>    <span class="token number">1.873853</span><span class="token punctuation">]</span> usbcore: registered new interface driver usb-storage<span class="token punctuation">[</span>    <span class="token number">1.912107</span><span class="token punctuation">]</span> rtc-pl031 <span class="token number">9010000</span>.pl031: registered as rtc0<span class="token punctuation">[</span>    <span class="token number">1.913604</span><span class="token punctuation">]</span> rtc-pl031 <span class="token number">9010000</span>.pl031: setting system clock to <span class="token number">2023</span>-03-21T14:03:37 UTC <span class="token punctuation">(</span><span class="token number">1679407417</span><span class="token punctuation">)</span><span class="token punctuation">[</span>    <span class="token number">1.920946</span><span class="token punctuation">]</span> i2c_dev: i2c /dev entries driver<span class="token punctuation">[</span>    <span class="token number">1.977675</span><span class="token punctuation">]</span> ghes_edac: GHES probing device list is empty<span class="token punctuation">[</span>    <span class="token number">1.993502</span><span class="token punctuation">]</span> sdhci: Secure Digital Host Controller Interface driver<span class="token punctuation">[</span>    <span class="token number">1.996446</span><span class="token punctuation">]</span> sdhci: Copyright<span class="token punctuation">(</span>c<span class="token punctuation">)</span> Pierre Ossman<span class="token punctuation">[</span>    <span class="token number">2.005337</span><span class="token punctuation">]</span> Synopsys Designware Multimedia Card Interface Driver<span class="token punctuation">[</span>    <span class="token number">2.016116</span><span class="token punctuation">]</span> sdhci-pltfm: SDHCI platform and OF driver helper<span class="token punctuation">[</span>    <span class="token number">2.037350</span><span class="token punctuation">]</span> ledtrig-cpu: registered to indicate activity on CPUs<span class="token punctuation">[</span>    <span class="token number">2.060641</span><span class="token punctuation">]</span> usbcore: registered new interface driver usbhid<span class="token punctuation">[</span>    <span class="token number">2.061289</span><span class="token punctuation">]</span> usbhid: USB HID core driver<span class="token punctuation">[</span>    <span class="token number">2.134717</span><span class="token punctuation">]</span> NET: Registered PF_PACKET protocol family<span class="token punctuation">[</span>    <span class="token number">2.136285</span><span class="token punctuation">]</span> 9pnet: Installing 9P2000 support<span class="token punctuation">[</span>    <span class="token number">2.139040</span><span class="token punctuation">]</span> Key <span class="token builtin class-name">type</span> dns_resolver registered<span class="token punctuation">[</span>    <span class="token number">2.394485</span><span class="token punctuation">]</span> registered taskstats version <span class="token number">1</span><span class="token punctuation">[</span>    <span class="token number">2.398687</span><span class="token punctuation">]</span> Loading compiled-in X.509 certificates<span class="token punctuation">[</span>    <span class="token number">2.427898</span><span class="token punctuation">]</span> input: gpio-keys as /devices/platform/gpio-keys/input/input0<span class="token punctuation">[</span>    <span class="token number">2.443319</span><span class="token punctuation">]</span> ALSA device list:<span class="token punctuation">[</span>    <span class="token number">2.443778</span><span class="token punctuation">]</span>   No soundcards found.<span class="token punctuation">[</span>    <span class="token number">2.448472</span><span class="token punctuation">]</span> uart-pl011 <span class="token number">9000000</span>.pl011: no DMA platform data<span class="token punctuation">[</span>    <span class="token number">2.620782</span><span class="token punctuation">]</span> Freeing unused kernel memory: 20224K<span class="token punctuation">[</span>    <span class="token number">2.622695</span><span class="token punctuation">]</span> Run /linuxrc as init process<span class="token punctuation">[</span>    <span class="token number">2.622932</span><span class="token punctuation">]</span>   with arguments:<span class="token punctuation">[</span>    <span class="token number">2.623086</span><span class="token punctuation">]</span>     /linuxrc<span class="token punctuation">[</span>    <span class="token number">2.623191</span><span class="token punctuation">]</span>   with environment:<span class="token punctuation">[</span>    <span class="token number">2.623333</span><span class="token punctuation">]</span>     <span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span>/<span class="token punctuation">[</span>    <span class="token number">2.623444</span><span class="token punctuation">]</span>     <span class="token assign-left variable"><span class="token environment constant">TERM</span></span><span class="token operator">=</span>linuxPlease press Enter to activate this console.<span class="token punctuation">[</span>jack@ <span class="token punctuation">]</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于Please press Enter to activate this console.</p><p>如果想要直接不敲回车，自动进入模拟系统</p><p>需要修改etc/inittab，将::askfirst:-/bin/sh修改为::respawn:-/bin/sh</p></blockquote><h1 id="5-使用模拟磁盘"><a href="#5-使用模拟磁盘" class="headerlink" title="5 使用模拟磁盘"></a>5 使用模拟磁盘</h1><p>上述initramfs的方式，将根文件系统打包到内核源码，运行时都是在内存中，可以操作，但系统重启就会丢失，下面用模拟磁盘方式挂载根文件系统。</p><p>制作磁盘文件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>rootfs_ext4.img <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1024</span>mkfs.ext4 rootfs_ext4.img<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> tmpfs<span class="token function">sudo</span> <span class="token function">mount</span>  <span class="token parameter variable">-t</span> ext4 rootfs_ext4.img  tmpfs/ <span class="token parameter variable">-o</span> loop<span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-af</span> _install_arm64/* tmpfs/<span class="token function">sudo</span> <span class="token function">umount</span>  tmpfs<span class="token function">chmod</span> <span class="token number">777</span> rootfs_ext4.img<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>rootfs_ext4.img就是即将用来挂载的磁盘；</p><p>再次启动内核：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-aarch64 <span class="token parameter variable">-machine</span> virt <span class="token parameter variable">-cpu</span> cortex-a57 <span class="token parameter variable">-machine</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>virt <span class="token parameter variable">-m</span> <span class="token number">1024</span> <span class="token parameter variable">-smp</span> <span class="token number">4</span> <span class="token parameter variable">-kernel</span> arch/arm64/boot/Image <span class="token parameter variable">--append</span> <span class="token string">"noinitrd root=/dev/vda rw console=ttyAMA0 loglevel=8"</span>  <span class="token parameter variable">-nographic</span> <span class="token parameter variable">-drive</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>none,file<span class="token operator">=</span>rootfs_ext4.img,id<span class="token operator">=</span>hd0 <span class="token parameter variable">-device</span> virtio-blk-device,drive<span class="token operator">=</span>hd0 <span class="token parameter variable">--fsdev</span> local,id<span class="token operator">=</span>kmod_dev,path<span class="token operator">=</span><span class="token environment constant">$PWD</span>/kmodules,security_model<span class="token operator">=</span>none <span class="token parameter variable">-device</span> virtio-9p-device,fsdev<span class="token operator">=</span>kmod_dev,mount_tag<span class="token operator">=</span>kmod_mount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>传递给内核的命令行参数变化了，添加了noinitrd选项，这样就会挂载我们自己的模拟磁盘。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@myQEMU <span class="token punctuation">]</span>Filesystem                Size      Used Available Use% Mounted on/dev/root               <span class="token number">975</span>.9M     <span class="token number">12</span>.8M    <span class="token number">895</span>.9M   <span class="token number">1</span>% /tmpfs                   <span class="token number">496</span>.1M         <span class="token number">0</span>    <span class="token number">496</span>.1M   <span class="token number">0</span>% /tmptmpfs                   <span class="token number">496</span>.1M         <span class="token number">0</span>    <span class="token number">496</span>.1M   <span class="token number">0</span>% /devkmod_mount              <span class="token number">981</span>.8G     <span class="token number">32</span>.5G    <span class="token number">899</span>.4G   <span class="token number">3</span>% /mnt<span class="token punctuation">[</span>root@myQEMU <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样在文件系统的读写，就会存在磁盘，重启后，数据不会丢失。</p><blockquote><p>[    2.403424] —[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(254,0) ]—</p></blockquote><h1 id="6-qemu与主机ubuntu文件共享"><a href="#6-qemu与主机ubuntu文件共享" class="headerlink" title="6 qemu与主机ubuntu文件共享"></a>6 qemu与主机ubuntu文件共享</h1><p>前面已经支持了主机和qemu上的系统共享目录，这个目录就是kmodules目录：</p><p>通过mount可以查看被挂载到了qemu上的系统的/mnt目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>jack@ mnt<span class="token punctuation">]</span><span class="token comment"># mount</span>rootfs on / <span class="token builtin class-name">type</span> rootfs <span class="token punctuation">(</span>rw<span class="token punctuation">)</span>proc on /proc <span class="token builtin class-name">type</span> proc <span class="token punctuation">(</span>rw,relatime<span class="token punctuation">)</span>tmpfs on /tmp <span class="token builtin class-name">type</span> tmpfs <span class="token punctuation">(</span>rw,relatime<span class="token punctuation">)</span>sysfs on /sys <span class="token builtin class-name">type</span> sysfs <span class="token punctuation">(</span>rw,relatime<span class="token punctuation">)</span>tmpfs on /dev <span class="token builtin class-name">type</span> tmpfs <span class="token punctuation">(</span>rw,relatime<span class="token punctuation">)</span>debugfs on /sys/kernel/debug <span class="token builtin class-name">type</span> debugfs <span class="token punctuation">(</span>rw,relatime<span class="token punctuation">)</span>kmod_mount on /mnt <span class="token builtin class-name">type</span> 9p <span class="token punctuation">(</span>rw,sync,dirsync,relatime,access<span class="token operator">=</span>client,trans<span class="token operator">=</span>virtio<span class="token punctuation">)</span>devpts on /dev/pts <span class="token builtin class-name">type</span> devpts <span class="token punctuation">(</span>rw,relatime,mode<span class="token operator">=</span><span class="token number">600</span>,ptmxmode<span class="token operator">=</span>000<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在ubuntu的kmodules目录，创建一个文件hello.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World,Qemu!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在qemu查看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>jack@ mnt<span class="token punctuation">]</span><span class="token comment">#cat hello.c</span><span class="token comment">#include &lt;stdio.h&gt;</span>int main<span class="token punctuation">(</span>int argc, char **argv<span class="token punctuation">)</span><span class="token punctuation">{</span>printf<span class="token punctuation">(</span><span class="token string">"Hello World,Qemu!<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在ubuntu编译，</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc  hello.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在qemu运行，</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>jack@ mnt<span class="token punctuation">]</span><span class="token comment"># ./a.out</span>Hello World,Qemu<span class="token operator">!</span><span class="token punctuation">[</span>jack@ mnt<span class="token punctuation">]</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可见，在共享目录，可以执行含动态库的应用程序；</p><h1 id="7-内核模块测试："><a href="#7-内核模块测试：" class="headerlink" title="7 内核模块测试："></a>7 内核模块测试：</h1><p>Makefile文件，</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">KERNEL_DIR ?<span class="token operator">=</span> ~/work/Linux/linuxobj-m :<span class="token operator">=</span> module_test.omodules:<span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token parameter variable">-C</span> <span class="token variable"><span class="token variable">$(</span>KERNEL_DIR<span class="token variable">)</span></span> <span class="token assign-left variable">M</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token environment constant">PWD</span><span class="token variable">)</span></span> modulesclean: <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token parameter variable">-C</span> <span class="token variable"><span class="token variable">$(</span>KERNEL_DIR<span class="token variable">)</span></span> <span class="token assign-left variable">M</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token environment constant">PWD</span><span class="token variable">)</span></span> cleaninstall:         <span class="token function">cp</span> *.ko <span class="token variable"><span class="token variable">$(</span>KERNEL_DIR<span class="token variable">)</span></span>/kmodules<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>驱动测试文件model_test.c，</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;   static int __init module_test_init(void){        printk("---module_test_init\n");        return 0;}        static void __exit module_test_exit(void){        printk("---module_test_exit\n");}    module_init(module_test_init);module_exit(module_test_exit);MODULE_LICENSE("GPL");` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在ubuntu上交叉编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">leon@leon:~/work/Linux/linux/kmodules$ <span class="token function">make</span><span class="token function">make</span> <span class="token parameter variable">-C</span> ~/work/Linux/linux <span class="token assign-left variable">M</span><span class="token operator">=</span>/home/leon/work/Linux/linux/kmodules modulesmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/leon/work/Linux/linux'</span>  CC <span class="token punctuation">[</span>M<span class="token punctuation">]</span>  /home/leon/work/Linux/linux/kmodules/module_test.o  MODPOST /home/leon/work/Linux/linux/kmodules/Module.symvers  CC <span class="token punctuation">[</span>M<span class="token punctuation">]</span>  /home/leon/work/Linux/linux/kmodules/module_test.mod.o  LD <span class="token punctuation">[</span>M<span class="token punctuation">]</span>  /home/leon/work/Linux/linux/kmodules/module_test.komake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/leon/work/Linux/linux'</span>leon@leon:~/work/Linux/linux/kmodules$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在qemu加载驱动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@myQEMU mnt<span class="token punctuation">]</span>---module_test_init.<span class="token punctuation">[</span>root@myQEMU mnt<span class="token punctuation">]</span>---module_test_exit.<span class="token punctuation">[</span>root@myQEMU mnt<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，内核模块正常运行了。</p><h1 id="8-gdb调试"><a href="#8-gdb调试" class="headerlink" title="8 gdb调试"></a>8 gdb调试</h1><p>安装arm-none-eabi-gdb</p><p><a href="https://askubuntu.com/questions/1243252/how-to-install-arm-none-eabi-gdb-on-ubuntu-20-04-lts-focal-fossa">https://askubuntu.com/questions/1243252/how-to-install-arm-none-eabi-gdb-on-ubuntu-20-04-lts-focal-fossa</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> gdb-multiarch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>qemu模拟端启动内核：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-aarch64 <span class="token parameter variable">-machine</span> virt <span class="token parameter variable">-cpu</span> cortex-a57 <span class="token parameter variable">-machine</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>virt <span class="token parameter variable">-m</span> <span class="token number">1024</span> <span class="token parameter variable">-smp</span> <span class="token number">4</span> <span class="token parameter variable">-kernel</span> arch/arm64/boot/Image <span class="token parameter variable">--append</span> <span class="token string">"rdinit=/linuxrc root=/dev/vda rw console=ttyAMA0 loglevel=8"</span>  <span class="token parameter variable">-nographic</span> <span class="token parameter variable">--fsdev</span> local,id<span class="token operator">=</span>kmod_dev,path<span class="token operator">=</span><span class="token environment constant">$PWD</span>/k_shared,security_model<span class="token operator">=</span>none <span class="token parameter variable">-device</span> virtio-9p-device,fsdev<span class="token operator">=</span>kmod_dev,mount_tag<span class="token operator">=</span>kmod_mount  <span class="token parameter variable">-S</span>  <span class="token parameter variable">-s</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>X86启动gdb：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gdb-multiarch <span class="token parameter variable">--tui</span> vmlinux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span>target remote localhost:1234  //通过1234端口远程连接到qemu端<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span>b start_kernel   //在内核的start_kernel设置断点<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如图，gdb接管linux内核，在断点处(start_kernel)暂停，即可通过gdb来调试内核。</p><p>用Eclipse可视化环境，单步调试Linux内核，参考：</p><p><a href="https://blog.csdn.net/luteresa/article/details/119188792">https://blog.csdn.net/luteresa/article/details/119188792</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Qemu </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>expect与shell自动化交互，实现批量自动化执行任务</title>
      <link href="/blog/fa48b9ad.html"/>
      <url>/blog/fa48b9ad.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p> 我们通过Shell可以实现简单的控制流功能，如：循环、判断等。但是对于需要交互的场合则必须通过人工来干预，有时候我们可能会需要实现和交互程序如telnet服务器等进行交互的功能。而expect就使用来实现这种功能的工具。</p><p> expect是一个免费的编程工具语言，用来实现自动和交互式任务进行通信，而无需人的干预。expect是不断发展的，随着时间的流逝，其功能越来越强大，已经成为系统管理员的的一个强大助手。expect需要Tcl编程语言的支持，要在系统上运行expect必须首先安装Tcl。</p><h2 id="2-expect的安装"><a href="#2-expect的安装" class="headerlink" title="2 expect的安装"></a>2 expect的安装</h2><p>expect是在Tcl基础上创建起来的，所以在安装expect前我们应该先安装Tcl。</p><h2 id="2-1-方法一-编译安装"><a href="#2-1-方法一-编译安装" class="headerlink" title="2.1 方法一: 编译安装"></a>2.1 方法一: 编译安装</h2><h3 id="2-1-1-安装Tcl库"><a href="#2-1-1-安装Tcl库" class="headerlink" title="2.1.1 安装Tcl库"></a>2.1.1 安装Tcl库</h3><ol><li>下载源码包</li></ol><p><a href="http://www.tcl.tk/software/tcltk/downloadnow84.tml">主页下载</a>下载源码包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://nchc.dl.sourceforge.net/sourceforge/tcl/tcl8.4.11-src.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>解压缩源码包</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> xfvz tcl8.4.11-src.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>安装配置</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> tcl8.4.11/unix./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/tcl --enable-shared<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意: <span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ol><li><p>安装完毕以后，进入tcl源代码的根目录，把子目录unix下面的<code>tclUnixPort.h</code> copy到子目录generic中。</p></li><li><p>暂时不要删除tcl源代码，因为expect的安装过程还需要用。</p></li></ol><h3 id="2-1-2-expect-安装"><a href="#2-1-2-expect-安装" class="headerlink" title="2.1.2 expect 安装"></a>2.1.2 expect 安装</h3><ol><li><a href="http://expect.nist.gov/">主页下载</a>下载源码包</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://sourceforge.net/projects/expect/files/Expect/5.45/expect5.45.tar.gz/download<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>解压缩源码</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> xzvf expect5.45.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>安装配置</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> expect5.45  ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/expect --with-tcl<span class="token operator">=</span>/usr/tcl/lib --with-tclinclude<span class="token operator">=</span><span class="token punctuation">..</span>/tcl8.4.11/generic  <span class="token function">make</span>  <span class="token function">make</span> <span class="token function">install</span>  <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/tcl/bin/expect /usr/expect/bin/expect  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-yum-x2F-apt安装"><a href="#2-2-yum-x2F-apt安装" class="headerlink" title="2.2 yum/apt安装"></a>2.2 yum/apt安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">expect</span> tcl tclx tcl-devel<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">expect</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="3-Expect工作原理"><a href="#3-Expect工作原理" class="headerlink" title="3 Expect工作原理"></a>3 Expect工作原理</h1><p> 从最简单的层次来说，Expect的工作方式象一个通用化的Chat脚本工具。Chat脚本最早用于UUCP网络内，以用来实现计算机之间需要建立连接时进行特定的登录会话的自动化。</p><p> Chat脚本由一系列expect-send对组成：expect等待输出中输出特定的字符，通常是一个提示符，然后发送特定的响应。例如下面的 Chat脚本实现等待标准输出出现Login:字符串，然后发送somebody作为用户名；然后等待Password:提示符，并发出响应 sillyme。</p><p>Expect最简单的脚本操作模式本质上和Chat脚本工作模式是一样的。例子：</p><h2 id="3-1-实现功能"><a href="#3-1-实现功能" class="headerlink" title="3.1 实现功能"></a>3.1 实现功能</h2><p>下面我们分析一个响应chsh命令的脚本。我们首先回顾一下这个交互命令的格式。</p><p>假设我们要为用户chavez改变登录脚本，要求实现的命令交互过程如下：</p><ol><li><p># chsh chavez  </p></li><li><p>Changing the login shell for chavez  </p></li><li><p>Enter the new value, or press return for the default  </p></li><li><p>Login Shell [/bin/bash]: /bin/tcsh</p></li></ol><p>可以看到该命令首先输出若干行提示信息并且提示输入用户新的登录shell。我们必须在提示信息后面输入用户的登录shell或者直接回车不修改登录shell。</p><h2 id="3-2-实现自动执行"><a href="#3-2-实现自动执行" class="headerlink" title="3.2 实现自动执行"></a>3.2 实现自动执行</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect </span><span class="token comment"># Change a login shell to tcsh</span><span class="token builtin class-name">set</span> user <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">0</span><span class="token punctuation">]</span> spawn chsh <span class="token variable">$user</span> <span class="token function">expect</span> <span class="token punctuation">{</span><span class="token string">"]:"</span> <span class="token punctuation">{</span>send <span class="token string">"/bin/tcsh<span class="token entity" title="\r">\r</span>"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">expect</span> eof <span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ol><li><p>首行指定用来执行该脚本的命令程序，这里是/usr/bin/expect。</p></li><li><p>程序第一行用来获得脚本的执行参数(其保存在数组$argv中，从0号开始是参数)，并将其保存到变量user中。</p></li><li><p>第二个参数使用expect的spawn命令来启动脚本和命令的会话，这里启动的是chsh命令，实际上命令是以衍生子进程的方式来运行的。</p></li><li><p>随后的expect和send命令用来实现交互过程。脚本首先等待输出中出现]:字符串，一旦在输出中出现chsh输出到的特征字符串(一般特征 字符串往往是等待输入的最后的提示符的特征信息)。对于其他不匹配的信息则会完全忽略。当脚本得到特征字符串时，expect将发送/bin/tcsh和 一个回车符给chsh命令。最后脚本等待命令退出(chsh结束)，一旦接收到标识子进程已经结束的eof字符，expect脚本也就退出结束。</p></li></ol><h2 id="3-3-决定如何响应"><a href="#3-3-决定如何响应" class="headerlink" title="3.3 决定如何响应"></a>3.3 决定如何响应</h2><p> 系统管理员往往有这样的需求，希望根据当前的具体情况来以不同的方式对一个命令进行响应。我们可以通过后面的例子看到expect可以实现非常复杂的条件响应，而仅仅通过简单的修改预处理脚本就可以实现。</p><p>下面的例子是一个更复杂的expect-send例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">expect</span> <span class="token parameter variable">-re</span> <span class="token string">"\[(.*)]:"</span> <span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token variable">$expect_out</span><span class="token punctuation">(</span><span class="token number">1</span>,string<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token string">"/bin/tcsh"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span> send <span class="token string">"/bin/tcsh"</span> <span class="token punctuation">}</span> send <span class="token string">"<span class="token entity" title="\r">\r</span>"</span> <span class="token function">expect</span> eof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li><p>第一个expect命令现在使用了-re参数，这个参数表示指定的的字符串是一个正则表达式，而不是一个普通的字符串。对于上面这个例子里是查找一个左方括号字符(其必须进行三次逃逸(escape)，因此有三个符号，因为它对于expect和正则表达时来说都是特殊字符)后面跟有零个或多个字符，最后是一个右方括号字符。这里.*表示表示一个或多个任意字符，将其存放在()中是因为将匹配结果存放在一个变量中以实现随后的对匹配结果的访问。</p></li><li><p>当发现一个匹配则检查包含在[]中的字符串，查看是否为/bin/tcsh。如果不是则发送/bin/tcsh给chsh命令作为输入，如果是则仅仅发送一个回车符。这个简单的针对具体情况发出不同相响应的小例子说明了expect的强大功能。</p></li><li><p>在一个正则表达时中，可以在()中包含若干个部分并通过expect_out数组访问它们。各个部分在表达式中从左到右进行编码，从1开始(0包含有整个匹配输出)。()可能会出现嵌套情况，这这种情况下编码从最内层到最外层来进行的。</p></li></ol><h2 id="3-4-使用超时"><a href="#3-4-使用超时" class="headerlink" title="3.4 使用超时"></a>3.4 使用超时</h2><p> 下一个expect例子中将阐述具有超时功能的提示符函数。这个脚本提示用户输入，如果在给定的时间内没有输入，则会超时并返回一个默认的响应。这个脚本接收三个参数：提示符字串，默认响应和超时时间(秒)。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect </span><span class="token comment"># Prompt function with timeout and default. </span><span class="token comment">#脚本的第一部分首先是得到运行参数并将其保存到内部变量中 </span><span class="token builtin class-name">set</span> prompt <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token builtin class-name">set</span> def <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">1</span><span class="token punctuation">]</span>  <span class="token builtin class-name">set</span> response <span class="token variable">$def</span> <span class="token builtin class-name">set</span> tout <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">2</span><span class="token punctuation">]</span>  send_tty <span class="token string">"<span class="token variable">$prompt</span>: "</span> <span class="token comment">#send_tty命令用来实现在终端上显示提示符字串和一个冒号及空格 </span><span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token variable">$tout</span> <span class="token comment">#set timeout命令设置后面所有的expect命令的等待响应的超时时间为$tout(-l参数用来关闭任何超时设置)。  </span><span class="token function">expect</span> <span class="token string">" "</span> <span class="token punctuation">{</span> <span class="token builtin class-name">set</span> raw <span class="token variable">$expect_out</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token comment"># remove final carriage return </span><span class="token builtin class-name">set</span> response <span class="token punctuation">[</span>string trimright <span class="token string">"<span class="token variable">$raw</span>"</span> <span class="token string">" "</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span> <span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token string">"<span class="token variable">$response</span>"</span> <span class="token operator">==</span> <span class="token string">"} {set response <span class="token variable">$def</span>} send "</span><span class="token variable">$response</span> " <span class="token comment"># Prompt function with timeout and default. </span><span class="token builtin class-name">set</span> prompt <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token builtin class-name">set</span> def <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">1</span><span class="token punctuation">]</span>  <span class="token builtin class-name">set</span> response <span class="token variable">$def</span> <span class="token builtin class-name">set</span> tout <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li><p>send_tty命令用来实现在终端上显示提示符字串和一个冒号及空格。</p></li><li><p>set timeout命令设置后面所有的expect命令的等待响应的超时时间为$tout(-l参数用来关闭任何超时设置)。</p></li><li><p>然后expect命令就等待输出中出现回车字符。如果在超时之前得到回车符，那么set命令就会将用户输入的内容赋值给变脸raw。随后的命令将用户输入内容最后的回车符号去除以后赋值给变量response。</p></li><li><p>如果response中内容为空则将response值置为默认值(如果用户在超时以后没有输入或者用户仅仅输入了回车符)。最后send命令将response变量的值加上回车符发送给标准输出。</p></li></ol><p>注意：<span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ol><li><p>该脚本没有使用spawn命令。</p></li><li><p>该expect脚本会与任何调用该脚本的进程交互。</p></li><li><p>如果该脚本名为prompt，那么它可以用在任何C风格的shell中。</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">% <span class="token builtin class-name">set</span> <span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token string">'prompt "Enter an answer" silence 10'</span>  Enter an answer: <span class="token builtin class-name">test</span>  % <span class="token builtin class-name">echo</span> Answer was <span class="token string">"<span class="token variable">$a</span>"</span>  Answer was <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>prompt设定的超时为10秒。如果超时或者用户仅仅输入了回车符号，echo命令将输出</p><p> <code>Answer was "silence"</code></p><h2 id="3-5-一个更复杂的例子"><a href="#3-5-一个更复杂的例子" class="headerlink" title="3.5 一个更复杂的例子"></a>3.5 一个更复杂的例子</h2><p> 下面我们将讨论一个更加复杂的expect脚本例子，这个脚本使用了一些更复杂的控制结构和很多复杂的交互过程。这个例子用来实现发送write命令给任意的用户，发送的消息来自于一个文件或者来自于键盘输入。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect </span><span class="token comment"># Write to multiple users from a prepared file </span><span class="token comment"># or a message input interactively </span><span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token variable">$argc</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">}</span> <span class="token punctuation">{</span> send_user <span class="token string">"usage: <span class="token variable">$argv0</span> file user1 user2 ... "</span> <span class="token builtin class-name">exit</span>  <span class="token punctuation">}</span>  <span class="token comment">#send_user命令用来显示使用帮助信息到父进程(一般为用户的shell)的标准输出。  </span><span class="token builtin class-name">set</span> nofile <span class="token number">0</span> <span class="token comment"># get filename via the Tcl lindex function </span><span class="token builtin class-name">set</span> <span class="token function">file</span> <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token variable">$file</span><span class="token operator">==</span><span class="token string">"i"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>     <span class="token builtin class-name">set</span> nofile <span class="token number">1</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment"># make sure message file exists </span><span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>file isfile <span class="token variable">$file</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">}</span>   <span class="token punctuation">{</span>     send_user <span class="token string">"<span class="token variable">$argv0</span>: file <span class="token variable">$file</span> not found. "</span>    <span class="token builtin class-name">exit</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>这部分实现处理脚本启动参数，其必须是一个储存要发送的消息的文件名或表示使用交互输入得到发送消的内容的”i”命令。</p></li><li><p>变量file被设置为脚本的第一个参数的值，是通过一个Tcl函数lindex来实现的，该函数从列表/数组得到一个特定的元素。[]用来实现将函数lindex的返回值作为set命令的参数。</p></li><li><p>如果脚本的第一个参数是小写的”i”，那么变量nofile被设置为1，否则通过调用Tcl的函数isfile来验证参数指定的文件存在，如果不存在就报错退出。</p></li><li><p>可以看到这里使用了if命令来实现逻辑判断功能。该命令后面直接跟判断条件，并且执行在判断条件后的{}内的命令。if条件为false时则运行else后的程序块。</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> procs <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment"># start write processes </span><span class="token keyword">for</span> <span class="token punctuation">{</span>set i <span class="token number">1</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$argc</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>incr i<span class="token punctuation">}</span> <span class="token punctuation">{</span> spawn <span class="token parameter variable">-noecho</span> <span class="token function">write</span>  <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token variable">$i</span><span class="token punctuation">]</span>  lappend procs <span class="token variable">$spawn_id</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>这一部分使用spawn命令来启动write进程实现向用户发送消息.</p></li><li><p>这里使用了for命令来实现循环控制功能，循环变量首先设置为1，然后因此递增。循环体是最后的{}的内容。</p></li><li><p>这里我们是用脚本的第二个和随后的参数来spawn一个write命令，并将每个参数作为发送消息的用户名。</p></li><li><p>lappend命令使用保存每个spawn的进程的进程ID号的内部变量$spawn_id在变量procs中构造了一个进程ID号列表。</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token variable">$nofile</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>  setmesg <span class="token punctuation">[</span>open <span class="token string">"<span class="token variable">$file</span>"</span> <span class="token string">"r"</span><span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> send_user <span class="token string">"enter message,  ending with ^D: "</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后脚本根据变量nofile的值实现打开消息文件或者提示用户输入要发送的消息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token parameter variable">-1</span> <span class="token keyword">while</span> <span class="token number">1</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token variable">$nofile</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>gets <span class="token variable">$mesg</span> chars<span class="token punctuation">]</span> <span class="token operator">==</span> -1<span class="token punctuation">}</span> <span class="token builtin class-name">break</span>    <span class="token builtin class-name">set</span> line <span class="token string">"<span class="token variable">$chars</span> "</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    expect_user <span class="token punctuation">{</span> <span class="token parameter variable">-re</span> <span class="token string">" "</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    eof <span class="token builtin class-name">break</span> <span class="token punctuation">}</span> <span class="token builtin class-name">set</span> line <span class="token variable">$expect_out</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token punctuation">}</span> foreach spawn_id <span class="token variable">$procs</span> <span class="token punctuation">{</span> send <span class="token variable">$line</span> <span class="token punctuation">}</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>这段代码说明了实际的消息文本是如何通过无限循环while被发送的。</p></li><li><p>while循环中的if判断消息是如何得到的。在非交互模式下，下一行内容从消息文件中读出，当文件内容结束时while循环也就结束了。(break命令实现终止循环) 。</p></li><li><p>在交互模式下，expect_user命令从用户接收消息，当用户输入ctrl+D时结束输入，循环同时结束。 两种情况下变量$line都被用来保存下一行消息内容。当是消息文件时，回车会被附加到消息的尾部。</p></li><li><p>foreach循环遍历spawn的所有进程，这些进程的ID号都保存在列表变量$procs中，实现分别和各个进程通信。send命令组成了foreach的循环体，发送一行消息到当前的write进程。while循环的最后是一个sleep命令，主要是用于处理非交互模式情况下，以确保消息 不会太快的发送给各个write进程。当while循环退出时，expect脚本结束。</p></li></ol><h1 id="4-expect脚本常用选项"><a href="#4-expect脚本常用选项" class="headerlink" title="4 expect脚本常用选项"></a>4 expect脚本常用选项</h1><h2 id="4-1-c-选项"><a href="#4-1-c-选项" class="headerlink" title="4.1 -c 选项"></a>4.1 -c 选项</h2><p>使用“-c”选项，从命令行执行expect脚本</p><p>expect可以让你使用“-c”选项，直接在命令行中执行它，如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">expect</span> <span class="token parameter variable">-c</span> 'expect <span class="token string">"<span class="token entity" title="\n">\n</span>"</span> <span class="token punctuation">{</span>send <span class="token string">"pressed enter<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">}</span> pressed enter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你执行了上面的脚本，它会等待输入换行符（\n）。按“enter”键以后，它会打印出“pressed enter”这个消息，然后退出。</p><h2 id="4-2-i-选项"><a href="#4-2-i-选项" class="headerlink" title="4.2  -i 选项"></a>4.2  -i 选项</h2><p>使用“-i”选项交互地执行expect脚本</p><p>使用“-i”选项，可以通过来自于标准输入的读命令来交互地执行expect脚本。如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">expect</span> <span class="token parameter variable">-i</span> arg1 arg2 arg3 expect1.<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>set argv arg1 arg2 arg3 expect1.<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>正常情况下，当你执行上面的expect命令的时候（没有“-i”选项），它会把arg1当成脚本的文件名，所以“-i”选项可以让脚本把多个参数当成一个连续的列表。</p><p>当你执行带有“-c”选项的expect脚本的时候，这个选项是十分有用的。因为默认情况下，expect是交互地执行的。</p><h2 id="4-3-d选项"><a href="#4-3-d选项" class="headerlink" title="4.3 -d选项"></a>4.3 -d选项</h2><p>当执行expect脚本的时候，输出调试信息</p><p>当你用“-d”选项执行代码的时候，你可以输出诊断的信息。如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> sample.exp <span class="token comment"># !/usr/bin/expect -fexpect "\n";send "pressed enter";$ expect -d sample.expexpect version 5.43.0argv[0] = expect argv[1] = -d argv[2] = sample.expset argc 0set argv0 "sample.exp"set argv ""executing commands from command file sample.exp </span>expect: does <span class="token string">""</span> <span class="token punctuation">(</span>spawn_id exp0<span class="token punctuation">)</span> match glob pattern <span class="token string">"<span class="token entity" title="\n">\n</span>"</span>? no expect: does <span class="token string">"<span class="token entity" title="\n">\n</span>"</span> <span class="token punctuation">(</span>spawn_id exp0<span class="token punctuation">)</span> match glob pattern <span class="token string">"<span class="token entity" title="\n">\n</span>"</span>? <span class="token function">yes</span> expect: <span class="token builtin class-name">set</span> expect_out<span class="token punctuation">(</span><span class="token number">0</span>,string<span class="token punctuation">)</span> <span class="token string">"<span class="token entity" title="\n">\n</span>"</span> expect: <span class="token builtin class-name">set</span> expect_out<span class="token punctuation">(</span>spawn_id<span class="token punctuation">)</span> <span class="token string">"exp0"</span> expect: <span class="token builtin class-name">set</span> expect_out<span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token string">"<span class="token entity" title="\n">\n</span>"</span> send: sending <span class="token string">"pressed enter"</span> to <span class="token punctuation">{</span> exp0 pressed enter<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-D选项"><a href="#4-4-D选项" class="headerlink" title="4.4 -D选项"></a>4.4 -D选项</h2><p>使用“-D”选项启动expect调试器</p><p>“-D”选项用于启动调试器，它只接受一个布尔值的参数。这个参数表示提示器必须马上启动，还是只是初始化调试器，以后再使用它。</p><p>“-D”选项左边的选项会在调试器启动以前被处理。然后，在调试器启动以后，剩下的命令才会被执行。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">expect</span> <span class="token parameter variable">-c</span> <span class="token string">'set timeout 10'</span> <span class="token parameter variable">-D</span> <span class="token number">1</span> <span class="token parameter variable">-c</span> <span class="token string">'set a 1'</span> <span class="token number">1</span>: <span class="token builtin class-name">set</span> a <span class="token number">1</span> dbg1.<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-5-b选项"><a href="#4-5-b选项" class="headerlink" title="4.5 -b选项"></a>4.5 -b选项</h2><p>逐行地执行expect脚本</p><p>通常，expect会在执行脚本之前，把整个脚本都读入到内存中。“-b”选项可以让expect一次只读取脚本中的一行。当你没有写完整个脚本的时候，这是十分有用的，expect可以开始执行这个不完整的脚本，并且，它可以避免把脚本写入到临时文件中。</p><h2 id="6、让expect不解释命令行参数"><a href="#6、让expect不解释命令行参数" class="headerlink" title="6、让expect不解释命令行参数"></a>6、让expect不解释命令行参数</h2><p>你可以使用标识符让expect不解释命令行参数。</p><p>你可以像下面这样的读入命令行参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> print_cmdline_args.exp <span class="token comment">#!/usr/bin/expect </span>puts <span class="token string">'argv0 : [lindex $argv 0]'</span><span class="token punctuation">;</span> puts <span class="token string">'argv1 : [lindex $argv 1]'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当执行上面的脚本的时候，会跳过命令行选项，它们会被当成参数（而不是expect选项），如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">expect</span> print_cmdline_args.exp <span class="token parameter variable">-d</span> <span class="token parameter variable">-c</span> argv0 <span class="token builtin class-name">:</span> <span class="token parameter variable">-d</span> argv1 <span class="token builtin class-name">:</span> <span class="token parameter variable">-c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="5-expect简单例子"><a href="#5-expect简单例子" class="headerlink" title="5 expect简单例子"></a>5 expect简单例子</h1><p>为了更好理解except脚本几个简单参数，我们再举一个简单的例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect   </span><span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token number">30</span>   spawn <span class="token function">ssh</span> <span class="token parameter variable">-l</span> username <span class="token number">192.168</span>.1.1   <span class="token function">expect</span> <span class="token string">"password:"</span> <span class="token punctuation">{</span>send <span class="token string">"ispass<span class="token entity" title="\r">\r</span>"</span>interact<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li><p>[#!/usr/bin/expect]这一行告诉操作系统脚本里的代码使用那一个shell来执行。这里的expect其实和linux下的bash、windows下的cmd是一类东西。 注意：这一行需要在脚本的第一行。  </p></li><li><p>[set timeout 30] 基本上认识英文的都知道这是设置超时时间的，现在你只要记住他的计时单位是：秒  </p></li><li><p>[spawn ssh -l username 10.0.0.8] spawn是进入expect环境后才可以执行的expect内部命令，如果没有装expect或者直接在默认的SHELL下执行是找不到spawn命令的。所以不要用 “which spawn“之类的命令去找spawn命令。好比windows里的dir就是一个内部命令，这个命令由shell自带，你无法找到一个<a href="https://link.zhihu.com/?target=http://dir.com">http://dir.com</a> 或 dir.exe 的可执行文件。 它主要的功能是给ssh运行进程加个壳，用来传递交互指令。  </p></li><li><p>[expect “password:”] 这里的expect也是expect的一个内部命令，有点晕吧，expect的shell命令和内部命令是一样的，但不是一个功能，习惯就好了。这个命令的意思是判断上次输出结果里是否包含“password:”的字符串，如果有则立即返回，否则就等待一段时间后返回，这里等待时长就是前面设置的30秒  </p></li><li><p>[send “ispass\r”] 这里就是执行交互动作，与手工输入密码的动作等效。<br> 温馨提示： 命令字符串结尾别忘记加上 “\r”，如果出现异常等待的状态可以核查一下。  </p></li><li><p>[interact] 执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。如果你只是登录过去执行一段命令就退出，可改为[expect eof]</p></li></ol><h1 id="6-expect实用案例"><a href="#6-expect实用案例" class="headerlink" title="6 expect实用案例"></a>6 expect实用案例</h1><h2 id="6-1-expect实现ssh免密登陆"><a href="#6-1-expect实现ssh免密登陆" class="headerlink" title="6.1 expect实现ssh免密登陆"></a>6.1 expect实现ssh免密登陆</h2><p>说明：用了两个脚本，一个bash脚本，在其中调用另外一个expect脚本，两个脚本放在同一个目录下： 1. bash脚本：send_key.sh</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># 批量推送免密脚本 调用expect交互</span><span class="token comment"># 1 检测是否安装expect，如果没有安装就自动安装</span><span class="token function">rpm</span> <span class="token parameter variable">-qa</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">expect</span> <span class="token operator">&amp;&gt;</span> /etc/null<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token parameter variable">-ne</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token keyword">then</span>  yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">expect</span> tcl tclx tcl-devel<span class="token keyword">fi</span><span class="token comment"># 2 检测是否存在密钥文件,如果不存在密钥文件则自动生成</span><span class="token comment"># 如果密钥文件不存在</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-f</span> ~/.ssh/id_rsa <span class="token punctuation">]</span><span class="token keyword">then</span> <span class="token comment"># 创建密钥文件</span>  ssh-keygen <span class="token parameter variable">-P</span> <span class="token string">""</span> <span class="token parameter variable">-f</span> ~/.ssh/id_rsa<span class="token comment"># else</span><span class="token keyword">fi</span><span class="token comment"># 3 检测主机是否在线，并推送密钥  # 需要提前准备好host.txt文件</span><span class="token keyword">for</span> <span class="token for-or-select variable">ip</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> hosts.txt<span class="token variable">`</span></span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token comment"># 推送密钥前先做连通测试，连不上就不做免密推送</span>  <span class="token function">ping</span> <span class="token parameter variable">-c2</span> <span class="token parameter variable">-W1</span> <span class="token variable">${ip}</span> <span class="token operator">&amp;&gt;</span> /etc/null  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token parameter variable">-eq</span> <span class="token number">0</span> <span class="token punctuation">]</span>  <span class="token keyword">then</span>      /usr/bin/expect ssh_key_send.exp <span class="token variable">${ip}</span>      <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${ip}</span>免密已完成 <span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span>"</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token parameter variable">-a</span> online.txt  <span class="token keyword">else</span>      <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${ip}</span>不在线 <span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span>"</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token parameter variable">-a</span> offline.txt  <span class="token keyword">fi</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span><span class="token comment"># 放在{执行代码}&amp;是将程序放在后台执行，高并发</span><span class="token keyword">done</span><span class="token comment"># wait--等待前面的程序执行完毕后再执行后面的程序</span><span class="token function">wait</span><span class="token builtin class-name">echo</span> <span class="token string">"免密推送完成"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）expect脚本：(ssh_key_send.exp)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect</span><span class="token comment"># 声明执行脚本的程序是expect</span><span class="token comment"># 执行免密交互</span><span class="token comment"># 超时时间为5秒</span><span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token number">5</span><span class="token comment"># 设置接收外部变量参数</span><span class="token builtin class-name">set</span> IPSITE <span class="token punctuation">[</span> lindex <span class="token variable">$argv</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token comment"># set USRE [ lindex $argv 1 ]</span><span class="token comment"># set PASSWORD [ lindex $argv 2 ]</span><span class="token comment"># expect中的监控程序，其运行会监控命令提出的交互式问题</span>spawn ssh-copy-id <span class="token variable">$IPSITE</span><span class="token comment"># send   #发送问题答案给交互命令</span><span class="token comment"># "\r"   #表示回车</span><span class="token comment"># exp_continue #当问题不存在时继续回答下边的问题</span><span class="token comment"># expect eof   #问题回答完毕退出expect环境</span><span class="token comment"># interact     #问题回答完毕留在交互界面</span><span class="token comment"># set NAME [ lindex $argv n ]  #定义变量，用于接收外部参数</span><span class="token function">expect</span> <span class="token punctuation">{</span>    <span class="token string">"yes/no"</span> <span class="token punctuation">{</span>send <span class="token string">"yes<span class="token entity" title="\r">\r</span>"</span><span class="token punctuation">;</span>exp_continue<span class="token punctuation">}</span>    <span class="token string">"password:"</span> <span class="token punctuation">{</span>send <span class="token string">"1234567<span class="token entity" title="\r">\r</span>"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">expect</span> eof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-2-ssh实现自动登录-并停在登录服务器上"><a href="#6-2-ssh实现自动登录-并停在登录服务器上" class="headerlink" title="6.2 ssh实现自动登录,并停在登录服务器上"></a>6.2 ssh实现自动登录,并停在登录服务器上</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect -f </span><span class="token builtin class-name">set</span> <span class="token function">ip</span> <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">0</span> <span class="token punctuation">]</span>   //接收第一个参数,并设置IP <span class="token builtin class-name">set</span> password <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">1</span> <span class="token punctuation">]</span>  //接收第二个参数,并设置密码 <span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token number">10</span>          //设置超时时间 spawn <span class="token function">ssh</span> root@<span class="token variable">$ip</span>    //发送ssh请滶 <span class="token function">expect</span> <span class="token punctuation">{</span>         //返回信息匹配 <span class="token string">"*yes/no"</span> <span class="token punctuation">{</span> send <span class="token string">"yes<span class="token entity" title="\r">\r</span>"</span><span class="token punctuation">;</span> exp_continue<span class="token punctuation">}</span> //第一次ssh连接会提示yes/no,继续 <span class="token string">"*password:"</span> <span class="token punctuation">{</span> send <span class="token string">"<span class="token variable">$password</span><span class="token entity" title="\r">\r</span>"</span> <span class="token punctuation">}</span>   //出现密码提示,发送密码 <span class="token punctuation">}</span> interact     //交互模式,用户会停留在远程服务器上面.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下:</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Last login: Sun Dec 20 12:45:12 2020 from 10.0.0.9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-3-根据IP和密码连接到不同的机器"><a href="#6-3-根据IP和密码连接到不同的机器" class="headerlink" title="6.3 根据IP和密码连接到不同的机器."></a>6.3 根据IP和密码连接到不同的机器.</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect -f </span><span class="token builtin class-name">set</span> <span class="token function">ip</span> <span class="token number">10.0</span>.0.10 <span class="token builtin class-name">set</span> password admin <span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token number">10</span> spawn <span class="token function">ssh</span> root@<span class="token variable">$ip</span> <span class="token function">expect</span> <span class="token punctuation">{</span> <span class="token string">"*yes/no"</span> <span class="token punctuation">{</span> send <span class="token string">"yes<span class="token entity" title="\r">\r</span>"</span><span class="token punctuation">;</span> exp_continue<span class="token punctuation">}</span> <span class="token string">"*password:"</span> <span class="token punctuation">{</span> send <span class="token string">"<span class="token variable">$password</span><span class="token entity" title="\r">\r</span>"</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">expect</span> eof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下:</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Last login: Sun Dec 20 12:37:33 2020 from 10.0.0.9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-4-远程登录到服务器-并且执行命令-执行完后并退出"><a href="#6-4-远程登录到服务器-并且执行命令-执行完后并退出" class="headerlink" title="6.4 远程登录到服务器,并且执行命令,执行完后并退出"></a>6.4 远程登录到服务器,并且执行命令,执行完后并退出</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect -f </span><span class="token builtin class-name">set</span> <span class="token function">ip</span> <span class="token number">10.0</span>.0.13<span class="token builtin class-name">set</span> password admin <span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token number">10</span> spawn <span class="token function">ssh</span> root@<span class="token variable">$ip</span> <span class="token function">expect</span> <span class="token punctuation">{</span>  <span class="token string">"*yes/no"</span> <span class="token punctuation">{</span> send <span class="token string">"yes<span class="token entity" title="\r">\r</span>"</span><span class="token punctuation">;</span> exp_continue<span class="token punctuation">}</span> <span class="token string">"*password:"</span> <span class="token punctuation">{</span> send <span class="token string">"<span class="token variable">$password</span><span class="token entity" title="\r">\r</span>"</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token function">expect</span> <span class="token string">"#*"</span> send <span class="token string">"pwd<span class="token entity" title="\r">\r</span>"</span> send <span class="token string">"exit<span class="token entity" title="\r">\r</span>"</span> <span class="token function">expect</span> eof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>. root@ubuntu:/home/zhangy<span class="token comment"># ./test3.exp </span><span class="token number">2</span>. spawn <span class="token function">ssh</span> root@10.0.0.13 <span class="token number">3</span>. root@10.0.0.13's password: <span class="token number">4</span>.Last login: Sun Dec <span class="token number">20</span> <span class="token number">12</span>:45:32 <span class="token number">2020</span> from <span class="token number">10.0</span>.0.9<span class="token number">5</span>. <span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># pwd </span><span class="token number">6</span>. /root <span class="token number">7</span>. <span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># exit</span> 登出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5-使用expect调用passwd自动更改密码"><a href="#6-5-使用expect调用passwd自动更改密码" class="headerlink" title="6.5 使用expect调用passwd自动更改密码"></a>6.5 使用expect调用passwd自动更改密码</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash </span><span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span>mynameuser <span class="token assign-left variable">PASS</span><span class="token operator">=</span>oldpassword <span class="token assign-left variable">NPASS</span><span class="token operator">=</span>newpassword <span class="token function">expect</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF spawn passwd expect "Changing password for <span class="token variable">${<span class="token environment constant">USER</span>}</span>." send "<span class="token variable">${PASS}</span><span class="token entity" title="\r">\r</span>" expect "Enter new UNIX password:" send "<span class="token variable">${NPASS}</span><span class="token entity" title="\r">\r</span>" expect "Retype new UNIX password:" send "<span class="token variable">${NPASS}</span><span class="token entity" title="\r">\r</span>" expect eof; EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-6-完成对服务器的scp任务："><a href="#6-6-完成对服务器的scp任务：" class="headerlink" title="6.6 完成对服务器的scp任务："></a>6.6 完成对服务器的scp任务：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect </span><span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token number">10</span> <span class="token builtin class-name">set</span> <span class="token function">host</span> <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token builtin class-name">set</span> username <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token builtin class-name">set</span> password <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token builtin class-name">set</span> src_file <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token builtin class-name">set</span> dest_file <span class="token punctuation">[</span>lindex <span class="token variable">$argv</span> <span class="token number">4</span><span class="token punctuation">]</span> spawn <span class="token function">scp</span> <span class="token variable">$src_file</span> <span class="token variable">$username</span>@<span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$dest_file</span> <span class="token function">expect</span> <span class="token punctuation">{</span> <span class="token string">"(yes/no)?"</span> <span class="token punctuation">{</span> send <span class="token string">"yes<span class="token entity" title="\r">\r</span>"</span><span class="token punctuation">;</span>exp_continue<span class="token punctuation">}</span> <span class="token string">"*assword:"</span> <span class="token punctuation">{</span> send <span class="token string">"<span class="token variable">$password</span><span class="token entity" title="\r">\r</span>"</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token function">expect</span> <span class="token string">"100%"</span> <span class="token function">expect</span> eof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li><p>注意代码刚开始的第一行，指定了expect的路径，与shell脚本相同，这一句指定了程序在执行时到哪里去寻找相应的启动程序。代码刚开始还设定了timeout的时间为10秒，如果在执行scp任务时遇到了代码中没有指定的异常，则在等待10秒后该脚本的执行会自动终止。</p></li><li><p>这个脚本设置了5个需要手动输入的参数，分别为：目标主机的IP、用户名、密码、本地文件路径、目标主机中的文件路径。如果将以上脚本保存为expect_scp文件，则在shell下执行时需要按以下的规范来输入命令：</p></li></ol><pre class="line-numbers language-text" data-language="text"><code class="language-text">./expect_scp 10.0.0.20 root 123456 /root/src_file /root/dest_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上的命令执行后，将把本地/root目录下的src_file文件拷贝到用户名为root，密码为123456的主机192.168.75.130中的/root下，同时还将这个源文件重命名为dest_file。</p><ol start="3"><li>spawn代表在本地终端执行的语句，在该语句开始执行后，expect开始捕获终端的输出信息，然后做出对应的操作。expect代码中的捕获的(yes/no)内容用于完成第一次访问目标主机时保存密钥的操作。有了这一句，scp的任务减少了中断的情况。代码结尾的expect eof与spawn对应，表示捕获终端输出信息的终止。</li></ol><p>如果需要实现批量scp的任务，则需要再写一个shell脚本来调用这个expect脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh </span><span class="token assign-left variable">list_file</span><span class="token operator">=</span><span class="token variable">$1</span> <span class="token assign-left variable">src_file</span><span class="token operator">=</span><span class="token variable">$2</span> <span class="token assign-left variable">dest_file</span><span class="token operator">=</span><span class="token variable">$3</span> <span class="token function">cat</span> <span class="token variable">$list_file</span> <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line <span class="token keyword">do</span> <span class="token assign-left variable">host_ip</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> $line <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">`</span></span> <span class="token assign-left variable">username</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> $line <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span><span class="token variable">`</span></span> <span class="token assign-left variable">password</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> $line <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $3}'</span><span class="token variable">`</span></span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$host_ip</span>"</span> ./expect_scp  <span class="token variable">$host_ip</span>  <span class="token variable">$username</span>  <span class="token variable">$password</span>  <span class="token variable">$src_file</span>  <span class="token variable">$dest_file</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定了3个参数：列表文件的位置、本地源文件路径、远程主机目标文件路径。需要说明的是其中的列表文件指定了远程主机ip、用户名、密码，这些信息需要写成以下的格式： IP username password</p><p>中间用空格或tab键来分隔，多台主机的信息需要写多行内容，如： 10.0.0.19 root 123456 10..0.0.20 root testpass</p><p>这样就指定了两台远程主机的信息。注意，如果远程主机密码中有“$”、“#”这类特殊字符的话，在编写列表文件时就需要在这些特殊字符前加上转义字符，否则expect在执行时会输入错误的密码。</p><p>执行脚本</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">./batch_scp.sh ./hosts.list /root/src_file /root/destfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用这两个脚本文件，就可以简单地完成批量scp的任务了。</p><h1 id="7-综合实例"><a href="#7-综合实例" class="headerlink" title="7 综合实例"></a>7 综合实例</h1><p>自动化脚本建立主机之间的SSH信任关系</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment">#./ssh_trust.sh host1 user1 passwd1 host2 user2 passwd2 </span><span class="token comment"># 即建立从user1@host1到user2@host2的ssh信任。 </span><span class="token assign-left variable">src_host</span><span class="token operator">=</span><span class="token variable">$1</span> <span class="token assign-left variable">src_username</span><span class="token operator">=</span><span class="token variable">$2</span> <span class="token assign-left variable">src_passwd</span><span class="token operator">=</span><span class="token variable">$3</span> <span class="token assign-left variable">dst_host</span><span class="token operator">=</span><span class="token variable">$4</span> <span class="token assign-left variable">dst_username</span><span class="token operator">=</span><span class="token variable">$5</span> <span class="token assign-left variable">dst_passwd</span><span class="token operator">=</span><span class="token variable">$6</span> <span class="token comment">#在远程主机1上生成公私钥对 </span><span class="token keyword">function</span> <span class="token function-name function">Keygen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">expect</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF spawn ssh <span class="token variable">$src_username</span>@<span class="token variable">$src_host</span> ssh-keygen -t rsa  while 1 {      expect {          "password:" { send "<span class="token variable">$src_passwd</span><span class="token entity" title="\r">\r</span>";exp_continue}          "yes/no*" { send "yes<span class="token entity" title="\r">\r</span>";exp_continue}           "Enter file in which to save the key*" {send "<span class="token entity" title="\r">\r</span>";exp_continue}           "Enter passphrase*" { send "<span class="token entity" title="\r">\r</span>";exp_continue}           "Enter same passphrase again:" { send "<span class="token entity" title="\r">\r</span>" ;exp_continue}            "Overwrite (y/n)" {send "n<span class="token entity" title="\r">\r</span>";exp_continue}           eof { exit }             }           } EOF</span>  <span class="token punctuation">}</span> <span class="token comment">#从远程主机1获取公钥保存到本地 </span><span class="token keyword">function</span> <span class="token function-name function">Get_pub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">expect</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF spawn scp <span class="token variable">$src_username</span>@<span class="token variable">$src_host</span>:~/.ssh/id_rsa.pub /tmp expect {       "password:" {send "<span class="token variable">$src_passwd</span><span class="token entity" title="\n">\n</span>";exp_continue}         "yes/no*" {send "yes<span class="token entity" title="\n">\n</span>";exp_continue}           eof { exit }        } EOF</span>  <span class="token punctuation">}</span> <span class="token comment">#将公钥的内容附加到远程主机2的authorized_keys </span><span class="token keyword">function</span> <span class="token function-name function">Put_pub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token assign-left variable">src_pub</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> /tmp/id_rsa.pub<span class="token variable">)</span></span>"</span> <span class="token function">expect</span> <span class="token operator">&lt;&lt;</span> EOF  spawn <span class="token function">ssh</span> <span class="token variable">$dst_username</span>@<span class="token variable">$dst_host</span> <span class="token string">"mkdir -p ~/.ssh;echo <span class="token variable">$src_pub</span> &gt;&gt; ~/.ssh/authorized_keys;chmod 600 ~/.ssh/authorized_keys"</span> <span class="token function">expect</span> <span class="token punctuation">{</span>       <span class="token string">"password:"</span> <span class="token punctuation">{</span>send <span class="token string">"<span class="token variable">$dst_passwd</span><span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">;</span>exp_continue<span class="token punctuation">}</span>       <span class="token string">"yes/no*"</span> <span class="token punctuation">{</span>send <span class="token string">"yes<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">;</span>exp_continue<span class="token punctuation">}</span>        eof <span class="token punctuation">{</span> <span class="token builtin class-name">exit</span> <span class="token punctuation">}</span>         <span class="token punctuation">}</span>  EOF  <span class="token punctuation">}</span><span class="token comment"># 调用函数执行</span>Keygen Get_pub Put_pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> expect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本学习01--入门</title>
      <link href="/blog/be73ac2a.html"/>
      <url>/blog/be73ac2a.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Shell是一种脚本语言，那么，就必须有解释器来执行这些脚本。</p></blockquote><p>Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>打开文本编辑器，新建一个文件<code>test.sh</code>，扩展名为<code>.sh</code>（sh代表shell）。</p><p>输入一些代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"Hello World !"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在命令行运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x test.sh./test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hello World <span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>#!</code> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即<strong>使用哪一种Shell</strong>。<code>echo</code>命令用于向窗口输出文本。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>以<code>#</code>开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个#号。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># --------</span><span class="token comment"># 这是注释块</span><span class="token comment"># --------</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h2><p><strong>echo</strong>： 是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> arg <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> arg <span class="token comment">#执行arg里的转义字符。echo加了-e默认会换行</span><span class="token builtin class-name">echo</span> arg <span class="token operator">&gt;</span> myfile <span class="token comment">#显示结果重定向至文件，会生成myfile文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，echo后单引号和双引号作用是不同的。单引号不能转义里面的字符。双引号可有可无，单引号主要用在原样输出中。</p><p><strong>printf</strong>：格式化输出语句。<br><code>printf</code> 命令用于格式化输出， 是<code>echo</code>命令的增强版。它是C语言<code>printf()</code>库函数的一个有限的变形，并且在语法上有些不同。</p><p>如同 <code>echo</code> 命令，<code>printf</code> 命令也可以输出简单的字符串:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">printf</span> <span class="token string">"hello<span class="token entity" title="\n">\n</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>printf</code> 不像 <code>echo</code> 那样会自动换行，必须显式添加换行符(\n)。</p><p>注意：<code>printf</code> 由 POSIX 标准所定义，移植性要比 <code>echo</code> 好。</p><p>printf 命令的语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">printf</span>  format-string  <span class="token punctuation">[</span>arguments<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#format-string 为格式控制字符串，arguments 为参数列表。功能和用法与c语言的 printf 命令类似。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里仅说明与C语言printf()函数的不同：</p><ul><li>printf 命令不用加括号</li><li>format-string 可以没有引号，但最好加上，单引号双引号均可。</li><li>参数比格式控制符(%)多时，格式控制符可以重用，可以将所有参数都转换。</li><li>arguments 使用空格分隔，不用逗号。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 双引号</span><span class="token builtin class-name">printf</span> <span class="token string">"%d %s<span class="token entity" title="\n">\n</span>"</span> <span class="token number">10</span> <span class="token string">"abc"</span><span class="token number">10</span> abc<span class="token comment"># 单引号与双引号效果一样 </span><span class="token builtin class-name">printf</span> <span class="token string">'%d %s\n'</span> <span class="token number">10</span> <span class="token string">"abc"</span> <span class="token number">10</span> abc<span class="token comment"># 没有引号也可以输出</span><span class="token builtin class-name">printf</span> %s abcabc<span class="token comment"># 但是下面的会出错：</span><span class="token builtin class-name">printf</span> %d %s <span class="token number">10</span> abc <span class="token comment">#因为系统分不清楚哪个是参数，这时候最好加引号了。</span><span class="token comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span>$ <span class="token builtin class-name">printf</span> %s a b cabc$ <span class="token builtin class-name">printf</span> <span class="token string">"%s<span class="token entity" title="\n">\n</span>"</span> a b cabc<span class="token comment"># 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span>$ <span class="token builtin class-name">printf</span> <span class="token string">"%s and %d <span class="token entity" title="\n">\n</span>"</span> and <span class="token number">0</span><span class="token comment"># 如果以 %d 的格式来显示字符串，那么会有警告，提示无效的数字，此时默认置为 0</span>$ <span class="token builtin class-name">printf</span> <span class="token string">"The first program always prints'%s,%d<span class="token entity" title="\n">\n</span>'"</span> Hello Shell-bash: printf: Shell: invalid numberThe first program always prints <span class="token string">'Hello,0'</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>read</strong>： 命令行从输入设备读入内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># Author : lalal</span><span class="token builtin class-name">echo</span> <span class="token string">"What is your name?"</span><span class="token builtin class-name">read</span> NAME <span class="token comment">#输入</span><span class="token builtin class-name">echo</span> <span class="token string">"Hello, <span class="token variable">$NAME</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x test.sh./test.shWhat is your name?lalalHello, lalal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>Shell支持自定义变量。</p><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量时，变量名不加美元符号（$），如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">variableName</span><span class="token operator">=</span><span class="token string">"value"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，<strong>变量名和等号之间不能有空格</strong>，这可能和你熟悉的所有编程语言都不一样。有空格会出错。</p><p>同时，变量名的命名须遵循如下规则：</p><blockquote><ul><li>首个字符必须为字母（a-z，A-Z）。</li></ul></blockquote><ul><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>变量定义举例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">myUrl</span><span class="token operator">=</span><span class="token string">"lalal"</span><span class="token assign-left variable">myNum</span><span class="token operator">=</span><span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注意：变量中间不能有空格，如果手误写错(例如 <code>var = test</code>)，刚好要使用<code>rm -rf $var/</code>删除这个目录，实际删除的是<code>/</code>！</p></blockquote><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号（$）即可，如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">your_name</span><span class="token operator">=</span><span class="token string">"lalal"</span><span class="token builtin class-name">echo</span> <span class="token variable">$your_name</span><span class="token builtin class-name">echo</span> <span class="token variable">${your_name}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>变量名外面的花括号是可选的</strong>，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">skill</span> <span class="token keyword">in</span> C PHP Python Java <span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"I am good at <span class="token variable">${skill}</span>Script"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果不给skill变量加花括号，写成<code>echo "I am good at $skillScript"</code>，解释器就会把<code>$skillScript</code>当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p><strong>推荐给所有变量加上花括号，这是个好的编程习惯。</strong></p><blockquote><p>已定义的变量，可以被重新定义。</p></blockquote><p>在变量前面加<code>readonly</code> 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">url</span><span class="token operator">=</span><span class="token string">"http://www.baidu.com"</span><span class="token builtin class-name">readonly</span> url<span class="token assign-left variable">url</span><span class="token operator">=</span><span class="token string">"http://www.baidu.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>unset</code> 命令可以删除变量。语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">unset</span> variable_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量被删除后不能再次使用；unset 命令不能删除只读变量。</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>运行shell时，会同时存在三种变量：<br><strong>1) 局部变量</strong><br>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</p><p><strong>2) 环境变量</strong><br>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</p><p><strong>3) shell变量</strong><br>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。</p><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><p>前面已经讲到，<strong>变量名只能包含数字、字母和下划线</strong>，因为某些包含其他字符的变量有特殊含义，这样的变量被称为<strong>特殊变量</strong>。</p><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>当前脚本的文件名</td></tr><tr><td><code>$n</code></td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是<code>$1</code></td></tr><tr><td>，第二个参数是<code>$2</code></td><td></td></tr><tr><td>。</td><td></td></tr><tr><td><code>$#</code></td><td>传递给脚本或函数的参数个数。</td></tr><tr><td><code>$*</code></td><td>传递给脚本或函数的所有参数。</td></tr><tr><td><code>$@</code></td><td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 <code>$*</code></td></tr><tr><td>稍有不同</td><td></td></tr><tr><td><code>$?</code></td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td><code>$$</code></td><td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td></tr></tbody></table><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"File Name: <span class="token variable">$0</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"First Parameter : <span class="token variable">$1</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"Second Parameter : <span class="token variable">$2</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"Quoted Values: <span class="token variable">$@</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"Quoted Values: <span class="token variable">$*</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"Total Number of Parameters : <span class="token variable">$#</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$./test.sh Zara AliFile Name <span class="token builtin class-name">:</span> ./test.shFirst Parameter <span class="token builtin class-name">:</span> ZaraSecond Parameter <span class="token builtin class-name">:</span> AliQuoted Values: Zara AliQuoted Values: Zara AliTotal Number of Parameters <span class="token builtin class-name">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$* 和 $@ 的区别"></a><code>$*</code> 和 <code>$@</code> 的区别</h3><p><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以<code>"$1" "$2" … "$n"</code> 的形式输出所有参数。</p><p>但是当它们被双引号(“ “)包含时，”<code>$*</code>“ 会将所有的参数作为一个整体，以”<code>$1 $2 … $n</code>“的形式输出所有参数；”<code>$@</code>“ 会将各个参数分开，以<code>"$1" "$2" … "$n"</code> 的形式输出所有参数。</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"\<span class="token variable">$*</span>="</span> <span class="token variable">$*</span><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token entity" title="\&quot;">\"</span>\<span class="token variable">$*</span><span class="token entity" title="\&quot;">\"</span>="</span> <span class="token string">"<span class="token variable">$*</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"\<span class="token variable">$@</span>="</span> <span class="token variable">$@</span><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token entity" title="\&quot;">\"</span>\<span class="token variable">$@</span><span class="token entity" title="\&quot;">\"</span>="</span> <span class="token string">"<span class="token variable">$@</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"print each param from \<span class="token variable">$*</span>"</span><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> <span class="token variable">$*</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"print each param from \<span class="token variable">$@</span>"</span><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> <span class="token variable">$@</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"print each param from <span class="token entity" title="\&quot;">\"</span>\<span class="token variable">$*</span><span class="token entity" title="\&quot;">\"</span>"</span><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$*</span>"</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"print each param from <span class="token entity" title="\&quot;">\"</span>\<span class="token variable">$@</span><span class="token entity" title="\&quot;">\"</span>"</span><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$@</span>"</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>./test.sh "a" "b" "c" "d"</code>，看到下面的结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$*</span><span class="token operator">=</span>  a b c d<span class="token string">"<span class="token variable">$*</span>"</span><span class="token operator">=</span> a b c d<span class="token variable">$@</span><span class="token operator">=</span>  a b c d<span class="token string">"<span class="token variable">$@</span>"</span><span class="token operator">=</span> a b c dprint each param from <span class="token variable">$*</span>abcdprint each param from <span class="token variable">$@</span>abcdprint each param from <span class="token string">"<span class="token variable">$*</span>"</span>a b c dprint each param from <span class="token string">"<span class="token variable">$@</span>"</span>abcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h3><p><code>$?</code> 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> <span class="token string">"error"</span>  <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</p><p>不过，也有一些命令返回其他值，表示不同类型的错误。</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">转义字符含义<span class="token punctuation">\</span><span class="token punctuation">\</span>反斜杠<span class="token punctuation">\</span>a警报，响铃<span class="token punctuation">\</span>b退格（删除键）<span class="token punctuation">\</span>f换页<span class="token punctuation">(</span>FF<span class="token punctuation">)</span>，将当前位置移到下页开头<span class="token punctuation">\</span>n换行<span class="token punctuation">\</span>r回车<span class="token punctuation">\</span>t水平制表符（tab键） <span class="token punctuation">\</span>v垂直制表符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>shell默认是不转义上面的字符的。需要加</strong><code>**-e**</code><strong>选项。</strong></p><p>举个例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">11</span><span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"a is <span class="token variable">$a</span> <span class="token entity" title="\n">\n</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a is <span class="token number">11</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里 <code>-e</code> 表示对转义字符进行替换。如果不使用 <code>-e</code> 选项，将会原样输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a is <span class="token number">11</span><span class="token punctuation">\</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用 echo 命令的 <code>-E</code> 选项禁止转义，默认也是不转义的；使用 <code>-n</code> 选项可以禁止插入换行符。</p><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。</p><p>语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">command</span><span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意是反引号，不是单引号，这个键位于 Esc 键下方。</strong></p><p>下面的例子中，将命令执行结果保存在变量中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">DATE</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token string">"Date is <span class="token variable">$DATE</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><p>变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值。</p><p>可以使用的变量替换形式：</p><table><thead><tr><th>形式</th><th>说明</th></tr></thead><tbody><tr><td><code>${var}</code></td><td>变量本来的值</td></tr><tr><td><code>${var:-word}</code></td><td>如果变量 <code>var</code></td></tr><tr><td>为空或已被删除(unset)，那么返回 word，但不改变 <code>var</code></td><td></td></tr><tr><td>的值。</td><td></td></tr><tr><td><code>${var:=word}</code></td><td>如果变量 <code>var</code></td></tr><tr><td>为空或已被删除(unset)，那么返回 word，并将 <code>var</code></td><td></td></tr><tr><td>的值设置为 word。</td><td></td></tr><tr><td><code>${var:?message}</code></td><td>如果变量 <code>var</code></td></tr><tr><td>为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 <code>var</code></td><td></td></tr><tr><td>是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。</td><td></td></tr><tr><td><code>${var:+word}</code></td><td>如果变量 <code>var</code></td></tr><tr><td>被定义，那么返回 word，但不改变 var 的值。</td><td></td></tr></tbody></table><h2 id="一个完整的shell示例"><a href="#一个完整的shell示例" class="headerlink" title="一个完整的shell示例"></a>一个完整的shell示例</h2><p>下面的脚本用于php安装过程中安装zip扩展。</p><p><code>php_zip_ins.sh</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment">#zip install</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-d</span> php-5.4.25/ext/zip <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span><span class="token builtin class-name">cd</span> php-5.4.25/ext/zip<span class="token keyword">else</span><span class="token function">tar</span> zxvf php-5.4.25.tar.gz<span class="token builtin class-name">cd</span> php-5.4.25/ext/zip<span class="token keyword">fi</span>/usr/local/php/bin/phpize./configure --with-php-config<span class="token operator">=</span>/usr/local/php/bin/php-config<span class="token function">make</span><span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span><span class="token function">make</span> <span class="token function">install</span><span class="token builtin class-name">echo</span> <span class="token function">grep</span> <span class="token string">'no-debug-zts-20100525'</span> /usr/local/php/etc/php.ini<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>        <span class="token builtin class-name">echo</span> <span class="token string">''</span> <span class="token operator">&gt;&gt;</span> /usr/local/php/etc/php.ini        <span class="token builtin class-name">echo</span> <span class="token string">'extension_dir=/usr/local/php/lib/php/extensions/no-debug-zts-20100525'</span> <span class="token operator">&gt;&gt;</span> /usr/local/php/etc/php.ini<span class="token keyword">fi</span><span class="token function">grep</span> <span class="token string">'zip.so'</span> /usr/local/php/etc/php.ini<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span><span class="token builtin class-name">echo</span> <span class="token string">'extension=zip.so'</span> <span class="token operator">&gt;&gt;</span> /usr/local/php/etc/php.ini<span class="token keyword">fi</span><span class="token builtin class-name">echo</span> <span class="token string">"zip install is OK"</span>/usr/local/apache2/bin/apachectl restart<span class="token builtin class-name">cd</span> -<span class="token function">rm</span> <span class="token parameter variable">-rf</span> php-5.4.25<span class="token builtin class-name">echo</span> <span class="token string">"all ok!"</span><span class="token function">ls</span> /usr/local/php/lib/php/extensions/no-debug-zts-20100525/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell脚本基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22.04安装jenkins</title>
      <link href="/blog/b9484dca.html"/>
      <url>/blog/b9484dca.html</url>
      
        <content type="html"><![CDATA[<p>Jenkins 是一个支持<strong>持续集成</strong> （CI） 和<strong>持续交付</strong> （CD） 的 CI/CD 软件平台。它用于<a href="https://phoenixnap.com/blog/best-automation-testing-tools">自动化软件测试</a>、构建、交付和部署。在 Ubuntu 上使用 Jenkins 创建了一个强大的管理工具，将开发工作流程提升到一个新的水平。</p><p><strong>本指南将帮助您在 Ubuntu 22.04 系统上安装 Jenkins。</strong></p><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/install-jenkins-on-ubuntu-20230311150922716.png" alt="在 Ubuntu 22.04 上安装 Jenkins"></p><p>先决条件</p><ul><li>运行 <a href="https://phoenixnap.com/kb/ubuntu-22-04-lts">Ubuntu 22.04 Jammy Jellyfish</a> 的系统。</li><li>具有管理员权限的用户帐户。</li><li>访问终端窗口/命令行（<strong>CTRL</strong>+<strong>ALT</strong>+<strong>T</strong>）。</li><li><a href="https://phoenixnap.com/kb/how-to-install-java-ubuntu">Java 8 或 11 安装在 Ubuntu 上</a>。</li></ul><h2 id="1-安装-Java"><a href="#1-安装-Java" class="headerlink" title="1 安装 Java"></a>1 安装 Java</h2><p>Jenkins 需要 Java 运行时环境 （JRE）。本指南将 OpenJDK 用于 Java 环境。OpenJDK是一个开发工具包，包括Java运行时环境。</p><p>在撰写本文时，Jenkins 仅支持 <a href="https://phoenixnap.com/kb/how-to-install-java-ubuntu">Ubuntu 上的 Java 8 和 Java 11</a>。您可以在 Ubuntu 上安装多个版本的 Java。如果这样做，请确保将 Java 8 或 Java 11 设置为默认版本。</p><p>请按照以下步骤在 Ubuntu 上安装 Java：</p><ol><li><a href="https://phoenixnap.com/kb/check-java-version-linux">检查您的 Ubuntu 系统上是否已经安装了 Java</a>：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/check-java-version-20230311150923445.png" alt="检查 Java 是否安装在 Ubuntu 上。"></p><p>由于我们的系统上没有安装 Java，我们将使用 OpenJDK 安装它。</p><p><strong>注意</strong>：如果您的 Ubuntu 系统上安装了 Java，请跳到步骤 2。</p><ol start="2"><li>首先，打开终端窗口并通过运行以下命令更新系统包存储库：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入您的管理员密码并等待更新完成。</p><ol start="3"><li>根据要安装的 Java 版本（Java 8 或 11），运行以下命令之一：</li></ol><ul><li>要安装 OpenJDK 8，请运行：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openjdk-8-jdk <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>要安装OpenJDK 11，请运行：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openjdk-11-jdk <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们在系统上安装了OpenJDK版本11：</p><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/install-java-jdk-11-20230311150922776.png" alt="Installing Java JDK 11 on Ubuntu 22.04."></p><p><strong>注意：</strong>阅读我们的 Jenkins 教程，熟悉 <a href="https://phoenixnap.com/kb/jenkins-tutorial">Jenkins</a> 并开始熟练地使用它。</p><h2 id="2-添加-Jenkins-存储库"><a href="#2-添加-Jenkins-存储库" class="headerlink" title="2 添加 Jenkins 存储库"></a>2 添加 Jenkins 存储库</h2><p>建议使用项目维护的存储库安装 Jenkins，而不是从默认的 Ubuntu 存储库安装。原因是因为默认 Ubuntu 存储库中的 Jenkins 版本可能不是最新的可用版本，这意味着它可能缺少最新的功能和错误修复。</p><p>按照以下步骤将 Jenkins 存储库添加到您的 Ubuntu 系统中。</p><ol><li>首先导入 GPG 密钥。GPG 密钥验证包完整性，但没有输出。跑：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://pkg.jenkins.io/debian-stable/jenkins.io.key <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /usr/share/keyrings/jenkins-keyring.asc <span class="token operator">&gt;</span> /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>将 Jenkins 软件仓库添加到源列表中，并提供认证密钥：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> deb <span class="token punctuation">[</span>signed-by<span class="token operator">=</span>/usr/share/keyrings/jenkins-keyring.asc<span class="token punctuation">]</span> https://pkg.jenkins.io/debian-stable binary/ <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/apt/sources.list.d/jenkins.list <span class="token operator">&gt;</span> /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令将长期支持 （LTS） 稳定版本添加到源列表中，但没有输出。</p><h2 id="3-安装-Jenkins"><a href="#3-安装-Jenkins" class="headerlink" title="3 安装 Jenkins"></a>3 安装 Jenkins</h2><p>参考文章：<a href="https://blog.csdn.net/leeasj/article/details/129990269">https://blog.csdn.net/leeasj/article/details/129990269</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> <span class="token punctuation">\</span>  /usr/share/keyrings/jenkins-keyring.asc <span class="token operator">&gt;</span> /dev/null<span class="token builtin class-name">echo</span> deb <span class="token punctuation">[</span>signed-by<span class="token operator">=</span>/usr/share/keyrings/jenkins-keyring.asc<span class="token punctuation">]</span> <span class="token punctuation">\</span>  https://pkg.jenkins.io/debian-stable binary/ <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> <span class="token punctuation">\</span>  /etc/apt/sources.list.d/jenkins.list <span class="token operator">&gt;</span> /dev/null<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置先决条件后，请按照以下步骤在 Ubuntu 上安装 Jenkins：</p><ol><li>再次更新系统存储库。更新会刷新缓存，并使系统知道新的 Jenkins 存储库。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>通过运行以下命令安装 Jenkins：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> jenkins <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待下载和安装完成。</p><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/install-jenkins-on-ubuntu-22-04-20230311150923435.png" alt="在 Ubuntu 22.04 上安装 Jenkins。"></p><ol start="3"><li>要检查 Jenkins 是否已安装并正在运行，请运行以下命令：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl status jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出中应显示标记为**<code>活动（正在运行）</code>**的亮绿色条目，指示服务正在运行。</p><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/check-jenkins-status-20230311150922828.png" alt="检查 Jenkins 是否正在运行。"></p><ol start="4"><li>按 <strong>Ctrl</strong>+<strong>Z</strong> 退出状态屏幕。</li></ol><p><strong>注意：</strong>如果 Jenkins 服务未运行或未处于活动状态，请运行以下命令以启动它：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果systemcrl ，可以尝试下列命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> jenkins <span class="token builtin class-name">enable</span><span class="token function">sudo</span> <span class="token function">service</span> jenkins start<span class="token function">sudo</span> <span class="token function">service</span> jenkins statusUsage: /etc/init.d/jenkins <span class="token punctuation">{</span>start<span class="token operator">|</span>stop<span class="token operator">|</span>status<span class="token operator">|</span>restart<span class="token operator">|</span>try-restart<span class="token operator">|</span>force-reload<span class="token punctuation">}</span>● jenkins.service - Jenkins Continuous Integration Server     Loaded: loaded <span class="token punctuation">(</span>/lib/systemd/system/jenkins.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>     Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Fri <span class="token number">2023</span>-03-10 <span class="token number">20</span>:18:13 CST<span class="token punctuation">;</span> 1h 36min ago   Main PID: <span class="token number">13755</span> <span class="token punctuation">(</span>java<span class="token punctuation">)</span>      Tasks: <span class="token number">44</span> <span class="token punctuation">(</span>limit: <span class="token number">14169</span><span class="token punctuation">)</span>     Memory: <span class="token number">1</span>.7G        CPU: 1min <span class="token number">47</span>.785s     CGroup: /system.slice/jenkins.service             └─13755 /usr/bin/java <span class="token parameter variable">-Djava.awt.headless</span><span class="token operator">=</span>true <span class="token parameter variable">-jar</span> /usr/share/java/jenkins.war <span class="token parameter variable">--webroot</span><span class="token operator">=</span>/var/cache/jenkins/war <span class="token parameter variable">--httpPort</span><span class="token operator">=</span><span class="token number">8080</span><span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:16:59 jack-HP jenkins<span class="token punctuation">[</span><span class="token number">13755</span><span class="token punctuation">]</span>: 4659b088bffa44f5bbc0d559374a57c3<span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:16:59 jack-HP jenkins<span class="token punctuation">[</span><span class="token number">13755</span><span class="token punctuation">]</span>: This may also be found at: /var/lib/jenkins/secrets/initialAdminPassword<span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:16:59 jack-HP jenkins<span class="token punctuation">[</span><span class="token number">13755</span><span class="token punctuation">]</span>: *************************************************************<span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:16:59 jack-HP jenkins<span class="token punctuation">[</span><span class="token number">13755</span><span class="token punctuation">]</span>: *************************************************************<span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:16:59 jack-HP jenkins<span class="token punctuation">[</span><span class="token number">13755</span><span class="token punctuation">]</span>: *************************************************************<span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:17:57 jack-HP jenkins<span class="token punctuation">[</span><span class="token number">13755</span><span class="token punctuation">]</span>: <span class="token number">2023</span>-03-10 <span class="token number">12</span>:17:57.245+0000 <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">51</span><span class="token punctuation">]</span>        INFO        h.m.DownloadService<span class="token variable">$Downloadable</span><span class="token comment">#load: Obtained the updated data file for &gt;</span><span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:17:57 jack-HP jenkins<span class="token punctuation">[</span><span class="token number">13755</span><span class="token punctuation">]</span>: <span class="token number">2023</span>-03-10 <span class="token number">12</span>:17:57.246+0000 <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">51</span><span class="token punctuation">]</span>        INFO        hudson.util.Retrier<span class="token comment">#start: Performed the action check updates server succe&gt;</span><span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:18:13 jack-HP jenkins<span class="token punctuation">[</span><span class="token number">13755</span><span class="token punctuation">]</span>: <span class="token number">2023</span>-03-10 <span class="token number">12</span>:18:13.127+0000 <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">]</span>        INFO        jenkins.InitReactorRunner<span class="token variable">$1</span><span class="token comment">#onAttained: Completed initialization</span><span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:18:13 jack-HP jenkins<span class="token punctuation">[</span><span class="token number">13755</span><span class="token punctuation">]</span>: <span class="token number">2023</span>-03-10 <span class="token number">12</span>:18:13.148+0000 <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">]</span>        INFO        hudson.lifecycle.Lifecycle<span class="token comment">#onReady: Jenkins is fully up and running</span><span class="token number">3</span>月 <span class="token number">10</span> <span class="token number">20</span>:18:13 jack-HP systemd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Started Jenkins Continuous Integration Server.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-修改防火墙以允许-Jenkins"><a href="#4-修改防火墙以允许-Jenkins" class="headerlink" title="4 修改防火墙以允许 Jenkins"></a>4 修改防火墙以允许 Jenkins</h2><p>允许 Jenkins 通过设置默认的 UFW 防火墙进行通信。</p><ol><li>通过运行以下命令打开端口 8080：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw allow <span class="token number">8080</span><span class="token function">sudo</span> ufw allow OpenSSH<span class="token function">sudo</span> ufw status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/configure-ufw-firewall-20230311150923538.png" alt="配置 UFW 防火墙。"></p><p>如果您使用的是其他防火墙应用程序，请按照其特定说明允许端口 8080 上的流量。</p><ol start="2"><li>如果尚未配置 UFW 防火墙，它将显示为非活动状态。通过运行以下命令启用 <a href="https://phoenixnap.com/kb/how-to-enable-disable-firewall-ubuntu">UFW</a>：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw <span class="token builtin class-name">enable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/enable-ufw-firewall-20230311150923091.png" alt="在 Ubuntu 中启用 UFW 防火墙。"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw statusStatus: activeTo                         Action      From--                         ------      ----<span class="token number">8080</span>                       ALLOW       AnywhereOpenSSH                    ALLOW       Anywhere<span class="token number">8080</span> <span class="token punctuation">(</span>v6<span class="token punctuation">)</span>                  ALLOW       Anywhere <span class="token punctuation">(</span>v6<span class="token punctuation">)</span>OpenSSH <span class="token punctuation">(</span>v6<span class="token punctuation">)</span>               ALLOW       Anywhere <span class="token punctuation">(</span>v6<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>如果您需要更改端口，请查看我们的文章<a href="https://phoenixnap.com/kb/jenkins-change-port">如何更改 Jenkins 的端口</a>。</p><h2 id="5-设置-Jenkins"><a href="#5-设置-Jenkins" class="headerlink" title="5 设置 Jenkins"></a>5 设置 Jenkins</h2><p>请按照以下步骤设置 Jenkins 并开始使用它：</p><ol><li>打开 Web 浏览器，然后导航到服务器的 IP 地址。使用以下语法：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">http://ip_address_or_domain:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用您使用 Jenkins 的服务器的实际 IP 地址或域名。例如，如果您在本地运行 Jenkins，请使用</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">http://localhost:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/unlock-jenkins-20230311150923305.png" alt="安装后解锁詹金斯。"></p><p>将打开一个页面，提示您<strong>解锁 Jenkins</strong>。在下一步中获取所需的管理员密码。</p><ol start="2"><li>通过打开终端并运行以下命令来获取默认的 Jenkins 解锁密码：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cat</span> /var/lib/jenkins/secrets/initialAdminPassword<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/jenkins-password-20230311150923171.png" alt="获取 Jenkins 管理员密码。"></p><ol start="3"><li><p>系统返回一个字母数字代码。在<em>管理员密码</em>字段中输入该代码，然后单击<strong>继续</strong>。</p></li><li><p>安装程序会提示<strong>安装建议的插件</strong>或<strong>选择要安装的插件</strong>。只需安装建议的插件即可。</p></li></ol><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/install-jenkins-plugins-20230311150923685.png" alt="安装后自定义 Jenkins 插件。"></p><ol start="5"><li><p>您以后总是可以安装更多插件。系统继续进行Jenkins的初始设置。</p><p> 下一步是创建第一个管理员用户。输入您要用于Jenkins管理员的凭据，然后单击保存并继续。</p></li></ol><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/create-first-admin-user-20230311150923563.png" alt="在 Jenkins 中创建第一个管理员用户。"></p><ol start="6"><li>在此之后，您应该设置<strong>实例配置</strong>。这是此 Jenkins 安装的首选网络地址。确认要用于服务器的地址。这很可能与您用于访问此配置页面的地址相同。</li></ol><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/configure-jenkins-instance-20230311150923982.png" alt="配置 Jenkins 实例。"></p><p>指定 Jenkins URL 后，单击“<strong>保存并完成</strong>”。</p><ol start="7"><li>你应该看到一个页面，上面写着 <strong>Jenkins 已经准备好了！</strong>单击“开始使用 Jenkins”以打开 <strong>Jenkins</strong> 仪表板。</li></ol><p><img src="/../../../images/linux/HowToInstallJenkinsOnUbuntu22.04/finish-jenkins-setup-20230311150923530.png" alt="在 Ubuntu 上完成 Jenkins 配置。"></p><p><strong>注意：</strong>查看我们关于如何手动<a href="https://phoenixnap.com/kb/bash-for-loop">重新启动 Jenkins</a> 的指南 - 在解决问题时很有用的做法。</p><h2 id="6-镜像源手动安装"><a href="#6-镜像源手动安装" class="headerlink" title="6 镜像源手动安装"></a>6 镜像源手动安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.aliyun.com/jenkins/debian-stable/jenkins_2.387.1_all.deb<span class="token function">sudo</span> dpkg <span class="token parameter variable">-i</span> jenkins_2.387.1_all.deb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>插件镜像源</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">https://mirrors.aliyun.com/jenkins/updates/update-center.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结论</p><p>现在，您应该在 Ubuntu 22.04 系统上安装了 Jenkins。接下来，了解如何<a href="https://phoenixnap.com/kb/how-to-install-jenkins-kubernetes">在 Kubernetes 集群上设置 Jenkins</a>。如果您使用的是不同的 Linux 发行版，我们也有关于如何安装 Jenkins <a href="https://phoenixnap.com/kb/install-jenkins-on-debian-10">od Debian 10</a> 以及如何<a href="https://phoenixnap.com/kb/how-to-install-jenkins-on-centos-8">在 CentOS 上安装 Jenkins</a> 的指南。</p><h1 id="7-jar包直接启动"><a href="#7-jar包直接启动" class="headerlink" title="7 jar包直接启动"></a>7 jar包直接启动</h1><h1 id="8-maven安装"><a href="#8-maven安装" class="headerlink" title="8 maven安装"></a>8 maven安装</h1><h1 id="9-令牌环触发"><a href="#9-令牌环触发" class="headerlink" title="9 令牌环触发"></a>9 令牌环触发</h1><p>普通触发</p><p><a href="http://192.168.0.117:8080/job/ltp_test/build?token=123456">http://192.168.0.117:8080/job/ltp_test/build?token=123456</a></p><p>安装插件 Build Authorization Token Root Plugin,可以免登录</p><p><a href="http://192.168.0.117:8080/buildByToken/build?job=ltp_test&amp;token=123456">http://192.168.0.117:8080/buildByToken/build?job=ltp_test&amp;token=123456</a></p><p><a href="http://192.168.0.117:8080/buildByToken/build?job=DayDayUp&amp;token=123456">http://192.168.0.117:8080/buildByToken/build?job=DayDayUp&amp;token=123456</a></p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu开发环境搭建</title>
      <link href="/blog/a6657676.html"/>
      <url>/blog/a6657676.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-更换国内源"><a href="#1-更换国内源" class="headerlink" title="1 更换国内源"></a>1 更换国内源</h1><p>Ubuntu访问一些国外的网站，软件源等等，速度都会比国内的网站要慢。我们可以更新软件源，或镜像源达到加速的目的</p><ol><li>适用系统 Ubuntu22.4,如果是别的版本的Ubuntu，源可能不同，自行百度更换，方法相同</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jack@jack-HP:~$ <span class="token function">uname</span> <span class="token parameter variable">-a</span>Linux jack-HP <span class="token number">5.19</span>.0-35-generic <span class="token comment">#36~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb 17 15:17:25 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>备份原先的官方源</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jack@jack-HP:~$ <span class="token function">sudo</span> <span class="token function">cp</span> /etc/apt/sources.list /etc/apt/sources.list.backup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>Sources.list 填充以下内容,阿里云镜像源</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># deb cdrom:[Ubuntu 22.04.1 LTS _Jammy Jellyfish_ - Release amd64 (20220809.1)]/ jammy main restricted</span><span class="token comment"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><span class="token comment"># newer versions of the distribution.</span>deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted<span class="token comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ jammy main restricted</span><span class="token comment">## Major bug fix updates produced after the final release of the</span><span class="token comment">## distribution.</span>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted<span class="token comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ jammy-updates main restricted</span><span class="token comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><span class="token comment">## team. Also, please note that software in universe WILL NOT receive any</span><span class="token comment">## review or updates from the Ubuntu security team.</span>deb http://mirrors.aliyun.com/ubuntu/ jammy universe<span class="token comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ jammy universe</span>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates universe<span class="token comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ jammy-updates universe</span><span class="token comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><span class="token comment">## team, and may not be under a free licence. Please satisfy yourself as to</span><span class="token comment">## your rights to use the software. Also, please note that software in</span><span class="token comment">## multiverse WILL NOT receive any review or updates from the Ubuntu</span><span class="token comment">## security team.</span>deb http://mirrors.aliyun.com/ubuntu/ jammy multiverse<span class="token comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ jammy multiverse</span>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates multiverse<span class="token comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ jammy-updates multiverse</span><span class="token comment">## N.B. software from this repository may not have been tested as</span><span class="token comment">## extensively as that contained in the main release, although it includes</span><span class="token comment">## newer versions of some applications which may provide useful features.</span><span class="token comment">## Also, please note that software in backports WILL NOT receive any review</span><span class="token comment">## or updates from the Ubuntu security team.</span>deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<span class="token comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ jammy-backports main restricted universe multiverse</span>deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted<span class="token comment"># deb-src http://security.ubuntu.com/ubuntu jammy-security main restricted</span>deb http://mirrors.aliyun.com/ubuntu/ jammy-security universe<span class="token comment"># deb-src http://security.ubuntu.com/ubuntu jammy-security universe</span>deb http://mirrors.aliyun.com/ubuntu/ jammy-security multiverse<span class="token comment"># deb-src http://security.ubuntu.com/ubuntu jammy-security multiverse</span><span class="token comment"># This system was installed using small removable media</span><span class="token comment"># (e.g. netinst, live or single CD). The matching "deb cdrom"</span><span class="token comment"># entries were disabled at the end of the installation process.</span><span class="token comment"># For information about how to configure apt package sources,</span><span class="token comment"># see the sources.list(5) manual.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>更新源，耐心等待一会儿</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jack@jack-HP:~$ <span class="token function">sudo</span> <span class="token function">apt</span> updateHit:1 http://mirrors.aliyun.com/ubuntu jammy InReleaseHit:2 http://mirrors.aliyun.com/ubuntu jammy-updates InReleaseHit:3 http://mirrors.aliyun.com/ubuntu jammy-backports InReleaseHit:4 http://mirrors.aliyun.com/ubuntu jammy-security InReleaseReading package lists<span class="token punctuation">..</span>. DoneBuilding dependency tree<span class="token punctuation">..</span>. DoneReading state information<span class="token punctuation">..</span>. Done<span class="token number">297</span> packages can be upgraded. Run <span class="token string">'apt list --upgradable'</span> to see them.<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-编辑器"><a href="#2-编辑器" class="headerlink" title="2 编辑器"></a>2 编辑器</h1><h2 id="2-1-安装vim"><a href="#2-1-安装vim" class="headerlink" title="2.1 安装vim"></a>2.1 安装vim</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">vim</span> <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-2-参考配置-vimrc"><a href="#2-2-参考配置-vimrc" class="headerlink" title="2.2 参考配置 . vimrc"></a>2.2 参考配置 . vimrc</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">"关闭vi兼容模式"</span><span class="token builtin class-name">set</span> nocompatible<span class="token string">"设置历史记录步数"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">history</span><span class="token operator">=</span><span class="token number">1000</span><span class="token string">"开启相关插件"</span><span class="token string">"侦测文件类型"</span>filetype on<span class="token string">"载入文件类型插件"</span>filetype plugin on<span class="token string">"为特定文件类型载入相关缩进文件"</span>filetype indent on<span class="token string">"当文件在外部被修改时，自动更新该文件"</span><span class="token builtin class-name">set</span> autoread<span class="token string">"激活鼠标的使用"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">mouse</span><span class="token operator">=</span>a<span class="token builtin class-name">set</span> <span class="token assign-left variable">selection</span><span class="token operator">=</span>exclusive<span class="token builtin class-name">set</span> <span class="token assign-left variable">selectmode</span><span class="token operator">=</span>mouse,key<span class="token string">"保存全局变量"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">viminfo</span><span class="token operator">+=</span><span class="token operator">!</span><span class="token string">"带有如下符号的单词不要被换行分割"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">iskeyword</span><span class="token operator">+=</span>_,$,@,%,<span class="token comment">#,-</span><span class="token string">"通过使用: commands命令，告诉我们文件的哪一行被改变过"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">report</span><span class="token operator">=</span><span class="token number">0</span><span class="token string">"被分割的窗口间显示空白，便于阅读"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">fillchars</span><span class="token operator">=</span>vert:<span class="token punctuation">\</span> ,stl:<span class="token punctuation">\</span> ,stlnc:<span class="token punctuation">\</span><span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token operator">=</span><span class="token operator">&gt;</span>字体和颜色<span class="token operator">&lt;=</span><span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">"自动开启语法高亮"</span>syntax <span class="token builtin class-name">enable</span><span class="token string">"设置字体"</span><span class="token string">"set guifont=dejaVu\ Sans\ MONO\ 10set guifont=Courier_New:h10:cANSI"</span>设置颜色<span class="token string">""</span>colorscheme desert<span class="token string">"高亮显示当前行"</span><span class="token builtin class-name">set</span> cursorlinehi cursorline <span class="token assign-left variable">guibg</span><span class="token operator">=</span><span class="token comment">#00ff00</span>hi CursorColumn <span class="token assign-left variable">guibg</span><span class="token operator">=</span><span class="token comment">#00ff00</span><span class="token string">"高亮显示普通txt文件（需要txt.vim脚本）"</span>au BufRead,BufNewFile *  setfiletype txt<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">"=&gt;代码折叠功能&lt;="</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span><span class="token string">"激活折叠功能"</span><span class="token builtin class-name">set</span> foldenable<span class="token string">"set nofen（这个是关闭折叠功能）"</span><span class="token string">"设置按照语法方式折叠（可简写set fdm=XX）"</span><span class="token string">"有6种折叠方法："</span>manual   手工定义折叠<span class="token string">""</span>indent   更多的缩进表示更高级别的折叠<span class="token string">""</span><span class="token function">expr</span>     用表达式来定义折叠<span class="token string">""</span>syntax   用语法高亮来定义折叠<span class="token string">""</span><span class="token function">diff</span>     对没有更改的文本进行折叠<span class="token string">""</span>marker   对文中的标志进行折叠<span class="token string">"set foldmethod=manual"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">fdl</span><span class="token operator">=</span><span class="token number">0</span>（这个是不选用任何折叠方法）<span class="token string">""</span>设置折叠区域的宽度<span class="token string">""</span>如果不为0，则在屏幕左侧显示一个折叠标识列<span class="token string">"分别用“-”和“+”来表示打开和关闭的折叠set foldcolumn=0"</span>设置折叠层数为3<span class="token string">"setlocal foldlevel=3"</span>设置为自动关闭折叠<span class="token string">"set foldclose=all"</span>用空格键来代替zo和zc快捷键实现开关折叠<span class="token string">""</span>zo O-pen a <span class="token function">fold</span> <span class="token punctuation">(</span>打开折叠<span class="token punctuation">)</span><span class="token string">"zc C-lose a fold (关闭折叠)"</span>zf F-old creation <span class="token punctuation">(</span>创建折叠<span class="token punctuation">)</span><span class="token string">"nnoremap &lt;space&gt; @=<span class="token variable"><span class="token punctuation">((</span>foldclosed<span class="token punctuation">(</span>line<span class="token punctuation">(</span>'.'<span class="token punctuation">))</span></span> &lt; 0) ? 'zc' : 'zo')&lt;CR&gt;"</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token operator">=</span><span class="token operator">&gt;</span>文字处理<span class="token operator">&lt;=</span><span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span><span class="token string">"使用空格来替换Tab"</span><span class="token builtin class-name">set</span> expandtab<span class="token string">"设置所有的Tab和缩进为4个空格"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">tabstop</span><span class="token operator">=</span><span class="token number">4</span><span class="token string">"设定&lt;&lt;和&gt;&gt;命令移动时的宽度为4"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">shiftwidth</span><span class="token operator">=</span><span class="token number">4</span><span class="token string">"使得按退格键时可以一次删除4个空格"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">softtabstop</span><span class="token operator">=</span><span class="token number">4</span><span class="token builtin class-name">set</span> smarttab<span class="token string">"缩进，自动缩进（继承前一行的缩进）"</span><span class="token string">"set autoindent 命令打开自动缩进，是下面配置的缩写"</span>可使用autoindent命令的简写，即“:set ai”和“:set noai”<span class="token string">"还可以使用“:set ai sw=4”在一个命令中打开缩进并设置缩进级别set aiset cindent"</span>智能缩进<span class="token string">"set si"</span>自动换行”<span class="token builtin class-name">set</span> wrap<span class="token string">"设置软宽度"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">sw</span><span class="token operator">=</span><span class="token number">4</span><span class="token string">"行内替换"</span><span class="token builtin class-name">set</span> gdefault<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">"=&gt;Vim 界面&lt;="</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span><span class="token string">"增强模式中的命令行自动完成操作"</span><span class="token builtin class-name">set</span> wildmenu<span class="token string">"显示标尺"</span><span class="token builtin class-name">set</span> ruler<span class="token string">"设置命令行的高度"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">cmdheight</span><span class="token operator">=</span><span class="token number">1</span><span class="token string">"显示行数"</span><span class="token builtin class-name">set</span> nu<span class="token string">"不要图形按钮"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">go</span><span class="token operator">=</span><span class="token string">"在执行宏命令时，不进行显示重绘；在宏命令执行完成后，一次性重绘，以便提高性能"</span><span class="token builtin class-name">set</span> lz<span class="token string">"使回格键（backspace）正常处理indent, eol, start等"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">backspace</span><span class="token operator">=</span>eol,start,indent<span class="token string">"允许空格键和光标键跨越行边界"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">whichwrap</span><span class="token operator">+=</span><span class="token operator">&lt;</span>,<span class="token operator">&gt;</span>,h,l<span class="token string">"设置魔术"</span><span class="token builtin class-name">set</span> magic<span class="token string">"关闭遇到错误时的声音提示"</span><span class="token string">"关闭错误信息响铃"</span><span class="token builtin class-name">set</span> noerrorbells<span class="token string">"关闭使用可视响铃代替呼叫"</span><span class="token builtin class-name">set</span> novisualbell<span class="token string">"高亮显示匹配的括号([{和}])"</span><span class="token builtin class-name">set</span> showmatch<span class="token string">"匹配括号高亮的时间（单位是十分之一秒）"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">mat</span><span class="token operator">=</span><span class="token number">2</span><span class="token string">"光标移动到buffer的顶部和底部时保持3行距离"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">scrolloff</span><span class="token operator">=</span><span class="token number">3</span><span class="token string">"搜索逐字符高亮"</span><span class="token builtin class-name">set</span> hlsearch<span class="token builtin class-name">set</span> incsearch<span class="token string">"搜索时不区分大小写"</span><span class="token string">"还可以使用简写（“:set ic”和“:set noic”）"</span><span class="token builtin class-name">set</span> ignorecase<span class="token string">"用浅色高亮显示当前行"</span>autocmd InsertLeave * se noculautocmd InsertEnter * se cul<span class="token string">"输入的命令显示出来，看的清楚"</span><span class="token builtin class-name">set</span> showcmd<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token operator">=</span><span class="token operator">&gt;</span>编码设置<span class="token operator">&lt;=</span><span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">"设置编码"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">encoding</span><span class="token operator">=</span>utf-8<span class="token builtin class-name">set</span> <span class="token assign-left variable">fencs</span><span class="token operator">=</span>utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936<span class="token string">"设置文件编码"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">fileencodings</span><span class="token operator">=</span>utf-8<span class="token string">"设置终端编码"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">termencoding</span><span class="token operator">=</span>utf-8<span class="token string">"设置语言编码"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">langmenu</span><span class="token operator">=</span>zh_CN.UTF-8<span class="token builtin class-name">set</span> <span class="token assign-left variable">helplang</span><span class="token operator">=</span>cn<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span><span class="token string">""</span>"<span class="token operator">=</span><span class="token operator">&gt;</span>其他设置<span class="token operator">&lt;=</span><span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span><span class="token string">"开启新行时使用智能自动缩进"</span><span class="token builtin class-name">set</span> smartindent<span class="token builtin class-name">set</span> cin<span class="token builtin class-name">set</span> showmatch<span class="token string">"在处理未保存或只读文件的时候，弹出确认"</span><span class="token builtin class-name">set</span> confirm<span class="token string">"隐藏工具栏"</span><span class="token builtin class-name">set</span> guioptions-<span class="token operator">=</span>T<span class="token string">"隐藏菜单栏"</span><span class="token builtin class-name">set</span> guioptions-<span class="token operator">=</span>m<span class="token string">"置空错误铃声的终端代码"</span><span class="token builtin class-name">set</span> vb <span class="token assign-left variable">t_vb</span><span class="token operator">=</span><span class="token string">"显示状态栏（默认值为1，表示无法显示状态栏）"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">laststatus</span><span class="token operator">=</span><span class="token number">2</span><span class="token string">"状态行显示的内容"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">statusline</span><span class="token operator">=</span>%F%m%r%h%w<span class="token punctuation">\</span> <span class="token punctuation">[</span>FORMAT<span class="token operator">=</span>%<span class="token punctuation">{</span><span class="token operator">&amp;</span>ff<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">\</span> <span class="token punctuation">[</span>TYPE<span class="token operator">=</span>%Y<span class="token punctuation">]</span><span class="token punctuation">\</span> <span class="token punctuation">[</span>POS<span class="token operator">=</span>%l,%v<span class="token punctuation">]</span><span class="token punctuation">[</span>%p%%<span class="token punctuation">]</span><span class="token punctuation">\</span> %<span class="token punctuation">{</span>strftime<span class="token punctuation">(</span><span class="token punctuation">\</span>"%d/%m/%y<span class="token punctuation">\</span> -<span class="token punctuation">\</span> %H:%M<span class="token punctuation">\</span>"<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token string">"粘贴不换行问题的解决方法"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">pastetoggle</span><span class="token operator">=</span><span class="token operator">&lt;</span>F<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span><span class="token string">"设置背景颜色"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">background</span><span class="token operator">=</span>dark<span class="token string">"文件类型自动检测，代码智能补全"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">completeopt</span><span class="token operator">=</span>longest,preview,menu<span class="token string">"共享剪切板"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">clipboard</span><span class="token operator">+=</span>unnamed<span class="token string">"从不备份"</span><span class="token builtin class-name">set</span> nobackup<span class="token builtin class-name">set</span> noswapfile<span class="token string">"自动保存"</span><span class="token builtin class-name">set</span> autowrite<span class="token string">"显示中文帮助"</span><span class="token keyword">if</span> version <span class="token operator">&gt;=</span> <span class="token number">603</span>        <span class="token builtin class-name">set</span> <span class="token assign-left variable">helplang</span><span class="token operator">=</span>cn            <span class="token builtin class-name">set</span> <span class="token assign-left variable">encoding</span><span class="token operator">=</span>utf-8endif<span class="token string">"设置高亮相关项"</span>highlight Search <span class="token assign-left variable">ctermbg</span><span class="token operator">=</span>black <span class="token assign-left variable">ctermfg</span><span class="token operator">=</span>white <span class="token assign-left variable">guifg</span><span class="token operator">=</span>white <span class="token assign-left variable">guibg</span><span class="token operator">=</span>black<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span><span class="token string">""</span>"<span class="token operator">=</span><span class="token operator">&gt;</span>在shell脚本开头自动增加解释器以及作者等版权信息<span class="token operator">&lt;=</span><span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span><span class="token string">"新建.py,.cc,.sh,.java文件，自动插入文件头"</span>autocmd BufNewFile *.py,*.cc,*.sh,*.java <span class="token builtin class-name">exec</span> <span class="token string">":call SetTitle()"</span><span class="token string">"定义函数SetTitle，自动插入文件头"</span>func SetTitle<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token function">expand</span> <span class="token punctuation">(</span><span class="token string">"%:e"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'sh'</span>        call setline<span class="token punctuation">(</span><span class="token number">1</span>, <span class="token string">"#!/bin/bash"</span><span class="token punctuation">)</span>        call setline<span class="token punctuation">(</span><span class="token number">2</span>, <span class="token string">"#Author:bert"</span><span class="token punctuation">)</span>        call setline<span class="token punctuation">(</span><span class="token number">3</span>, <span class="token string">"#Blog:http://blog.51cto.com/zpf666"</span><span class="token punctuation">)</span>        call setline<span class="token punctuation">(</span><span class="token number">4</span>, <span class="token string">"#Time:"</span>.strftime<span class="token punctuation">(</span><span class="token string">"%F %T"</span><span class="token punctuation">))</span>        call setline<span class="token punctuation">(</span><span class="token number">5</span>, <span class="token string">"#Name:"</span>.expand<span class="token punctuation">(</span><span class="token string">"%"</span><span class="token punctuation">))</span>        call setline<span class="token punctuation">(</span><span class="token number">6</span>, <span class="token string">"#Version:V1.0"</span><span class="token punctuation">)</span>        call setline<span class="token punctuation">(</span><span class="token number">7</span>, <span class="token string">"#Description:This is a production script."</span><span class="token punctuation">)</span>    endifendfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-版本管理"><a href="#3-版本管理" class="headerlink" title="3 版本管理"></a>3 版本管理</h1><h2 id="3-1-安装git"><a href="#3-1-安装git" class="headerlink" title="3.1 安装git"></a>3.1 安装git</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span> <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-2-配置git"><a href="#3-2-配置git" class="headerlink" title="3.2 配置git"></a>3.2 配置git</h2><p>1 配置用户名密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"xxx"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"xxx.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过以下命令查看配置清单</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--list</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2 创建ssh秘钥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"xxx.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一路回车，直至结束</p><p>3 公钥上传至个人github gitee账号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://github.com/settings/keys">github: 头像 –&gt; Settings –&gt; SSH and GPG keys –&gt; New SSH key</a></p><p><a href="https://gitee.com/profile/sshkeys">gitee: 头像 –&gt; 账号设置 –&gt; ssh公钥 –&gt; 添加公钥</a></p><p>这样clone 或者github/gitee网站的代码时就不用输入用户名密码了。</p><h1 id="4-编译"><a href="#4-编译" class="headerlink" title="4 编译"></a>4 编译</h1><h2 id="4-1-安装gcc-x2F-gdb"><a href="#4-1-安装gcc-x2F-gdb" class="headerlink" title="4.1 安装gcc/gdb"></a>4.1 安装gcc/gdb</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gcc gdb <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-2-安装交叉编译器"><a href="#4-2-安装交叉编译器" class="headerlink" title="4.2 安装交叉编译器"></a>4.2 安装交叉编译器</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> g++-aarch64-linux-gnu <span class="token parameter variable">-y</span>aarch64-linux-gnu-gcc <span class="token parameter variable">-v</span>  <span class="token comment">#查看默认安装的gcc版本</span>aarch64-linux-gnu-g++ <span class="token parameter variable">-v</span>  <span class="token comment">#查看默认安装的g++版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-3-编译工具"><a href="#4-3-编译工具" class="headerlink" title="4.3 编译工具"></a>4.3 编译工具</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">make</span> cmake cmake-gui <span class="token parameter variable">-y</span> <span class="token comment">#安装 cmake-gui 有些需要选择性编译的库使用较方便</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="5-远程开发"><a href="#5-远程开发" class="headerlink" title="5 远程开发"></a>5 远程开发</h1><p>远程机：Ubuntu22.04</p><p>本地：windows/macOS</p><h2 id="5-1-安装ssh"><a href="#5-1-安装ssh" class="headerlink" title="5.1 安装ssh"></a>5.1 安装ssh</h2><ol><li>安装net-tools，查看Ubuntu的ip地址</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> net-tools <span class="token parameter variable">-y</span><span class="token function">ifconfig</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>安装ssh</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openssh-server <span class="token parameter variable">-y</span><span class="token function">sudo</span> /etc/init.d/ssh start<span class="token function">ps</span> <span class="token parameter variable">-e</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">ssh</span>  <span class="token comment"># 7497 ?        00:00:00 sshd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>本地连接</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token parameter variable">-p</span> <span class="token punctuation">[</span>port<span class="token punctuation">]</span> <span class="token punctuation">[</span>user name<span class="token punctuation">]</span>@<span class="token punctuation">[</span>remote ip<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>⭐⭐⭐ port端口一般是默认是22，可不用-p指定。如果是其它端口，需要使用-p指定</p><h2 id="5-2-配置本地免密登陆"><a href="#5-2-配置本地免密登陆" class="headerlink" title="5.2 配置本地免密登陆"></a>5.2 配置本地免密登陆</h2><p>1 获取==本地windows/macOS公钥==id_rsa.pub，并复制其中的内容</p><p>2 新建文件authorized_keys,并将刚才复制的公钥粘贴到Ubuntu。wq保存退出</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样下次在本地ssh连接Ubuntu时就不需要每次都输入密码了</p><h1 id="6-python"><a href="#6-python" class="headerlink" title="6 python"></a>6 python</h1><h2 id="6-1-安装python2-7"><a href="#6-1-安装python2-7" class="headerlink" title="6.1 安装python2.7"></a>6.1 安装python2.7</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> python2.7 <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jack@jack-HP:~$ python2.7 <span class="token parameter variable">-V</span>Python <span class="token number">2.7</span>.18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-2-安装python3"><a href="#6-2-安装python3" class="headerlink" title="6.2 安装python3"></a>6.2 安装python3</h2><p>推荐使用python3</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> python3 <span class="token parameter variable">-y</span> <span class="token comment"># 默认python3版本</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> python3.11 <span class="token parameter variable">-y</span> <span class="token comment"># 指定python3版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jack@jack-HP:~$ python3 <span class="token parameter variable">-V</span>Python <span class="token number">3.10</span>.6 <span class="token comment"># 默认python3版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-3-设置python3为默认"><a href="#6-3-设置python3为默认" class="headerlink" title="6.3 设置python3为默认"></a>6.3 设置python3为默认</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jack@jack-HP:~$ <span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/bin/python3 /usr/bin/pythonjack@jack-HP:~$ <span class="token function">which</span> python/usr/bin/pythonjack@jack-HP:~$ python <span class="token parameter variable">-V</span>Python <span class="token number">3.10</span>.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样在终端中输入python，python解释器默认就是python3了。<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="6-4-安装pip3"><a href="#6-4-安装pip3" class="headerlink" title="6.4 安装pip3"></a>6.4 安装pip3</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> build-essential libssl-dev libevent-dev libjpeg-dev libxml2-dev libxslt-dev <span class="token comment"># 安装build依赖包 </span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> python3-pip <span class="token parameter variable">-y</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> python3-tk <span class="token parameter variable">-y</span> <span class="token comment"># use for import</span>jack@jack-HP:~$ pip <span class="token parameter variable">-V</span>pip <span class="token number">22.0</span>.2 from /usr/lib/python3/dist-packages/pip <span class="token punctuation">(</span>python <span class="token number">3.10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5-Pip3安装python库"><a href="#6-5-Pip3安装python库" class="headerlink" title="6.5 Pip3安装python库"></a>6.5 Pip3安装python库</h2><ol><li>一般安装，这种方式访问国外源，安装会非常慢，还有可能安装失败</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> Pandas<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>安装时手动指定镜像源</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> Pandas <span class="token parameter variable">-i</span> http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>配置默认源</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ~/.pip<span class="token function">sudo</span> <span class="token function">vim</span> ~/.pip/pip.conf<span class="token comment"># add</span><span class="token punctuation">[</span>global<span class="token punctuation">]</span>index-url <span class="token operator">=</span> https://mirrors.aliyun.com/pypi/simple/<span class="token punctuation">[</span>install<span class="token punctuation">]</span>trusted-host<span class="token operator">=</span>mirrors.aliyun.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科技大学 ：<a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>华中科技大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a><br>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p></blockquote><blockquote><p>WARNING: The script tldextract is installed in ‘/home/jack/.local/bin’ which is not on PATH.</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'export PATH=/home/jack/.local/bin:$PATH'</span> <span class="token operator">&gt;&gt;</span>~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="7-下载工具"><a href="#7-下载工具" class="headerlink" title="7 下载工具"></a>7 下载工具</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">curl</span> <span class="token function">wget</span> <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="8-expect工具"><a href="#8-expect工具" class="headerlink" title="8 expect工具"></a>8 expect工具</h1><p>expect是一个自动化交互套件，主要应用于执行命令和程序时，系统以交互形式要求输入指定字符串，实现交互通信。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">expect</span> <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="9-Linux内核qemu"><a href="#9-Linux内核qemu" class="headerlink" title="9 Linux内核qemu"></a>9 Linux内核qemu</h1><ol><li>命令行安装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qemu-system <span class="token parameter variable">-y</span> <span class="token comment"># 安装</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> qemu-system-arm <span class="token comment"># 只安装arm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>手动安装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ninja-build<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> pkg-config<span class="token function">wget</span> https://download.qemu.org/qemu-7.2.0.tar.xz<span class="token function">tar</span> xvJf qemu-7.2.0.tar.xz<span class="token builtin class-name">cd</span> qemu-7.2.0./configure<span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="10-man-CN"><a href="#10-man-CN" class="headerlink" title="10 man-CN"></a>10 man-CN</h1><p>中文手册</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> manpages-zh <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>.bashrc设置重命名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">cman</span><span class="token operator">=</span><span class="token string">'man -M /usr/share/man/zh_CN'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cman <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS开发环境搭建</title>
      <link href="/blog/cb5ce835.html"/>
      <url>/blog/cb5ce835.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Command-Line-Tools"><a href="#1-Command-Line-Tools" class="headerlink" title="1 Command Line Tools"></a>1 Command Line Tools</h1><p>使用 Terminal 运行如下代码安装，默认安装（Command Line Tools）最新版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xcode-select <span class="token parameter variable">--install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者直接在App Store当中安装Xcode</p><h1 id="2-Git"><a href="#2-Git" class="headerlink" title="2 Git"></a>2 Git</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> <span class="token function">git</span><span class="token operator">==</span><span class="token operator">&gt;</span> Downloading https://mirrors.ustc.edu.cn/homebrew-bottles/bottles/gettext-0.21.monterey.bottle.tar.gz<span class="token comment">######################################################################## 100.0%</span><span class="token operator">==</span><span class="token operator">&gt;</span> Downloading https://mirrors.ustc.edu.cn/homebrew-bottles/bottles/pcre2-10.39.monterey.bottle.tar.gz<span class="token comment">######################################################################## 100.0%</span><span class="token operator">==</span><span class="token operator">&gt;</span> Downloading https://mirrors.ustc.edu.cn/homebrew-bottles/bottles/git-2.35.1.monterey.bottle.tar.gz<span class="token comment">######################################################################## 100.0%</span><span class="token operator">==</span><span class="token operator">&gt;</span> Installing dependencies <span class="token keyword">for</span> git: gettext and pcre2<span class="token operator">==</span><span class="token operator">&gt;</span> Installing <span class="token function">git</span> dependency: gettext<span class="token operator">==</span><span class="token operator">&gt;</span> Pouring gettext-0.21.monterey.bottle.tar.gz🍺  /usr/local/Cellar/gettext/0.21: <span class="token number">1,953</span> files, <span class="token number">20</span>.2MB<span class="token operator">==</span><span class="token operator">&gt;</span> Installing <span class="token function">git</span> dependency: pcre2<span class="token operator">==</span><span class="token operator">&gt;</span> Pouring pcre2-10.39.monterey.bottle.tar.gz🍺  /usr/local/Cellar/pcre2/10.39: <span class="token number">230</span> files, <span class="token number">6</span>.2MB<span class="token operator">==</span><span class="token operator">&gt;</span> Installing <span class="token function">git</span><span class="token operator">==</span><span class="token operator">&gt;</span> Pouring git-2.35.1.monterey.bottle.tar.gz<span class="token operator">==</span><span class="token operator">&gt;</span> CaveatsThe Tcl/Tk GUIs <span class="token punctuation">(</span>e.g. gitk, git-gui<span class="token punctuation">)</span> are now <span class="token keyword">in</span> the <span class="token variable"><span class="token variable">`</span>git-gui<span class="token variable">`</span></span> formula.Subversion interoperability <span class="token punctuation">(</span>git-svn<span class="token punctuation">)</span> is now <span class="token keyword">in</span> the <span class="token variable"><span class="token variable">`</span>git-svn<span class="token variable">`</span></span> formula.<span class="token function">zsh</span> completions and functions have been installed to:  /usr/local/share/zsh/site-functionsEmacs Lisp files have been installed to:  /usr/local/share/emacs/site-lisp/git<span class="token operator">==</span><span class="token operator">&gt;</span> Summary🍺  /usr/local/Cellar/git/2.35.1: <span class="token number">1,523</span> files, 43MB<span class="token operator">==</span><span class="token operator">&gt;</span> Running <span class="token variable"><span class="token variable">`</span>brew cleanup <span class="token function">git</span><span class="token variable">`</span></span><span class="token punctuation">..</span>.Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.Hide these hints with HOMEBREW_NO_ENV_HINTS <span class="token punctuation">(</span>see <span class="token variable"><span class="token variable">`</span><span class="token function">man</span> brew<span class="token variable">`</span></span><span class="token punctuation">)</span>.<span class="token operator">==</span><span class="token operator">&gt;</span> Caveats<span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token function">git</span>The Tcl/Tk GUIs <span class="token punctuation">(</span>e.g. gitk, git-gui<span class="token punctuation">)</span> are now <span class="token keyword">in</span> the <span class="token variable"><span class="token variable">`</span>git-gui<span class="token variable">`</span></span> formula.Subversion interoperability <span class="token punctuation">(</span>git-svn<span class="token punctuation">)</span> is now <span class="token keyword">in</span> the <span class="token variable"><span class="token variable">`</span>git-svn<span class="token variable">`</span></span> formula.<span class="token function">zsh</span> completions and functions have been installed to:  /usr/local/share/zsh/site-functionsEmacs Lisp files have been installed to:  /usr/local/share/emacs/site-lisp/git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h2><p>通过下面这些指令，配置用户名和邮箱</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"xxx"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>名字和邮箱需要用双引号包裹，回车之后，如路径没有任何变化说明设置成功；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"xxx.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处的邮箱账号可以是假的账号，但是格式必须复合邮箱格式，同样回车成功之后路径不会有变化；<br>配置本地仓库文件大小写敏感，建议配置，以免文件更新有误；</p><p>通过以下命令查看配置清单</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--list</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>创建 SSH密钥</strong><br>首先在termital终端输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"xxx"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(注：username为你git上的用户名,一般是你的邮箱地址)<br>然后，打开相对应的id_rsa.pub文件,将其中的内容全部copy到github/gitee上做添加配置.</p><p>在当前项目中，早先创建并已经push到远程的文件及文件夹，将名称大小写更改后，git无法检测出更改。<br>出现这种情况的原因是，git默认配置为忽略大小写，因此无法正确检测大小写的更改。<br>那么，解决办法是，在当前项目中，运行 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config core.ignorecase <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭git忽略大小写配置，即可检测到大小写名称更改。</p><h1 id="3-on-my-zsh"><a href="#3-on-my-zsh" class="headerlink" title="3 on-my-zsh"></a>3 on-my-zsh</h1><p><a href="https://ohmyz.sh/">官网</a></p><h2 id="3-1-命令行安装"><a href="#3-1-命令行安装" class="headerlink" title="3.1 命令行安装"></a>3.1 命令行安装</h2><p>确保本机已安装zsh</p><p>Ubuntu</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">zsh</span> <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>macOS</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> <span class="token function">zsh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Oh My Zsh 是通过在您的终端中运行以下命令之一来安装的。您可以通过命令行使用 ，或其他类似工具安装它。<code>curl</code> <code>wget</code></p><table><thead><tr><th>方法</th><th>命令</th></tr></thead><tbody><tr><td><strong>curl</strong></td><td><code>sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></td></tr><tr><td><strong>wget</strong></td><td><code>sh -c "$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></td></tr><tr><td><strong>fetch</strong></td><td><code>sh -c "$(fetch -o - https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></td></tr></tbody></table><p><em>请注意，任何以前的 <code>.zshrc</code> 都将重命名为 .<code>zshrc.pre-oh-my-zsh</code>。安装后，您可以将要保留的配置移动到新的 <code>.zshrc</code> 中。</em></p><p>国内安装</p><p><code>sh -c "$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)"</code></p><h2 id="3-2-手动安装"><a href="#3-2-手动安装" class="headerlink" title="3.2 手动安装"></a>3.2 手动安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh<span class="token function">sh</span> install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/ohmyzsh/ohmyzsh.git # githubgit clone https://gitee.com/mirrors/oh-my-zsh.git # giteecd oh-my-zsh/tools./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-插件安装"><a href="#3-3-插件安装" class="headerlink" title="3.3 插件安装"></a>3.3 插件安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><span class="token function">git</span> clone https://gitee.com/async_github/zsh-autosuggestions.git <span class="token variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions<span class="token comment"># git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><span class="token function">git</span> clone https://gitee.com/dawnwords/zsh-syntax-highlighting.git <span class="token variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>添加插件到配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.zshrc<span class="token assign-left variable">plugins</span><span class="token operator">=</span><span class="token punctuation">(</span>git zsh-syntax-highlighting zsh-autosuggestions<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重新启动终端，或者source配置文件，使得插件生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-4-更换主题powerlevel10k"><a href="#3-4-更换主题powerlevel10k" class="headerlink" title="3.4 更换主题powerlevel10k"></a>3.4 更换主题powerlevel10k</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Users in China can use the official mirror on gitee.com for faster download.</span><span class="token comment"># 中国用户可以使用 gitee.com 上的官方镜像加速下载.</span><span class="token function">git</span> clone <span class="token parameter variable">--depth</span><span class="token operator">=</span><span class="token number">1</span> https://gitee.com/romkatv/powerlevel10k.git <span class="token variable">${ZSH_CUSTOM<span class="token operator">:-</span>$HOME<span class="token operator">/</span>.oh-my-zsh<span class="token operator">/</span>custom}</span>/themes/powerlevel10k<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置zsh主题为powerlevel10k</p><p><code>Set ZSH_THEME="powerlevel10k/powerlevel10k" in ~/.zshrc.</code></p><p>安装，只有按照提示和自己的喜好一路安装下去了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">p10k configure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意：如果字体安装失败，可以通过下面链接手动安装。终端或者iterm2的字体设置为下面任意一种即可</p><ul><li>[MesloLGS NF Regular.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Regular.ttf)</li><li>[MesloLGS NF Bold.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold.ttf)</li><li>[MesloLGS NF Italic.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Italic.ttf)</li><li>[MesloLGS NF Bold Italic.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold Italic.ttf)</li></ul></blockquote><p><img src="/../../images/macOS/image-20230311235634062.png" alt="image-20230311235634062"></p><p>更换终端或iterm2的字体为MesloLGS NF</p><h2 id="3-5-更换Spaceship主题"><a href="#3-5-更换Spaceship主题" class="headerlink" title="3.5 更换Spaceship主题"></a>3.5 更换Spaceship主题</h2><p><a href="https://github.com/denysdovhan/spaceship-prompt">Spaceship Github</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. Clone仓库:</span><span class="token function">git</span> clone https://github.com/denysdovhan/spaceship-prompt.git <span class="token string">"<span class="token variable">$ZSH_CUSTOM</span>/themes/spaceship-prompt"</span><span class="token comment"># 2. 链接spaceship.zsh-theme到oh-my-zsh自定义主题目录:</span><span class="token function">ln</span> <span class="token parameter variable">-s</span> <span class="token string">"<span class="token variable">$ZSH_CUSTOM</span>/themes/spaceship-prompt/spaceship.zsh-theme"</span> <span class="token string">"<span class="token variable">$ZSH_CUSTOM</span>/themes/spaceship.zsh-theme"</span><span class="token comment"># 在.zshrc设置ZSH_THEME="spaceship"</span><span class="token function">vim</span> ~/.zshrc<span class="token comment"># 使新主题在终端中生效</span><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-6-自定义设置"><a href="#3-6-自定义设置" class="headerlink" title="3.6 自定义设置"></a>3.6 自定义设置</h2><p>更换背景图</p><p>具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Window，在Background Image里勾选<code>Enbale</code>，Mode可以选择<code>Scale to Fill</code></p><p>添加系统状态栏</p><p>具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Session，在窗口最下面勾选<code>Status bar enabled</code>，然后通过Configure自己拖选喜欢的插件。<code>Auto-rainbow</code>可以设置为Automatic。</p><h2 id="3-7-lsd显示文件小图标"><a href="#3-7-lsd显示文件小图标" class="headerlink" title="3.7 lsd显示文件小图标"></a>3.7 lsd显示文件小图标</h2><p>macOS安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> lsd or <span class="token function">sudo</span> port <span class="token function">install</span> lsd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Ubuntu</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg <span class="token parameter variable">-i</span> lsd_0.23.1_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://github.com/Peltoche/lsd/releases">release page</a>获取lsd_0.23.1_amd64.deb</p><p>简单配置.zshrc</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">ls</span><span class="token operator">=</span><span class="token string">'lsd'</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">l</span><span class="token operator">=</span><span class="token string">'ls -l'</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">ll</span><span class="token operator">=</span><span class="token string">'ls -l'</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">la</span><span class="token operator">=</span><span class="token string">'ls -a'</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">lla</span><span class="token operator">=</span><span class="token string">'ls -la'</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">lt</span><span class="token operator">=</span><span class="token string">'ls --tree'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../../images/macOS/image-20230313205815380.png" alt="image-20230313205815380"></p><h1 id="4-iterm2"><a href="#4-iterm2" class="headerlink" title="4 iterm2"></a>4 iterm2</h1><p>官网安装</p><p><a href="http://iterm2.com/">http://iterm2.com/</a></p><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> iterm2 <span class="token parameter variable">--casks</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主题</p><p><a href="https://gitee.com/walter_bishop/iTerm2-Color-Schemes">https://gitee.com/walter_bishop/iTerm2-Color-Schemes</a></p><p>快捷键</p><blockquote><p>command + enter 进入与返回全屏模式<br>command + t 新建标签<br>command + w 关闭标签<br>command + 数字 command + 左右方向键    切换标签<br>command + enter 切换全屏<br>command + f 查找<br>command + d 水平分屏<br>command + shift + d 垂直分屏<br>command + option + 方向键 command + [ 或 command + ]    切换屏幕<br>command + ; 查看历史命令<br>command + shift + h 查看剪贴板历史<br>ctrl + u    清除当前行<br>ctrl + l    清屏<br>ctrl + a    到行首<br>ctrl + e    到行尾<br>ctrl + f/b  前进后退<br>ctrl + p    上一条命令<br>ctrl + r    搜索命令历史</p></blockquote><p><img src="/../../images/macOS/image-20230312222114880.png" alt="image-20230312222114880"></p><h1 id="5-HomeBrew"><a href="#5-HomeBrew" class="headerlink" title="5 HomeBrew"></a>5 HomeBrew</h1><p>Homebrew是一款自由及开放源代码的软件包管理系统，用以简化macOS系统上的软件安装过程，最初由马克斯·霍威尔（Max Howell）写成。因其可扩展性得到了一致好评，而在Ruby on Rails社区广为人知。</p><h2 id="5-1-安装HomeBrew"><a href="#5-1-安装HomeBrew" class="headerlink" title="5.1 安装HomeBrew"></a>5.1 安装HomeBrew</h2><blockquote><p><a href="https://gitee.com/link?target=https://zhuanlan.zhihu.com/p/111014448">知乎文章地址：https://zhuanlan.zhihu.com/p/111014448</a><br>苹果电脑标准安装脚本：（推荐 优点全面 缺点慢一点）<br>/bin/zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh">https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh</a>)” </p><p>苹果电脑极速安装脚本：（优点安装速度快 缺点update功能需要命令修复 ）<br>/bin/zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh">https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh</a>)” speed </p><p>Linux 标准安装脚本：<br>rm Homebrew.sh ; wget <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh">https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh</a> ; bash Homebrew.sh </p><p>苹果电脑卸载脚本：<br>/bin/zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh">https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh</a>)” </p><p>Linux卸载脚本：<br>rm HomebrewUninstall.sh ; wget <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh">https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh</a> ; bash HomebrewUninstall.sh </p></blockquote><p><a href="https://brew.sh/index_zh-cn">官网安装</a><br>或者一句安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/bin/zsh <span class="token parameter variable">-c</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh<span class="token variable">)</span></span>"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-2-换源（中科大源）"><a href="#5-2-换源（中科大源）" class="headerlink" title="5.2 换源（中科大源）"></a>5.2 换源（中科大源）</h2><p><a href="https://mirrors.ustc.edu.cn/help/homebrew-cask-versions.git.html">Homebrew Cask Versions 源使用帮助 — USTC Mirror Help 文档</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">homebrew | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>替换<strong>brew.git</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>brew <span class="token parameter variable">--repo</span><span class="token variable">)</span></span>"</span> <span class="token function">git</span> remote set-url origin https://mirrors.ustc.edu.cn/brew.git <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>替换<strong>homebrew-core.git</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>brew <span class="token parameter variable">--repo</span><span class="token variable">)</span></span>/Library/Taps/homebrew/homebrew-core"</span> <span class="token function">git</span> remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>替换<strong>homebrew-cask.git</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>brew <span class="token parameter variable">--repo</span><span class="token variable">)</span></span>/Library/Taps/homebrew/homebrew-cask"</span> <span class="token function">git</span> remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>更新</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew update <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一次可能会慢一点（大约5分钟），不过，后面执行brew install xxx软件时就会很快了。</p><h2 id="5-3-基本使用"><a href="#5-3-基本使用" class="headerlink" title="5.3 基本使用"></a>5.3 基本使用</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew update<span class="token comment"># 更新Homwbrew本身</span>brew list<span class="token comment"># 显示已安装的包</span>brew upgrade<span class="token comment"># 升级所有安装的包</span>brew upgrade <span class="token punctuation">[</span>包名<span class="token punctuation">]</span><span class="token comment"># 升级指定包</span>brew search <span class="token punctuation">[</span>包名<span class="token punctuation">]</span><span class="token comment"># 搜索指定包</span>brew info <span class="token punctuation">[</span>包名<span class="token punctuation">]</span><span class="token comment"># 查看包信息</span>brew <span class="token function">install</span> <span class="token punctuation">[</span>包名<span class="token punctuation">]</span> <span class="token comment"># 安装指定包</span>brew uninstall <span class="token punctuation">[</span>包名<span class="token punctuation">]</span> <span class="token comment"># 卸载指定包</span>brew <span class="token parameter variable">--help</span><span class="token comment"># 查看帮助</span>brew doctor <span class="token comment"># 诊断关于Homebrew的问题</span>brew outdated<span class="token comment"># 检查过时的包，这会列出所有安装的包里，哪些可以升级</span>brew outdated <span class="token punctuation">[</span>包名<span class="token punctuation">]</span><span class="token comment"># 检查指定的包是否有新版本</span>brew cleanup<span class="token comment"># 清理老版本的软件包及其安装包缓存</span>brew cleanup <span class="token punctuation">[</span>包名<span class="token punctuation">]</span><span class="token comment"># 清理指定包的老版本及其安装包缓存。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-常用包"><a href="#5-4-常用包" class="headerlink" title="5.4 常用包"></a>5.4 常用包</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> python3brew <span class="token function">install</span> clang-formatbrew <span class="token function">install</span> <span class="token function">wget</span>brew <span class="token function">install</span> shfmtbrew cask <span class="token function">install</span> visual-studio-codebrew <span class="token function">install</span> alfred <span class="token parameter variable">--cask</span> brew <span class="token function">install</span> <span class="token function">node</span>brew <span class="token function">install</span> <span class="token function">npm</span>brew <span class="token function">install</span> lsd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-软件安装问题"><a href="#6-软件安装问题" class="headerlink" title="6 软件安装问题"></a>6 软件安装问题</h1><p><strong>无法打开“XXXX”，因为Apple无法检查其是否包含恶意软件</strong></p><p>方法1</p><ol><li><p>在启动台里找到终端，并打开</p></li><li><p>输入命令：</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> spctl --master-disable <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>然后回车！</li><li>输入电脑密码（密码输入是看不见的，无视继续输入)，回车！</li><li>ok，执行完成。现在你又能愉快的用上你心爱的软件了。</li></ol><p>方法2</p><p>终端粘贴复制输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> xattr <span class="token parameter variable">-r</span> <span class="token parameter variable">-d</span> com.apple.quarantine <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（注意最后有一个空格），先不要按回车<br>打开 “访达”（Finder）进入 “应用程序” 目录，找到该软件图标，将图标拖到刚才的终端窗口里面，会得到如下组合：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> xattr <span class="token parameter variable">-r</span> <span class="token parameter variable">-d</span> com.apple.quarantine /Applications/PyCharm<span class="token punctuation">\</span> CE.app Password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>回到终端窗口按回车，输入系统密码回车即可。</p><h1 id="7-Clion重置时间"><a href="#7-Clion重置时间" class="headerlink" title="7 Clion重置时间"></a>7 Clion重置时间</h1><p><strong>添加无限重置时间插件</strong><br>在File-Settings -&gt; Plugins 内手动添加第三方插件仓库地址：<em><a href="https://plugins.zhile.io/">https://plugins.zhile.io</a></em><br><img src="/../../images/macOS/0285cf7458c4.png"><br><img src="/../../images/macOS/9a20b2cf133b.png"></p><p><img src="/../../images/macOS/3149529fe807.png"></p><h1 id="8-安装man手册"><a href="#8-安装man手册" class="headerlink" title="8 安装man手册"></a>8 安装man手册</h1><ol><li>软件依赖</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> autotoolsbrew <span class="token function">install</span> python3brew <span class="token function">install</span> openccbrew <span class="token function">install</span> <span class="token function">make</span>brew <span class="token function">install</span> cmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>下载</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone  https://github.com/man-pages-zh/manpages-zh    <span class="token comment">#下载文件 </span><span class="token builtin class-name">cd</span> manpages-zh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>编译</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token parameter variable">-S</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-B</span> buildcmake <span class="token parameter variable">--build</span> build<span class="token function">make</span> <span class="token parameter variable">-C</span> build <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>查看是否安装成功</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">man</span> <span class="token parameter variable">-M</span> /usr/local/share/man/zh_CN <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">LS(1)                                            用户命令                                           LS(1)名称       ls - 列出目录内容概述       ls [选项]... [文件列表]...描述       列出指定“文件”（默认为当前目录）的信息。如果既没有指定 -cftuvSUX 中任何一个，也没有指定       --sort，则按字母排序项目。       必选参数对长短选项同时适用。       -a, --all              不要忽略以点号（“.”）起始的条目       -A, --almost-all              不要列出隐含的 . 和 ..       --author              与 -l 同时使用时，列出每个文件的作者       -b, --escape              将无法显示的字符显示为C风格的转义形式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>配置别名</li></ol><p>.bashrc 或者 .zshrc添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">cman</span><span class="token operator">=</span><span class="token string">'man -M /usr/local/share/man/zh_CN'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>source</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc<span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以后使用cman ls就可以查看中文版手册了</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法和Typora编辑器使用</title>
      <link href="/blog/420f09d5.html"/>
      <url>/blog/420f09d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Markdown历史"><a href="#1-Markdown历史" class="headerlink" title="1. Markdown历史"></a>1. Markdown历史</h1><p>在日常工作和互联网写作中, Markdown几乎随处可见,并且扮演着越来越重要的角色。不管你是不是程序员,只要关乎写作,都离不开 Markdown。知乎、简书、CSDN、 GitHub、 WordPress印象笔记、有道笔记等都支持 Markdown, Markdown俨然已成为最流行的“写作语言”。</p><p>据 GitHub Flavored Markdown(GFM)官方文档介绍, Markdown是由约翰·格鲁伯( John Gruber)在亚伦·斯沃茨( Aaron Swartz)的帮助下开发,并在2004年发布的标记语言。</p><p>其设计灵感主要来源于纯文本电子邮件的格式,目标是让人们能够使用易读、易写的纯文本格式编写文档,而且这些文档可以转换为HTML( Hyper Text MarkupLanguage,超文本标记语言)文档。</p><p>起初 Markdown主要用于网络写作,后来人们希望 Markdown能够应用到更多的领域,如写书、记笔记、写文档、写幻灯片等。<br>由于 Markdown本身功能有限,一些特定的需求和场景无法被满足,因此产生了许多扩展语法,这些语法在基础语法之上新增了如表格、任务列表、围栏代码块等功能。</p><h2 id="1-1-Markdown演进史"><a href="#1-1-Markdown演进史" class="headerlink" title="1.1  Markdown演进史"></a>1.1  Markdown演进史</h2><ul><li>2006年, Pandoc’s Markdown发布,作者是 John MacFarlane此版本对 Markdown语法有额外的扩充和些许修正,这使 Markdown可以转换为更多的文件格式, Pando堪称文件转换领域的“瑞士军刀”</li><li>2011年, MultiMarkdown(简称MMD)发布,作者是 Fletcher T. Penney此版本让 Markdown可以转换为更多的文件格式,包括HTML/ XHTML、OpenDocument, OPML( Outline Processor Markup Language,大纲处理标记语言)</li><li>2013年, Markdown Extra发布,作者是 Michel fortin。此版本最初使用PHP语言实现,新增了围栏代码块、具有 id/class属性的元素、表格、任务列表、脚注、缩写等功能。</li><li>2014年, Common Mark规范发布,主要作者是 Jeff Atwood和JohrMacFarlaneCommonAl旨在为人们提供一个标准的 Markdown语法规范和参考实现。Markdown标准化工作开始于2012年,2014年9月,由于 John Gruber反对在这一工作中继续使用“ Markdown”这个名字,其被更名为 Common Mark</li><li>2017年, GitHub发布了 GitHub Flavored Markdown,即GFM此版本遵循 CommonMark规范,新增了围栏代码块、表格、删除线、自动接、 Emoji表情和任务列表等功能,是目前使用最广泛的版本。</li></ul><h2 id="1-2-标准语法-Common-Mark"><a href="#1-2-标准语法-Common-Mark" class="headerlink" title="1.2 标准语法 Common Mark"></a>1.2 标准语法 Common Mark</h2><p>由于不同版本的扩展语法太多, John Gruber对 Markdown语法也没有指定明确的规范,在非正式规范中也存在一些含糊不清的地方,一些扩展语法慢慢偏离了最初的参考实现方式。另外,用户的写作习惯和编辑器的解析规则也不尽相同,这就导致 Markdown文本在不同编辑器上解析时可能会出现一些问题。</p><p>这些问题促使一些机构和开发人员努力对 Markdown语法进行标准化CommonMark(<a href="http://commonmark.org/)%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E4%BA%A7%E7%89%A9%E3%80%82%E5%AE%83%E4%B8%BA">http://commonmark.org/)就是这样一个产物。它为</a> Markdown t提出了一个标准的、明确的语法规范,以及一套全面的测试,根据此规范可以验证Markdown的实现结果, GitHub Flavored Markdown(GFM)遵循的就是CommonMark规范</p><h2 id="1-3-最流行的扩展语法CFM"><a href="#1-3-最流行的扩展语法CFM" class="headerlink" title="1.3 最流行的扩展语法CFM"></a>1.3 最流行的扩展语法CFM</h2><p>目前最流行的扩展语法是 GitHub Flavored Markdown,简称GFM,毕竟Github是全球最大的程序员“交友”网站.</p><h1 id="2-Markdown使用场景"><a href="#2-Markdown使用场景" class="headerlink" title="2. Markdown使用场景"></a>2. Markdown使用场景</h1><p>当你对文章的排版没什么特殊需求,且不想花太多时间在排版上时,就可以使用 Markdown。因为编辑器或平台会通过 Markdown标记对文章进行渲染,最终的版效果会非常简洁、漂亮。众多“专职”的 Markdown编辑器(如 Typora、熊掌记、 Ulysses)也提供了对 Markdown的支持。</p><p>Markdown并不是万能的,它只适用于对排版要求不高的场景,如果你对字号段落、图片、表格等方面的排版要求较高,还是需要使用Word这类专业的编辑软件的。<br>小提示: Markdown文件可以很方便地转换为Word文件,如果有一些需要特殊处理的格式,可以两者结合使用。</p><h1 id="3-Markdown使用流程"><a href="#3-Markdown使用流程" class="headerlink" title="3. Markdown使用流程"></a>3. Markdown使用流程</h1><p>Markdown的工作流程很简单,首先要挑一款好用的编辑器进行写作,内容使用 Markdown进行标记,然后通过编辑器的功能将文章进行渲染、发布或导出。<br>所以如果想让 Markdown发挥最大的作用,语法和编辑器都是要好好学习的。</p><h2 id="3-1-语法学习"><a href="#3-1-语法学习" class="headerlink" title="3.1 语法学习"></a>3.1 语法学习</h2><ol><li>学习基础语法<br>Markdown的基础语法是指 John Gruber最初发布的 Markdown版本,大多扩展语法都是基于此版本开发的,因此基础语法是需要学会的。</li><li>学习扩展语法<br>在众多扩展语法中,GEM无疑是目前最流行的。它扩展了包括表格、任务列表、删除线、围栏代码、Emoj等在内的语法,功能非常全面,是笔者重点推荐学习的扩展语法。</li><li>学习写作规范<br>人们在使用 Markdown的过程中逐渐总结出了一些最佳实践方案,并且制定了写作规范,学习这些规范可以让我们养成良好的写作习惯,避免重复“踩坑”。另外,遵循这些规范也可以让源码(没有渲染过的文本)有更强的可读性、可移植性(一处编写,随处使用)和可维护性(有统一的认知)。</li></ol><h2 id="3-2-编辑器简介"><a href="#3-2-编辑器简介" class="headerlink" title="3.2 编辑器简介"></a>3.2 编辑器简介</h2><p>正所谓“好马配好鞍”,好的编辑工具可以让写作事半功倍。在市面上也有很多流行的 Markdown编辑器,免费的、收费的都有,可谓各有千秋。本文挑选了比较有代表性的工具Typora来介绍。</p><p>比较流行的Markdown编辑器列表</p><table><thead><tr><th align="center">编辑器</th><th align="center">Markdown语法</th><th align="center">跨平台</th><th align="center">移动端</th><th align="center">免费</th><th align="center">推荐指数</th><th align="center">适宜人群</th></tr></thead><tbody><tr><td align="center">Typora</td><td align="center">GFM</td><td align="center">✔️</td><td align="center">❎</td><td align="center">✔️</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">所有人</td></tr><tr><td align="center">VS Code</td><td align="center">GFM</td><td align="center">✔️</td><td align="center">❎</td><td align="center">✔️</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">技术写作人员</td></tr><tr><td align="center">Gitbook</td><td align="center">GFM</td><td align="center">✔️</td><td align="center">❎</td><td align="center">✔️</td><td align="center">⭐⭐⭐⭐</td><td align="center">热爱开源的人</td></tr><tr><td align="center">印象笔记</td><td align="center">GFM</td><td align="center">✔️</td><td align="center">❎</td><td align="center">✔️(内购)</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">印象笔记用户</td></tr><tr><td align="center">有道笔记</td><td align="center">GFM</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️(内购)</td><td align="center">⭐⭐⭐⭐</td><td align="center">有道笔记用户</td></tr><tr><td align="center">熊掌记</td><td align="center">简化并兼容标准语法</td><td align="center">❎(macOS)</td><td align="center">✔️(iOS)</td><td align="center">✔️(内购)</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">文艺青年</td></tr><tr><td align="center">Ulysses</td><td align="center">GFM</td><td align="center">❎(macOS)</td><td align="center">✔️(iOS)</td><td align="center">❎</td><td align="center">⭐⭐⭐⭐</td><td align="center">重度文字工作者</td></tr><tr><td align="center">MWeb</td><td align="center">GFM</td><td align="center">❎(macOS)</td><td align="center">✔️(iOS)</td><td align="center">❎</td><td align="center">⭐⭐⭐⭐</td><td align="center">技术写作人员</td></tr><tr><td align="center">MarkdownPad</td><td align="center">GFM</td><td align="center">❎(Windows)</td><td align="center">❎</td><td align="center">✔️(内购)</td><td align="center">⭐⭐⭐</td><td align="center">Windows用户</td></tr><tr><td align="center">CMD Markdown</td><td align="center">GFM</td><td align="center">✔️</td><td align="center">❎</td><td align="center">✔️(内购)</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">所有人</td></tr></tbody></table><p>本文示例演示使用的是Typora + VS Code。</p><h1 id="4-MarkDown语法"><a href="#4-MarkDown语法" class="headerlink" title="4. MarkDown语法"></a>4. MarkDown语法</h1><h2 id="4-1-基础语法"><a href="#4-1-基础语法" class="headerlink" title="4.1 基础语法"></a>4.1 基础语法</h2><h3 id="4-1-1-字体"><a href="#4-1-1-字体" class="headerlink" title="4.1.1 字体"></a>4.1.1 字体</h3><h4 id="4-1-1-1-标题"><a href="#4-1-1-1-标题" class="headerlink" title="4.1.1.1 标题"></a>4.1.1.1 标题</h4><ul><li>使用# 语法表示标题</li></ul><p><code># + 空格 + 标题内容</code></p><ul><li><p>语法说明</p><ol><li><p>在行首插入#可标记出标题</p></li><li><p>#的个数表示标题等级</p></li><li><p>建议在#之后加一个空格</p></li><li><p>Markdown最多支持六级标题</p></li></ol></li><li><p>示例演示</p></li></ul><p><img src="/images/typora/c5257c96bdccfaa71a55c938765be20b.png" alt="image-20210602233706829"></p><p>建议标题写在一行的开头，结尾不要有空格和标点符号，如句号，都好，冒号，分号等。</p><p>建议标题要尽量简短，这样方便引用，特别是当生成目录时。如果原拟的标题是一个长句，可以从长句中提取标题，并将长句作为标题下的内容。</p><h4 id="4-1-1-2-粗体和斜体"><a href="#4-1-1-2-粗体和斜体" class="headerlink" title="4.1.1.2 粗体和斜体"></a>4.1.1.2 粗体和斜体</h4><p>在Markdown中，粗体由两个 * 或者两个 _ 包裹，斜体由一个 * 或者一个 _ 包裹</p><ul><li>使用* 的加粗语法</li></ul><p><code>**加粗内容**</code></p><ul><li>使用_ 的加粗语法</li></ul><p><code>__加粗内容__</code></p><ul><li>使用* 的斜体语法</li></ul><p><code>*加粗内容*</code></p><ul><li>使用_ 的斜体语法</li></ul><p><code>_加粗内容_</code></p><ul><li>示例演示</li></ul><p><img src="/images/typora/aac25fa61a7df8a4a771bccea416bff4.png" alt="image-20210603001344569"></p><h3 id="4-1-2-段落与换行"><a href="#4-1-2-段落与换行" class="headerlink" title="4.1.2 段落与换行"></a>4.1.2 段落与换行</h3><p>Markdown支持有序列表和无序列表</p><p>有序列表使用数字序号 + 加英文句号 + 空格 + 列表内容来标记</p><p>无序列表由*/+/- + 空格 + 列表内容来标记。</p><h4 id="4-1-2-1-有序列表"><a href="#4-1-2-1-有序列表" class="headerlink" title="4.1.2.1 有序列表"></a>4.1.2.1 有序列表</h4><ul><li><p>有序列表语法如下</p><p>  <code>数字序号 + 英文句号 + 空格 —+ 列表内容</code></p></li><li><p>示例演示</p></li></ul><p><img src="/images/typora/5d3b3a1c9a4dd17ed7dc64523f03e6ed.png" alt="image-20210603001814484"></p><h4 id="4-1-2-2-无序列表"><a href="#4-1-2-2-无序列表" class="headerlink" title="4.1.2.2 无序列表"></a>4.1.2.2 无序列表</h4><ul><li>无序列表语法如下</li></ul><p><code>*/+/- + 空格 + 列表内容</code></p><p>建议使用-来标记无序列表，因为* 容易跟粗体和斜体混淆,而+不流行</p><ul><li>示例演示</li></ul><p><img src="/images/typora/2ce7c662b26e9ea6f98846a2b73515d4.png" alt="image-20210603002534732"></p><h4 id="4-1-2-3-嵌套列表"><a href="#4-1-2-3-嵌套列表" class="headerlink" title="4.1.2.3 嵌套列表"></a>4.1.2.3 嵌套列表</h4><ul><li>嵌套列表语法</li></ul><p><code>+ 第一层列表</code></p><p><code>TAB + 第二层列表</code></p><p><code>TAB + TAB + 第三层列表</code></p><ul><li>示例演示</li></ul><p><img src="/images/typora/5823cdd42ebd2a6c9bb4e121597292f8.png" alt="image-20210603004437012"></p><h4 id="4-1-2-4-分割线"><a href="#4-1-2-4-分割线" class="headerlink" title="4.1.2.4 分割线"></a>4.1.2.4 分割线</h4><p>在Markdown中，分割线由三个以上的*/-/_来标记。</p><ul><li>分割线语法</li></ul><p><code>***</code></p><p><code>---</code></p><p><code>___</code></p><p>==注意，在行内不要有其他的字符==</p><ul><li>示例演示</li></ul><p><img src="/images/typora/ea0741982832bb24baebbf240d02cb85.png" alt="image-20210603223346746"></p><h3 id="4-1-3-图片-framed-picture"><a href="#4-1-3-图片-framed-picture" class="headerlink" title="4.1.3 图片:framed_picture:"></a>4.1.3 图片<span class="github-emoji"><span>🖼</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f5bc.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><ul><li>插入图片的语法如下</li></ul><p><code>![图片代表文字](图片地址)</code></p><ul><li><p>语法说明</p><ol><li><p>图片替代问题在图片无法正常显示时比较有用，正常情况下可以为空</p></li><li><p>图片地址是本地图片也可以是网络图片</p></li><li><p>本地图片支持相对路径和绝对路径</p></li></ol></li><li><p>示例演示</p></li></ul><p><img src="/images/typora/42cb2cee0643a2c4ce15f6416dc4bd67.png" alt="image-20210605145346541"></p><p><img src="/images/typora/7489feba2820a8975881241e007950c6.png" alt="image-20210605145109936"></p><p><img src="/images/typora/864807412c04593a376f959d4f2c203c.png" alt="image-20210605145223049"></p><p><img src="/images/typora/82313543ec9ff193521495dca6ff9386.png" alt="image-20210605145309429"></p><h3 id="4-1-4-链接-link"><a href="#4-1-4-链接-link" class="headerlink" title="4.1.4 链接 :link:"></a>4.1.4 链接 <span class="github-emoji"><span>🔗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><h4 id="4-1-4-1文字链接"><a href="#4-1-4-1文字链接" class="headerlink" title="4.1.4.1文字链接"></a>4.1.4.1文字链接</h4><p>文字链接就是把链接地址写在文本里。语法是用方括号包裹链接文字，后面紧跟着括号包裹的链接地址。</p><p><code>[链接文字](链接地址)</code></p><ul><li>示例演示</li></ul><p><img src="/images/typora/164b70748ff5a8f539729b19e4dbccda.png" alt="image-20210605150610474"></p><p><img src="/images/typora/a2318a0b52e269f0b39883439a7108f2.png" alt="image-20210605150925108"></p><p>相较之下，第二种写法将链接地址放在某个地方统一定义好，然后在正文中通过<strong>变量</strong>来引用，可读性更好一些，这种方法叫引用链接。</p><h4 id="4-1-4-3网址链接"><a href="#4-1-4-3网址链接" class="headerlink" title="4.1.4.3网址链接"></a>4.1.4.3网址链接</h4><p>在Markdown中，将网络地址或邮箱地址使用&lt;&gt;包裹起来就会被自动转换为超链接。</p><ul><li>网络链接语法</li></ul><p><code>&lt;URL或邮箱地址&gt;</code></p><ul><li>示例演示</li></ul><p><img src="/images/typora/256f36dff2011d5ce69cbd512d73e1c0.png" alt="image-20210605152121436"></p><p>==注意 自动链接要以http/https 开头==</p><h3 id="4-1-5-代码"><a href="#4-1-5-代码" class="headerlink" title="4.1.5 代码"></a>4.1.5 代码</h3><h4 id="4-1-5-1-行内代码"><a href="#4-1-5-1-行内代码" class="headerlink" title="4.1.5.1 行内代码"></a>4.1.5.1 行内代码</h4><p>在Markdown中，行内代码引用使用两个`包裹</p><ul><li>示例演示</li></ul><p><img src="/images/typora/65a0aa07464acee4ddd6c492871b08b2.png" alt="image-20210605153117858"></p><h4 id="4-1-5-2-代码块"><a href="#4-1-5-2-代码块" class="headerlink" title="4.1.5.2 代码块"></a>4.1.5.2 代码块</h4><p>在Markdown中，代码块以tab键或者四个空格开头</p><ul><li>示例演示</li></ul><p><img src="/images/typora/e32f4665c60f020ab58fb2b3623a2381.png" alt="image-20210605153554490"></p><p>因为代码块使用tab后者四个空格开头的效果不够直观，很多扩展语法如GFM提供了<em><strong>围栏代码块</strong></em>功能，并且支持语法高亮，详见4.2.5。</p><h3 id="4-1-6-引用"><a href="#4-1-6-引用" class="headerlink" title="4.1.6 引用"></a>4.1.6 引用</h3><p>在Markdown中，引用由 &gt; + 引用内容来标记</p><ul><li>引用语法</li></ul><p><code>&gt; 引用内容</code></p><ul><li><p>语法说明</p><ol><li>多行引用也可以在没一行的开头都插入&gt; 。</li><li>在引用中可以嵌套引用</li><li>在引用中可以嵌套其他的Markdown语法</li><li>段落与换行的格式在引用中也是适用的。</li></ol></li><li><p>示例演示</p></li></ul><p><img src="/images/typora/d790cdb30c52ce4977802f8ada8ce448.png" alt="image-20210605165843595"></p><h3 id="4-1-7-转义"><a href="#4-1-7-转义" class="headerlink" title="4.1.7 转义"></a>4.1.7 转义</h3><p>当我们在Markdown文件中插入一些标记，但是又不想这些符号被渲染时，可以使用\进行转义</p><ul><li>转义语法</li></ul><p><code>\特殊符号</code></p><p>可被转义的字符</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">\   反斜线`   反引号<span class="token list punctuation">*</span>   星号_   底线{}  花括号[]  方括号()  括弧<span class="token title important"><span class="token punctuation">#</span>   井字号</span><span class="token list punctuation">+</span>   加号<span class="token list punctuation">-</span>   减号.   英文句点!   惊叹号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>示例演示</li></ul><p><img src="/images/typora/767e9b25267609d6ef9b6c67bbef906e.png" alt="image-20210605170717467"></p><h2 id="4-2-扩展语法"><a href="#4-2-扩展语法" class="headerlink" title="4.2 扩展语法"></a>4.2 扩展语法</h2><p>在众多Markdown扩展语法中，Github Flavored Markdown（简称 GFM）无疑是最流行的，它提供了包括表格，任务列表，围栏代码块，蔚蓝代码，emoji表情等在内的标记语法。</p><h3 id="4-2-1-删除线"><a href="#4-2-1-删除线" class="headerlink" title="4.2.1 删除线"></a>4.2.1 删除线</h3><ul><li>删除线语法</li></ul><p><code>~~被删除文字~~</code></p><ul><li>示例演示</li></ul><p><img src="/images/typora/2358035b107e112db741214cb2d25ef3.png" alt="image-20210605171920271"></p><h3 id="4-2-2-表情符号-dog"><a href="#4-2-2-表情符号-dog" class="headerlink" title="4.2.2 表情符号:dog:"></a>4.2.2 表情符号<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><p>使用：包裹表情代码即可</p><ul><li>表情符号与法</li></ul><p><code>:表情代码:</code></p><ul><li>示例演示</li></ul><p><img src="/images/typora/78616ec674d1dfd5237a6d0932d5b2ed.png" alt="image-20210605172850754"></p><p>更多表情符号，请查阅<a href="https://emoji.svend.cc/">https://emoji.svend.cc/</a></p><h3 id="4-2-3-表格"><a href="#4-2-3-表格" class="headerlink" title="4.2.3 表格"></a>4.2.3 表格</h3><ul><li>表格语法</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token table"><span class="token table-header-row"><span class="token punctuation">|</span><span class="token table-header important"> 表头1 </span><span class="token punctuation">|</span><span class="token table-header important"> 表头2 </span><span class="token punctuation">|</span><span class="token table-header important"> 表头2 </span><span class="token punctuation">|</span></span><span class="token table-line"><span class="token punctuation">|</span> <span class="token punctuation">----</span> <span class="token punctuation">|</span> <span class="token punctuation">----</span> <span class="token punctuation">|</span> <span class="token punctuation">----</span> <span class="token punctuation">|</span></span><span class="token table-data-rows"><span class="token punctuation">|</span><span class="token table-data"> 内容1 </span><span class="token punctuation">|</span><span class="token table-data"> 内容2 </span><span class="token punctuation">|</span><span class="token table-data"> 内容3 </span><span class="token punctuation">|</span><span class="token punctuation">|</span><span class="token table-data"> 内容1 </span><span class="token punctuation">|</span><span class="token table-data"> 内容2 </span><span class="token punctuation">|</span><span class="token table-data"> 内容3 </span><span class="token punctuation">|</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>语法说明</p><ol><li><p>单元格之间使用|来分割，为了阅读清晰，建议前和后都使用|</p></li><li><p>表头和其他行使用—-来分割</p></li><li><p>表格对齐方式</p><ol><li>左对齐(默认) <code>:----</code></li><li>右对齐 <code>----:</code></li><li>居中对齐 <code>:----:</code></li></ol></li><li><p>块级元素（代码区域，引用区块）不能插入表格</p></li></ol></li><li><p>示例演示</p></li></ul><p><img src="/images/typora/75190dd933ca8c9cbc844d8296da9151.png" alt="image-20210605175509710"></p><h3 id="4-2-4-任务列表"><a href="#4-2-4-任务列表" class="headerlink" title="4.2.4 任务列表"></a>4.2.4 任务列表</h3><ul><li>任务列表语法</li></ul><pre class="line-numbers language-markd" data-language="markd"><code class="language-markd">- [ ] 未勾选- [x] 未勾选<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>语法说明</p><ol><li>任务列表以-或者+开头，然后加[ 空格 / + ]</li><li>x可以小写也可以大写，推荐使用小写x</li><li>方括号中的符号为空格时，复选框是未选中状态，为x时是选中状态</li></ol></li><li><p>示例演示</p></li></ul><p><img src="/images/typora/17687a03ed1f0ce33f15e116d455fffb.png" alt="image-20210605181432884"></p><h3 id="4-2-5-围栏代码块"><a href="#4-2-5-围栏代码块" class="headerlink" title="4.2.5 围栏代码块"></a>4.2.5 围栏代码块</h3><ul><li>围栏代码语法</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">​```代码块​```或者~<span class="token strike"><span class="token punctuation">~~</span><span class="token content">代码块</span><span class="token punctuation">~~</span></span>~语法高亮​```编程语言的名称代码块​```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>语法说明</li></ul><p>围栏代码使用三个`或者~包裹，支持语法高亮并可以加上编程语言的名称</p><ul><li>示例演示</li></ul><p><img src="/images/typora/d0864330ac8ac316a9ac2c4bed959034.png" alt="image-20210605182516976"></p><h3 id="4-2-6-目录"><a href="#4-2-6-目录" class="headerlink" title="4.2.6 目录"></a>4.2.6 目录</h3><ul><li>生成目录的语法</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">@[toc]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>示例演示</li></ul><p><img src="/images/typora/9319bb71797c087639f018e0df020b19.png" alt="image-20210605184138034"></p><h2 id="4-3-排版建议"><a href="#4-3-排版建议" class="headerlink" title="4.3 排版建议"></a>4.3 排版建议</h2><ul><li><p>英文标点符号（如,.;:?）与后面的字符之间需要加空格，与前面的字符不需要加空格</p></li><li><p>当在中文，或者英文中使用&gt;标识路径是，两边加空格</p><p>  例如 偏好设置 →通用 →高级设置</p></li><li><p>数字和百分号之间不需要添加空格</p></li><li><p>数字和单位符号之间不需要添加空格</p></li><li><p>货币符号后不加空格</p></li><li><p>中文排版中，使用全角标点符号</p></li><li><p>英文排版中，使用半角标点符号</p></li><li><p>正确使用英文大小写</p></li></ul><h1 id="5-Typora编辑器使用"><a href="#5-Typora编辑器使用" class="headerlink" title="5. Typora编辑器使用"></a>5. Typora编辑器使用</h1><h2 id="5-1-软件安装"><a href="#5-1-软件安装" class="headerlink" title="5.1 软件安装"></a>5.1 软件安装</h2><p>Typora是目前最受欢迎的Markdown编辑器之一，主要特性如下</p><ol><li>实时预览：传统的Markdown编辑器都有两个窗口，左边是源码，右边是渲染后的结果。Typora 独辟蹊径，把源码编辑和预览效果合二为一，实现了真正的所见即所得。</li><li>扩展语法：Typora不仅支持GFM，还扩展数学公式，流程图等功能</li><li>快捷操作：Typora对几乎所有的Markdown标记都提供了快捷操作方式，使用起来非常高效。</li><li>界面漂亮：默认支持6种主题，可自定义，好看又好用</li><li>文件转换：支持多种文件格式通过导入/导出功能跟.md格式相互转换</li><li>支持中文，可以帮助大家更好的理解各项功能</li><li>视图模式：支持大纲和文档列表视图，方便在不同段落和不同文件之间进行切换</li><li>跨平台：支持macOS，windows和Linux系统</li><li>目前免费：真香</li></ol><p>下载地址：<a href="https://www.typora.io/">https://www.typora.io/</a></p><h2 id="5-2-界面介绍"><a href="#5-2-界面介绍" class="headerlink" title="5.2 界面介绍"></a>5.2 界面介绍</h2><p>在默认情况下，Typora会使用操作系统的语言，如果需要自定义语言，可以在Typora编辑器上执行如下操作：偏好设置 →通用 →语言 ，选择语言后，重启Typora即可生效。</p><p>Typora编辑器的界面</p><p><img src="/images/typora/394f2b65567e88447d8368ef1dc7467b.png" alt="image-20210606191009446"></p><p>默认鼠标放到状态栏才会显示字数统计，如果我们想让字数一直显示，则需要在<strong>偏好设置</strong>中设置，操作步骤：文件→ 偏好设置 → 外观 → 字数统计 → 勾选 <strong>总是显示字数统计</strong></p><p>Typora编辑器最具特色的功能就是实时预览，当输入Markdown标记后，按回车键或者定位到别的段落就可以看到预览效果。之前介绍的Markdown语法，Typora都支持</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">##</span> 常用标记</span><span class="token bold"><span class="token punctuation">**</span><span class="token content">粗体</span><span class="token punctuation">**</span></span> ，<span class="token italic"><span class="token punctuation">*</span><span class="token content">斜体</span><span class="token punctuation">*</span></span>，==高亮==，<span class="token strike"><span class="token punctuation">~~</span><span class="token content">删除线</span><span class="token punctuation">~~</span></span>，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>u</span><span class="token punctuation">&gt;</span></span>下划线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>u</span><span class="token punctuation">&gt;</span></span>，我是^上标^，我是<span class="token strike"><span class="token punctuation">~</span><span class="token content">下标</span><span class="token punctuation">~</span></span>，<span class="token url">[<span class="token content">超链接</span>](<span class="token url">http://www.baidu.com</span>)</span><span class="token url"><span class="token operator">!</span>[<span class="token content">图片</span>](<span class="token url">https://wx1.sinaimg.cn/large/008egyxIly1gqh131whhfj30u010yagf.jpg</span>)</span>无序列表<span class="token list punctuation">-</span> 无序列表1<span class="token list punctuation">-</span> 无序列表2<span class="token list punctuation">1.</span> 有序列表<span class="token list punctuation">2.</span> 有序列表任务列表-[ ] 看电影-[ ] 听音乐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染后的效果</p><p><img src="/images/typora/48214d125988931bd3ee6aca57061981.png" alt="image-20210620234753126"></p><h2 id="5-3-高效使用Typora"><a href="#5-3-高效使用Typora" class="headerlink" title="5.3 高效使用Typora"></a>5.3 高效使用Typora</h2><p>Typora支持GFM，还扩展了很多其他的功能（如支持的数学公式，上标，下标，高亮，各种图表），它几乎为每个标记提供了快捷的操作方式，这使得我们的写作变得轻松。</p><h3 id="5-3-1-基础语法和GFM语法"><a href="#5-3-1-基础语法和GFM语法" class="headerlink" title="5.3.1 基础语法和GFM语法"></a>5.3.1 基础语法和GFM语法</h3><h4 id="5-3-1-1-编辑样式"><a href="#5-3-1-1-编辑样式" class="headerlink" title="5.3.1.1 编辑样式"></a>5.3.1.1 编辑样式</h4><p>在Typora中通过执行：菜单栏 → <strong>格式</strong> → 加粗/斜体/代码/图像/超链接 ，可以添加或移除关于文字样式的的标记符号。如果没有选中文字，则只会添件标记符号；如果选中了文字，则会为选中的文字添加或移除标记符号</p><p>格式快捷键</p><p>Format</p><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">加粗</td><td align="center">Ctrl + B</td><td align="center">Command + B</td></tr><tr><td align="center">斜体</td><td align="center">Ctrl + I</td><td align="center">Command + I</td></tr><tr><td align="center">下划线</td><td align="center">Ctrl + U</td><td align="center">Command + U</td></tr><tr><td align="center">行内代码</td><td align="center">Ctrl + Shift + `</td><td align="center">Control + `</td></tr><tr><td align="center">删除线</td><td align="center">Alt + Shift + 5</td><td align="center">Control + Shift + `</td></tr><tr><td align="center">超链接</td><td align="center">Ctrl + K</td><td align="center">Command + K</td></tr><tr><td align="center">图片</td><td align="center">Ctrl + Shift + I</td><td align="center">Command + Control + I</td></tr><tr><td align="center">清除格式</td><td align="center">Ctrl + \</td><td align="center">Command + \</td></tr><tr><td align="center">源代码模式/预览模式切换</td><td align="center">Ctrl + /</td><td align="center">Command + /</td></tr></tbody></table><h4 id="5-3-1-2-编辑段落"><a href="#5-3-1-2-编辑段落" class="headerlink" title="5.3.1.2 编辑段落"></a>5.3.1.2 编辑段落</h4><p>在Typora中通过执行：菜单栏 → <strong>段落</strong> → 段落/引用/表格/代码块/分割线/有序列表/无序列表/任务列表，可以添加或删除关于段落的标记符号</p><ol><li>段落的快捷键</li></ol><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">标题1-6</td><td align="center">Ctrl + 1/2/3/4/5/6</td><td align="center">Command + 1/2/3/4/5/6</td></tr><tr><td align="center">正文</td><td align="center">Ctrl + 0</td><td align="center">Command + 0</td></tr><tr><td align="center">提升标题级别</td><td align="center">Ctrl + =</td><td align="center">Command + =</td></tr><tr><td align="center">降低标题级别</td><td align="center">Ctrl + -</td><td align="center">Command + -</td></tr><tr><td align="center">添加有序列表</td><td align="center">Ctrl + Shift + [</td><td align="center">Command + Option + O</td></tr><tr><td align="center">添加无序列表</td><td align="center">Ctrl + Shift + ]</td><td align="center">Command + Option + U</td></tr><tr><td align="center">减少缩进</td><td align="center">Ctrl + [</td><td align="center">Command + [</td></tr><tr><td align="center">增加缩进</td><td align="center">Ctrl + ]</td><td align="center">Command + ]</td></tr><tr><td align="center">添加任务状态</td><td align="center">无</td><td align="center">Option + Command + X</td></tr><tr><td align="center">切换任务状态</td><td align="center">无</td><td align="center">Control + X</td></tr></tbody></table><p><strong>注意</strong><span class="github-emoji"><span>㊙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/3299.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li><p>当光标放在任务列表上时，任务状态被激活，这时才可以切换任务状态</p></li><li><p><em>列表</em>和<em>代码块</em>都可以使用<strong>增加缩进</strong>和<strong>减少缩进</strong></p></li></ul><ol start="2"><li>引用和水平分割线</li></ol><p>与引用和水平分割线对应的快捷键</p><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">添加引用</td><td align="center">Ctrl + Shift + Q</td><td align="center">Option + Command + Q</td></tr><tr><td align="center">添加水平分割线</td><td align="center">无</td><td align="center">Option + Command + -</td></tr></tbody></table><ol start="3"><li>表格</li></ol><p>如果想创建一个表格，可以执行菜单栏 → <strong>段落</strong> → 表格 → 输入列数和行数 → 单击确定按钮。</p><p>创建表格的快捷键</p><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">创建表格</td><td align="center">Ctrl + Shift + T</td><td align="center">Option + Command + T</td></tr><tr><td align="center">增加一行</td><td align="center">Ctrl + Enter</td><td align="center">Command + Enter</td></tr><tr><td align="center">删除一行</td><td align="center">Ctrl + Backspace</td><td align="center">Command + Shift + Delete</td></tr></tbody></table><p>对于表格的增加，删除，复制和格式化操作，可以在表格中单击鼠标右键，选择<strong>表格</strong>，通过其列出的操作选项对表格进行操作。如图</p><p><img src="/images/typora/434f75138e9bfaa8979a192417191b24.png" alt="image-20210606204601224"></p><p>快速调整表格</p><p>如果想快速调整表格的行数，列数，对齐方式，可以将光标放在表格中，表格左上方和右下方都会显示操作菜单，直接进行操作即可。==但是不太建议用这种方式调整对齐方式，否则整个文档粘贴到博客当中之后，可能还是调整前的状态，建议直接修改源代码，用:来调整==</p><p><img src="/images/typora/8873ed25fecea85fb6544359d8c32e0d.png" alt="image-20210606205215428"></p><p>如果想调整表格中行或列的顺序，可将光标放在行的最左边或列的最上边，当光标变成双向箭头后拖动即可调整顺序。</p><p><img src="/images/typora/c9bd182e00f64b8ee45ed9c5ad4e9170.gif" alt="Jietu20210606-210513-HD"></p><ol start="4"><li>围栏代码块</li></ol><p>如果想添加或删除围栏代码块的标记，可以执行菜单栏 → 段落 → 代码块。如果想把某段内容使用围栏代码块包裹，需要首先选中该内容，然后执行上述操作。</p><p>围栏代码块快捷键</p><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">代码块</td><td align="center">Ctrl + Shift + K</td><td align="center">Option + Command + C</td></tr></tbody></table><p>代码块默认是不显示行数的，如果想显示行数，则需要执行文件 → 偏好设置 → markdown →代码块 → 勾选显示行数。</p><p>在代码块中，如果代码过长，默认是会自动换行的。如果不希望代码自动换行，可以执行，文件 → 偏好设置 → markdown → 代码块 → 不勾选代码块自动换行。</p><h3 id="5-3-2-Typora扩展语法1"><a href="#5-3-2-Typora扩展语法1" class="headerlink" title="5.3.2 Typora扩展语法1"></a>5.3.2 Typora扩展语法1</h3><p>Typora扩展了下划线，数学公式，目录，脚注，上标和下标，图表操作等功能，并且支持很多HTML标签，使排版样式更加齐全。</p><h4 id="5-3-2-1-下划线"><a href="#5-3-2-1-下划线" class="headerlink" title="5.3.2.1 下划线"></a>5.3.2.1 下划线</h4><p>在Typora中，下划线是通过HTML的&lt;u&gt;标签来实现的，语法如下</p><p><code>&lt;u&gt;这段文字下面有下划线&lt;/u&gt;</code>，效果就是这样，<u>这段文字下面有下划线</u></p><p>下划线快捷键</p><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">下划线</td><td align="center">Ctrl + U</td><td align="center">Command +U</td></tr></tbody></table><h4 id="5-2-2-2-高亮"><a href="#5-2-2-2-高亮" class="headerlink" title="5.2.2.2 高亮"></a>5.2.2.2 高亮</h4><p>如果想使用高亮，需要首先激活偏好设置 → Markdown → Markdown扩展语法 → 勾选高亮→ 重启Typora。</p><p>Typora的语法</p><p><code>==高亮内容==</code></p><ul><li><p>语法说明</p><ol><li><p>使用两个等号（=）把想要高亮的内容包裹起来</p></li><li><p>设置的高亮的内容是显示为黄色</p></li></ol></li><li><p>示例演示</p></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">==我醉欲眠卿且去==，明朝有意抱琴来<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染后的效果</p><p>==我醉欲眠卿且去==，明朝有意抱琴来</p><p>还可以执行：菜单栏 → 格式 → 高亮，插入高亮的语法标记</p><h4 id="5-2-2-3-注释"><a href="#5-2-2-3-注释" class="headerlink" title="5.2.2.3 注释"></a>5.2.2.3 注释</h4><p>如果想添加注释，可以执行：菜单栏 → 格式 → 注释，在编辑和预览时，注释的内容会被显示；在导出PDF和word时，则会被隐藏</p><p>设置注释的语法</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token comment">&lt;!--我是注释--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置注释的快捷键</p><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">注释</td><td align="center">无</td><td align="center">Control + -</td></tr></tbody></table><h4 id="5-2-2-4-清除格式"><a href="#5-2-2-4-清除格式" class="headerlink" title="5.2.2.4 清除格式"></a>5.2.2.4 清除格式</h4><p>如果想快速清除样式，可以执行：菜单栏 → 格式 → 清除样式</p><p>清除样式的快捷键</p><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">清除样式</td><td align="center">Ctrl + \</td><td align="center">Control + \</td></tr></tbody></table><h3 id="5-3-3-Typora扩展语法2"><a href="#5-3-3-Typora扩展语法2" class="headerlink" title="5.3.3 Typora扩展语法2"></a>5.3.3 Typora扩展语法2</h3><h4 id="5-3-3-1-上标和下标"><a href="#5-3-3-1-上标和下标" class="headerlink" title="5.3.3.1 上标和下标"></a>5.3.3.1 上标和下标</h4><p>如果想使用上标和下标，需要首先激活偏好设置 → Markdown → Markdown扩展语法 → 勾选下标/上标 → 重启Typora。上标和下标的语法</p><p><code>~下标内容~</code></p><p><code>^上标内容^</code></p><ul><li>语法说明</li></ul><ol><li>使用~把下标内容包裹起来</li><li>使用^把上标内容包裹起来</li></ol><ul><li>示例演示</li></ul><pre class="line-numbers language-Markdown" data-language="Markdown"><code class="language-Markdown">下标：H~2~O上标：x^2^ + Y^2^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染后的效果</p><p>下标：H<del>2</del>O</p><p>上标：x^2^ + Y^2^</p><p>还可以执行：菜单栏 → 格式 → 上标/下标，插入上标/下标的语法标记</p><h4 id="5-3-3-2-内联数学公式"><a href="#5-3-3-2-内联数学公式" class="headerlink" title="5.3.3.2 内联数学公式"></a>5.3.3.2 内联数学公式</h4><p>如果想使用内联数学公式，需要首先激活偏好设置 → Markdown → Markdown扩展语法 → 勾选内联公式 → 重启Typora。内联数学公式的语法是使用$把数学公式包裹起来</p><p><code>$数学公式$</code></p><ul><li>示例演示</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">分数：$f(x,y) = \frac{x^2}{y^3}$开根号：$f(x,y) = \sqrt[n]{{x^2}{y^3}}$省略号：$f(x<span class="token strike"><span class="token punctuation">~</span><span class="token content">1</span><span class="token punctuation">~</span></span>,x<span class="token strike"><span class="token punctuation">~</span><span class="token content">2</span><span class="token punctuation">~</span></span>，\ldots,x<span class="token strike"><span class="token punctuation">~</span><span class="token content">n</span><span class="token punctuation">~</span></span>) = x<span class="token strike"><span class="token punctuation">~</span><span class="token content">1</span><span class="token punctuation">~</span></span> + x<span class="token strike"><span class="token punctuation">~</span><span class="token content">2</span><span class="token punctuation">~</span></span> + + \cdots x<span class="token strike"><span class="token punctuation">~</span><span class="token content">n</span><span class="token punctuation">~</span></span>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染后的效果</p>分数：$f(x,y) = \frac{x^2}{y^3}$开根号：$f(x,y) = \sqrt[n]{{x^2}{y^3}}$省略号：$f(x~1~,x~2~，\ldots,x~n~) = x~1~ + x~2~ + + \cdots x~n~$<p>还可以执行：菜单栏 → 格式  →  内嵌公式 ，插入内联数学公式。</p><p>设置插入内联数学公式的快捷方式</p><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">内联数学公式</td><td align="center">无</td><td align="center">Control + M</td></tr></tbody></table><h4 id="5-2-3-3-数学公式块"><a href="#5-2-3-3-数学公式块" class="headerlink" title="5.2.3.3 数学公式块"></a>5.2.3.3 数学公式块</h4><p>专业的写作离不开数学公式。其语法是使用两个$包裹数学公式</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$数学公式$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为某段内容添加或删除公式块，需要先选中该内容，然后执行：菜单栏 → 段落 → 公式块，如果不选中任何内容，直接执行：菜单栏 → 段落 → 公式块，则会插入公式块标记。</p><p>公式块快捷键</p><table><thead><tr><th align="center">操作</th><th align="center">Windows</th><th align="center">macOS</th></tr></thead><tbody><tr><td align="center">公式块</td><td align="center">Ctrl + Shift + M</td><td align="center">Option + Command + M</td></tr></tbody></table><h3 id="5-3-4-Typora扩展语法3"><a href="#5-3-4-Typora扩展语法3" class="headerlink" title="5.3.4 Typora扩展语法3"></a>5.3.4 Typora扩展语法3</h3><p>如果想使用图表功能,需要先激活:文件→偏好设置 → Markdown →Markdown扩展语法 →勾选 图表→重启 Typora<br>注意</p><ol><li>图表是 Typora的扩展语法,标准的 Markdown语法、 CommonMark和GFM都不支持这一语法。</li><li>如果想要把图表使用到更多的地方,推荐直接插入图片,不推荐在 Typora中进行绘制</li><li>在 Typora中,图表在导出 HTML/PDF/ePub/dox等格式的文件时会被正常显示,但是其他的 Markdown编辑器不一定支持此语法。</li></ol><h4 id="5-2-4-1-序列图"><a href="#5-2-4-1-序列图" class="headerlink" title="5.2.4.1  序列图"></a>5.2.4.1  序列图</h4><p>序列图( Sequence Diagram)也被称为循序图,是一种UML( Unified Modeling Language,统一建模语言)行为图,它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。<br>Typora提供的序列图语法标记功能是基于开源项目发的</p><ul><li>语法</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">​```mermaidsequenceDiagramjs-sequence-diagrames语法​```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>语法说明</p><ol><li>使用3个 ` +  sequence包裹js-quence-diagrams语法。</li><li>js-sequence-diagrams语法参考<a href="http://bramp.githu.io/js-sequence-diagrams/">http://bramp.githu.io/js-sequence-diagrams/</a>。</li></ol></li><li><p>示例演示</p></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">​```mermaidsequenceDiagraminterface-&gt;&gt;CanTp:CanTp_TransmitCanTp-&gt;&gt;CanTp:Check inputCanTp-&gt;&gt;CanTp:Active a Tx taskCanTp--&gt;&gt;interface:CanTp-&gt;&gt;interface:PduR_CanTpCopyTxDatainterface-&gt;&gt;interface:copy segment datainterface--&gt;&gt;CanTp:CanTp-&gt;&gt;CanIf:CanIf_TransmitCanIf--&gt;&gt;CanTp:CanIf-&gt;&gt;CanTp:CanTp_TxConfirmationCanTp--&gt;&gt;CanIf:CanTp-&gt;&gt;interface:PduR_CanTpTxConfirmationinterface--&gt;&gt;CanTp:​```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>渲染效果</li></ul><p><img src="/images/typora/4ed276465678150cb2dbb79ee50ee0ff.png" alt="image-20210620233726718"></p><h4 id="5-2-4-2-流程图"><a href="#5-2-4-2-流程图" class="headerlink" title="5.2.4.2 流程图"></a>5.2.4.2 流程图</h4><p>流程图是以图像的方式表示过程，算法和流程的，Typora提供的流程图语法标记是基于开源项目(flowchart.js)开发的</p><p>flowchart.js语法参考<a href="http://flowchaer.js.org/">http://flowchaer.js.org/</a>。</p><h4 id="5-2-4-3-甘特图"><a href="#5-2-4-3-甘特图" class="headerlink" title="5.2.4.3 甘特图"></a>5.2.4.3 甘特图</h4><h2 id="5-4-自定义Typora主题"><a href="#5-4-自定义Typora主题" class="headerlink" title="5.4 自定义Typora主题"></a>5.4 自定义Typora主题</h2><p>如果想更换Typora主题，可以执行：菜单栏 → 主题→ 选择中意的主题</p><p>Typora软件安装后，就有五种主题可选择，如果感觉不太满意，可以去<a href="https://theme.typora.io/">官网主题</a>下载。</p><p>也可以在github上下载<a href="https://github.com/luxihua201010028/Typora-theme">Typora主题</a>,然后放在主题文件夹下即可。</p><p>如果不知道安装目录，可以执行：菜单栏 → 偏好设置 → 外观→ 打开主题文件夹，就可以打开主题文件夹，重启Typora即可看到下载的主题，选择即可。</p><p><img src="/images/typora/daabbf0ee158d5bbc08092be6e5fdae5.png" alt="image-20210608215821717"></p><h2 id="5-5-Typora自动上传图片至阿里云图床"><a href="#5-5-Typora自动上传图片至阿里云图床" class="headerlink" title="5.5 Typora自动上传图片至阿里云图床"></a>5.5 Typora自动上传图片至阿里云图床</h2><p>Typora + ipic + 阿里云OSS</p><h3 id="5-5-1-阿里云图床环境搭建"><a href="#5-5-1-阿里云图床环境搭建" class="headerlink" title="5.5.1 阿里云图床环境搭建"></a>5.5.1 阿里云图床环境搭建</h3><ol><li><a href="https://account.aliyun.com/register/register.htm?spm=5176.12901015.yrepazatz.1.3ec5525covwkoT&amp;oauth_callback=https://www.aliyun.com?spm=5176.12901015.0.i12901015.3ec5525covwkoT">注册阿里云账号</a>，手机号注册即可</li></ol><p><img src="/images/typora/153c2561022e48c02c272a76327a85ab.png" alt="image-20210608220913086"></p><ol start="2"><li>阿里云控制台 → 产品与服务 → 对象存储OSS → Bucket列表 → 创建Bucket</li></ol><p><img src="/images/typora/8ed58ed0420a54f887554182918fff89.png" alt="image-20210608221058065"></p><p><img src="/images/typora/eeceb6a2ea941d061136b5272903c68a.png" alt="image-20210608221238617"></p><p><img src="/images/typora/62cbd31e5451f45a59a742a6f67923f9.png" alt="image-20210608221615157"></p><ol start="3"><li>设置Bucket</li></ol><p>注意：==Bucket名称只允许小写字母、数字、短横线（-），且不能以短横线开头或结尾==</p><p>参考配置如下</p><p><img src="/images/typora/aef28aba56939af984814999e7a4143a.png" alt="image-20210608222628067"></p><p><img src="/images/typora/45bfb1cb087a51db966e4757245b95ad.png" alt="image-20210608222702498"></p><p>几点注意事项</p><ul><li><p>Bucket名称 （配置iPic需要用到）</p></li><li><p>Endpoint的地址（配置IPic需要用到）</p></li><li><p>选择公共读</p></li><li><p>存储类型和空间，按需购买设置</p></li></ul><ol start="4"><li>创建子用户 AccessKey</li></ol><p>控制台 → AccessKey管理 →  开始使用子用户AccessKey</p><p><img src="/images/typora/ff281bbe2b5d1a13dc1e716547475df5.png" alt="image-20210608223424628"></p><p><img src="/images/typora/5ca60c7023d1f76f4dd8c1487decaf92.png" alt="image-20210608223531105"></p><p><img src="/images/typora/66222d3ad71eb201afe94dec7c019513.png" alt="image-20210608223714196"></p><p><img src="/images/typora/59e903925fffbcd7e796836c1992b271.png" alt="image-20210608224031312"></p><p>注意：==创建成功后，弹出下图信息，这里的AccessKey Secret只显示一次，自己备份下来==</p><p><img src="/images/typora/6fda52202188674125147a2e2d4a1a89.png" alt="image-20210608224320023"></p><p>如果一不小心手抖了，将网页切走了，可以到 控制台 → AccessKey管理 → 继续使用AccessKey  → 继续使用子用户 → 输入手机号 → 复制AccessKeyId和AccessKey</p><p><img src="/images/typora/f7d6c20b645a17d2890c66cb4b4303f1.png" alt="image-20210608225751486"></p><ol start="5"><li>给刚创建的用户添加管理OSS权限</li></ol><p><img src="/images/typora/1c224b3268ed7d5d1cae730e04a154c0.png" alt="image-20210608224612077"></p><p><img src="/images/typora/c1f65468adb03d53a02cd2bca72ecf52.png" alt="image-20210608224737786"></p><p>如此，阿里云OSS准备工作完成。</p><h3 id="5-5-2-iPic添加阿里云Oss"><a href="#5-5-2-iPic添加阿里云Oss" class="headerlink" title="5.5.2 iPic添加阿里云Oss"></a>5.5.2 iPic添加阿里云Oss</h3><p>前往商店下载IPic即可，这里主要说下如何设置阿里云OSS</p><p>iPic → 偏好设置 → 图床 → + → 选择阿里云OSS</p><p><img src="/images/typora/3681e062c093958e8c09f07e08ebddb7.png" alt="image-20210608230359850"></p><ul><li>Bucket 就是我们设置Bucket名称</li><li>AccessKey 就是上面得到的AccessID</li><li>Secret Key 就是上面得到的AccessKey Secret</li><li>网址前缀设置如下，点击==验证==即可检验信息是否填写正确</li></ul><p><img src="/images/typora/e85b9d7caa9b777f95f72357076f88b0.png" alt="image-20210608231346370"></p><h3 id="5-5-3-Typora设置图片上传位置"><a href="#5-5-3-Typora设置图片上传位置" class="headerlink" title="5.5.3 Typora设置图片上传位置"></a>5.5.3 Typora设置图片上传位置</h3><p>偏好设置 → 图像 → 插入图片时上传图片</p><p><img src="/images/typora/53af09a5d6787972f8c14104ec201375.png" alt="image-20210608231745977"></p><p>注意<span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li>勾选 对于网络位置/本地位置的图片应用上述规则，即上传</li><li>头癣允许根据YAML设置自动上传图片</li><li>选择使用iPic上传</li></ul><p>如此，Typora就会将图片自动上传至阿里云</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
