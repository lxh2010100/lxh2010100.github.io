<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>华仔の小站</title>
  
  <subtitle>积土成山 积水成渊</subtitle>
  <link href="http://luxihua.space/atom.xml" rel="self"/>
  
  <link href="http://luxihua.space/"/>
  <updated>2024-02-03T04:59:48.966Z</updated>
  <id>http://luxihua.space/</id>
  
  <author>
    <name>一只不停游泳的鱼儿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://luxihua.space/blog/0.html"/>
    <id>http://luxihua.space/blog/0.html</id>
    <published>2024-02-03T04:59:48.966Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<p>ltp测试</p><p>环境： ubuntu 22.4</p><ol><li>下载ltp</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/linux-test-project/ltp.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>安装依赖</li></ol><p>对于可选的库依赖项，请查看 <code>ci/</code> 目录中主要发行版的脚本。您还可以使用 <code>./build.sh</code> 脚本构建整个 LTP</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ci/<span class="token function">sudo</span> ./ubuntu.sh <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>配置</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~/Desktop/github/ltp <span class="token comment"># make autotools</span>autoheader<span class="token function">make</span> <span class="token parameter variable">-C</span> testcases/realtime autotoolsmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/jack/Desktop/github/ltp/testcases/realtime'</span>autoheadermake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/jack/Desktop/github/ltp/testcases/realtime'</span><span class="token function">make</span> <span class="token parameter variable">-C</span> testcases/open_posix_testsuite autotoolsmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/jack/Desktop/github/ltp/testcases/open_posix_testsuite'</span>make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Nothing to be <span class="token keyword">done</span> <span class="token keyword">for</span> <span class="token string">'autotools'</span><span class="token builtin class-name">.</span>make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/jack/Desktop/github/ltp/testcases/open_posix_testsuite'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span><span class="token environment constant">$PWD</span>/_install_ltp_x86_x64 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>运行</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> _install_ltp_x86_x64/<span class="token function">sudo</span> ./runltp <span class="token parameter variable">-f</span> syscalls <span class="token comment">#运行所有syscalls</span><span class="token function">sudo</span> ./runltp <span class="token parameter variable">-f</span> syscalls <span class="token parameter variable">-g</span> syscalls.html <span class="token comment">#生成html报告</span><span class="token function">sudo</span> ./runltp <span class="token parameter variable">-s</span> <span class="token builtin class-name">exit</span> <span class="token parameter variable">-g</span> exit_report.html  <span class="token comment"># 运行所有以exit开头的用例</span><span class="token function">sudo</span> ./runltp <span class="token parameter variable">-s</span> exit01 <span class="token parameter variable">-g</span> exit_report.html  <span class="token comment"># 运行以exit01开头的用例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ltp测试&lt;/p&gt;
&lt;p&gt;环境： ubuntu 22.4&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载ltp&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;lang</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luxihua.space/blog/0.html"/>
    <id>http://luxihua.space/blog/0.html</id>
    <published>2024-02-03T04:59:48.966Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><h3 id="1、Makefile-是什么"><a href="#1、Makefile-是什么" class="headerlink" title="1、Makefile 是什么"></a>1、Makefile 是什么</h3><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，那些文件需要后编译，那些文件需要重新编译，甚至于进行更复杂的功能操作。</p><p>【百度百科 <a href="https://baike.baidu.com/item/Makefile/4619787">https://baike.baidu.com/item/Makefile/4619787</a> 】</p><h3 id="2、make-与-Makefile-的关系"><a href="#2、make-与-Makefile-的关系" class="headerlink" title="2、make 与 Makefile 的关系"></a>2、make 与 Makefile 的关系</h3><p>make是一个命令工具，他解释Makefile中的指令。在Makefile文件中描述了整个工程所有文件的编译顺序、编译规则。</p><h3 id="3、Makefile-命名规则"><a href="#3、Makefile-命名规则" class="headerlink" title="3、Makefile 命名规则"></a>3、Makefile 命名规则</h3><p>Makefile或makefile，一般使用Makefile。</p><h3 id="4、Cmake-又是什么"><a href="#4、Cmake-又是什么" class="headerlink" title="4、Cmake 又是什么"></a>4、Cmake 又是什么</h3><p>Cmake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装（<a href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B&amp;spm=1001.2101.3001.7020">编译过程</a>）。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性，类似UNIX下的automake。只是Cmake的组态档取名为CMakeList.txt。Cmake并不直接构建出最终的软件，而是产生标准的建构档（如UNIX的Makefile或Windows Visual C++ 的projects/workspaces），然后再依一般的建构方式使用。</p><p>【百度百科 <a href="https://baike.baidu.com/item/cmake/7138032">https://baike.baidu.com/item/cmake/7138032</a> 】</p><h3 id="5、Cmake-与-CMakeLists-的关系"><a href="#5、Cmake-与-CMakeLists-的关系" class="headerlink" title="5、Cmake 与 CMakeLists 的关系"></a>5、Cmake 与 CMakeLists 的关系</h3><p>Cmake是一个命令工具，可用来生成Makefile。但也要根据CMakeLists.txt中的内容来生成，CMakeLists.txt就是写给Cmake的规则。</p><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h3><ul><li><p>make是一个命令工具，Makefile是一个文件，make执行的时候，去读取Makefile文件中的规则，<strong>重点是Makefile需要自己写</strong>。</p></li><li><p>Cmake是一个命令工具，CMakeLists.txt是一个文件，Cmake执行的时候，去读取CMakeLists.txt文件中的规则，<strong>重点是CMakeLists.txt需要自己写</strong>。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/c53af1699c6f47b3886cbffe31d90877.png#pic_center"></p><hr><h2 id="二、从-hello-world-开始"><a href="#二、从-hello-world-开始" class="headerlink" title="二、从 hello world 开始"></a>二、从 hello world 开始</h2><h3 id="1、Makefile-基本语法"><a href="#1、Makefile-基本语法" class="headerlink" title="1、Makefile 基本语法"></a>1、Makefile 基本语法</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">目标</span><span class="token punctuation">:</span>依赖Tab 命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>目标：一般是指要编译的目标，也可以是一个动作</li><li>依赖：指执行当前目标所要依赖的先项，包括其他目标，某个具体文件或库等。<strong>一个目标可以有多个依赖</strong></li><li>命令：该目标下要执行的具体命令，可以没有，也可以多条。<strong>多条时，每条命令一行</strong></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#命令前加@，抑制命令本身输出</span><span class="token target symbol">a</span><span class="token punctuation">:</span>b<span class="token operator">@</span>echo <span class="token string">"hello world"</span><span class="token comment">#输出hello world</span><span class="token operator">@</span>ls ./<span class="token comment">#查看当前目录下文件</span>gcc -lstdc++ main.cpp<span class="token comment">#编译源文件</span><span class="token target symbol">b</span><span class="token punctuation">:</span><span class="token operator">@</span>echo <span class="token string">"hello world!"</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token operator">@</span>rm -rf a.out<span class="token comment">#清除编译后产生的.out文件</span><span class="token operator">@</span>echo <span class="token string">"make clean success"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、make-常用选项"><a href="#2、make-常用选项" class="headerlink" title="2、make 常用选项"></a>2、make 常用选项</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make<span class="token punctuation">[</span>-f file<span class="token punctuation">]</span><span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>make默认在当前目录中寻找GNUmakefile，makefile，Makefile的文件作为make的输入文件</p><ul><li><pre><code class="shell">-f 可以指定除上述文件名之外的文件作为输入文件<pre class="line-numbers language-none"><code class="language-none">    *   ```shell    -v 显示版本号    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><pre><code class="shell">-n 只输出命令，但不执行，一般用来测试<pre class="line-numbers language-none"><code class="language-none">    *   ```shell    -s 只执行命令，但不显示具体命令，此处可在命令中用@抑制命令输出    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><p>```shell<br>-w 显示执行前执行后的路径</p><pre class="line-numbers language-none"><code class="language-none">    *   ```shell    -C dir 指定makeflie所在的目录    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="3、gcc-x2F-g-编译流程"><a href="#3、gcc-x2F-g-编译流程" class="headerlink" title="3、gcc/g++ 编译流程"></a>3、gcc/g++ 编译流程</h3><ul><li>源文件</li></ul><p><img src="https://img-blog.csdnimg.cn/25f247493d264f3b9d56cf77eb838b04.png#pic_center"></p><pre class="line-numbers language-none"><code class="language-none">`#这样执行不太好，全部编译耗时长#calc:#gcc add.cpp sub.cpp multi.cpp calc.cpp -o calc#这样分开来写，保证只编译有改动的代码，耗时短calc:add.o sub.o multi.ogcc add.o sub.o multi.o calc.cpp -o calcadd.o:add.cppgcc -c add.cpp -o add.osub.o:sub.cppgcc -c sub.cpp -o sub.omulti.o:multi.cppgcc -c multi.cpp -o multi.o` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>直接从源代码到目标可执行文件</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -lstdc++ main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="三、Makefile-中的变量"><a href="#三、Makefile-中的变量" class="headerlink" title="三、Makefile 中的变量"></a>三、Makefile 中的变量</h2><h3 id="1、系统变量"><a href="#1、系统变量" class="headerlink" title="1、系统变量"></a>1、系统变量</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$*</span> <span class="token comment">#不包括扩展名的目标文件名称</span><span class="token variable">$+</span> <span class="token comment">#所有的依赖文件，以空格分隔</span><span class="token variable">$&lt;</span> <span class="token comment">#表示规则中的第一个条件</span><span class="token variable">$?</span> <span class="token comment">#所有时间戳比目标文件晚的依赖文件，以空格分隔</span><span class="token variable">$@</span> <span class="token comment">#目标文件的完整名称</span><span class="token variable">$^</span> <span class="token comment">#所有不重复的依赖文件，以空格分隔</span><span class="token variable">$%</span> <span class="token comment">#如果目标是归档成员，则该变量表示目标的归档成员名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">`calc:add.o sub.o multi.o calc.ogcc $^ -o $@add.o:add.cppgcc -c $^ -o $@sub.o:sub.cppgcc -c $^ -o $@multi.o:multi.cppgcc -c $^ -o $@calc.o:calc.cppgcc -c $^ -o $@clean:rm -f *.o calc` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、系统常量（可用-make-p-查看）"><a href="#2、系统常量（可用-make-p-查看）" class="headerlink" title="2、系统常量（可用 make -p 查看）"></a>2、系统常量（可用 make -p 查看）</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">AS<span class="token comment">#汇编程序的名称，默认为as</span>CC<span class="token comment">#C编译器名称，默认为cc</span>CPP<span class="token comment">#C预编译器名称，默认为cc -E</span>CXX<span class="token comment">#C++编译器名称，默认为g++</span>RM<span class="token comment">#文件删除程序别名，默认rm -f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">`#$(CC)可替换为$(CXX)，因为$(CXX)可实现跨平台calc:add.o sub.o multi.o calc.o$(CC) add.o sub.o multi.o calc.o -o calcadd.o:add.cpp$(CC) -c add.cpp -o add.osub.o:sub.cpp$(CC) -c sub.cpp -o sub.omulti.o:multi.cpp$(CC) -c multi.cpp -o multi.ocalc.o:calc.cpp$(CC) -c calc.cpp -o calc.oclean:$(RM) *.o calc` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、自定义变量"><a href="#3、自定义变量" class="headerlink" title="3、自定义变量"></a>3、自定义变量</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">定义：变量名<span class="token operator">=</span>变量值使用：<span class="token variable">$</span><span class="token punctuation">(</span>变量名<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">{</span>变量名<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">`OBJ = add.o sub.o multi.o calc.oTARGET = calc$(TARGET):$(OBJ)gcc $(OBJ) -o $(TARGET)add.o:add.cppgcc -c add.cpp -o add.osub.o:sub.cppgcc -c sub.cpp -o sub.omulti.o:multi.cppgcc -c multi.cpp -o multi.ocalc.o:calc.cppgcc -c calc.cpp -o calc.oclean:rm -f *.o $(TARGET)` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="四、Makefile-中的伪目标和模式匹配"><a href="#四、Makefile-中的伪目标和模式匹配" class="headerlink" title="四、Makefile 中的伪目标和模式匹配"></a>四、Makefile 中的伪目标和模式匹配</h2><h3 id="1、伪目标"><a href="#1、伪目标" class="headerlink" title="1、伪目标"></a>1、伪目标</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>目标<span class="token comment">#声明目标为伪目标之后，makefile将不会判断目标是否存在或该目标是否需要更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>如果项目路径中有与<strong>clean</strong>同名的文件，**<code>make clean</code><strong>命令无法执行，需要在</strong>makefile<strong>文件中添加</strong><code>.PHONY:clean</code>**，才能使命令正常执行</li></ul><pre class="line-numbers language-none"><code class="language-none">`.PHONY:cleanOBJ = add.o sub.o multi.o calc.oTARGET = calc$(TARGET):$(OBJ)gcc $(OBJ) -o $(TARGET)add.o:add.cppgcc -c add.cpp -o add.osub.o:sub.cppgcc -c sub.cpp -o sub.omulti.o:multi.cppgcc -c multi.cpp -o multi.ocalc.o:calc.cppgcc -c calc.cpp -o calc.oclean:rm -f *.o $(TARGET)` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、模式匹配"><a href="#2、模式匹配" class="headerlink" title="2、模式匹配"></a>2、模式匹配</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">%目标</span><span class="token punctuation">:</span>%依赖<span class="token comment">#目标和依赖相同部分，可以用%来通配</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>依赖中的**<code>add.o sub.o multi.o calc.o</code><strong>都可以通过使用</strong><code>%.o:%.cpp</code>**产生</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">OBJ <span class="token operator">=</span> add.o sub.o multi.o calc.oTARGET <span class="token operator">=</span> calc<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.cppgcc -c <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -f *.o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="makefile-内置函数"><a href="#makefile-内置函数" class="headerlink" title="- makefile 内置函数"></a>- makefile 内置函数</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> 文件列表<span class="token punctuation">)</span><span class="token comment">#获取对应文件路径下的对应模式的文件名</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> 源模式, 目标模式, 文件列表<span class="token punctuation">)</span><span class="token comment">#将文件列表中想要改变的源模式替换成想要的目标模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong><code>$(wildcard ./*.cpp)</code><strong>获取当前目录下所有的</strong>.cpp</strong>文件名</li><li><strong><code>$(patsubst %.cpp, %.o, $(wildcard ./*.cpp))</code><strong>将对应的</strong>.cpp</strong>文件替换为**.o**文件</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#OBJ = add.o sub.o multi.o calc.o</span>OBJ <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.cpp, %.o, <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ./*.cpp<span class="token punctuation">)</span><span class="token punctuation">)</span>TARGET <span class="token operator">=</span> calc<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.cppgcc -c <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -f *.o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="五、Makefile-运行流程"><a href="#五、Makefile-运行流程" class="headerlink" title="五、Makefile 运行流程"></a>五、Makefile 运行流程</h2><p><img src="https://img-blog.csdnimg.cn/5f2ceadab86b4b17b911e81fc95a5d0e.png#pic_center"></p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">calc</span><span class="token punctuation">:</span>add.o sub.o multi.ogcc add.o sub.o multi.o calc.cpp -o calc<span class="token target symbol">add.o</span><span class="token punctuation">:</span>add.cppgcc -c add.cpp -o add.o<span class="token target symbol">sub.o</span><span class="token punctuation">:</span>sub.cppgcc -c sub.cpp -o sub.o<span class="token target symbol">multi.o</span><span class="token punctuation">:</span>multi.cppgcc -c multi.cpp -o multi.o<span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -f *.o calc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>代码执行流程如上图所示</li><li>保证目标是用<strong>最新</strong>的依赖生成的</li><li>第一次<strong>完全编译</strong>，后面只编译最新的代码（<strong>部分编译</strong>）</li></ul><hr><h2 id="六、Makefile-中编译动态链接库"><a href="#六、Makefile-中编译动态链接库" class="headerlink" title="六、Makefile 中编译动态链接库"></a>六、Makefile 中编译<a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93&amp;spm=1001.2101.3001.7020">动态链接库</a></h2><p>动态链接库：不会把代码编译到二进制文件中，而是在运行时才去加载，所以需要维护一个地址</p><ul><li><strong>动态</strong>：动态加载，运行时才加载</li><li><strong>链接</strong>：指库文件和二进制程序分离，用某种手段维护两者之间的关系</li><li><strong>库</strong>：库文件<ul><li><strong>Windows</strong> 中后缀为 <strong>.dll</strong></li><li><strong>Linux</strong> 中后缀为 <strong>.so</strong></li></ul></li><li><strong>常用选项</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-fPIC</span> 产生位置无关的代码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-shared</span> 共享<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-l</span> 指定动态库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-I</span> 指定头文件目录，默认当前目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-L</span> 手动指定库文件搜索目录，默认只链接共享目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>程序可以和库文件分离，可以分别发版，然后库文件可以被多处共享</p><hr><h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><h4 id="发布前："><a href="#发布前：" class="headerlink" title="发布前："></a>发布前：</h4><h5 id="soTest-h"><a href="#soTest-h" class="headerlink" title="soTest.h"></a>soTest.h</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class soTest{public:    void func1();    virtual void func2();    virtual void func3() = 0;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="soTest-cpp"><a href="#soTest-cpp" class="headerlink" title="soTest.cpp"></a>soTest.cpp</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include "soTest.h"void sotest::func1(){    printf("func1\n");}void sotest::func2(){    printf("func2\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-shared</span> <span class="token parameter variable">-fPIC</span> soTest.cpp <span class="token parameter variable">-o</span> libSoTest.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>soTest.cpp</strong>编译后会产生<strong>libsoTest.so</strong>，不用担心文件名不同会出现问题，在后续引用中，<strong>lib</strong>自动会被丢弃</li></ul><h5 id="Test-cpp"><a href="#Test-cpp" class="headerlink" title="Test.cpp"></a>Test.cpp</h5><pre class="line-numbers language-none"><code class="language-none">`#include &lt;iostream&gt;#include "soTest.h"class Test:public soTest{public:    void func2(){        printf("Test-func2\n");    }    void func3(){        printf("Test-func3\n");    }};int main(){    Test t1;    t1.func1();    t1.func2();    t1.func3();        return 0;}` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-lsoTest</span> -L./ Test.cpp <span class="token parameter variable">-o</span> Test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>指定动态库文件<strong>soTest</strong>，编译后由<strong>Test.cpp</strong>文件产生<strong>Test.o</strong>文件</li></ul><h4 id="项目发布："><a href="#项目发布：" class="headerlink" title="项目发布："></a>项目发布：</h4><h5 id="soTest-h-1"><a href="#soTest-h-1" class="headerlink" title="soTest.h"></a>soTest.h</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class soTest{public:    void func1();    virtual void func2();    virtual void func3() = 0;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h5><pre class="line-numbers language-none"><code class="language-none">`#include &lt;iostream&gt;#include "soTest.h"class MainTest:public soTest{public:    void func2(){        printf("MainTest-func2\n");    }    void func3(){        printf("MainTest-func3\n");    }};int main(){    MainTest t1;    t1.func1();    t1.func2();    t1.func3();        return 0;}` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-lsoTest</span> -L./001 main.cpp <span class="token parameter variable">-o</span> main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>编译时指定了要依赖的动态库，但运行时，会无法找到**.so**文件</li></ul><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul><li><p>将<a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E5%BA%93&amp;spm=1001.2101.3001.7020">动态库</a>文件移动到<strong>main.cpp</strong>文件同级目录下</p></li><li><p>运行时手动指定动态库文件所在目录</p><p><strong>Linux</strong>环境下的命令</p><ul><li><p>```shell<br>LD_LIBRARY_PATH = ./001</p><pre class="line-numbers language-none"><code class="language-none">    *   ```shell    export LD_LIBRARY_PATH    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h5 id="001-x2F-Makefile"><a href="#001-x2F-Makefile" class="headerlink" title="001/Makefile"></a>001/Makefile</h5><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">Test</span><span class="token punctuation">:</span>libsoTest.so<span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> -lsoTest -L./ Test.cpp -o Testcp libsoTest.so /usr/lib  <span class="token comment">#路径最好为main.cpp同级目录</span><span class="token target symbol">libsoTest.so</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> -shared -fPIC soTest.cpp -o libsoTest.so<span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> *.so Test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>cp libsoTest.so /usr/lib</code>将动态库文件复制到动态链接库默认路径下 <strong>不推荐复制，污染原库环境</strong></p></li><li><p><strong>Linux</strong> 默认动态库路径配置文件</p><ul><li>/etc/ld.so.conf</li><li>/etc/ld.so.conf.d/*.conf</li></ul></li></ul><hr><h2 id="七、Makefile-中编译静态链接库"><a href="#七、Makefile-中编译静态链接库" class="headerlink" title="七、Makefile 中编译静态链接库"></a>七、Makefile 中编译静态链接库</h2><p>静态链接库：会把库中的代码编译到二进制文件中，当程序编译完成后，该库文件可以删除</p><ul><li><strong>Windows</strong> 中后缀为 <strong>.lib</strong></li><li><strong>Linux</strong> 中后缀为 <strong>.a</strong></li></ul><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>运行时速度快（不用去加载库文件）</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>程序体积更大，并且库中的内容如果有更新，则需要重新编译生成程序</p><h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><ul><li>动态链接库必须与程序同时部署，还要保证程序能加载得到库文件</li><li>静态链接库可以不用部署（已经被加载到程序里面了）</li></ul><hr><h3 id="例：-1"><a href="#例：-1" class="headerlink" title="例："></a>例：</h3><h4 id="发布前：-1"><a href="#发布前：-1" class="headerlink" title="发布前："></a>发布前：</h4><h5 id="aTest-h"><a href="#aTest-h" class="headerlink" title="aTest.h"></a>aTest.h</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class aTest{public:    void func1();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="aTest-cpp"><a href="#aTest-cpp" class="headerlink" title="aTest.cpp"></a>aTest.cpp</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include "aTest.h"void aTest::func1(){    printf("aTest-func1\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-c</span> aTest.cpp <span class="token parameter variable">-o</span> aTest.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>aTest.cpp</strong>编译后会产生<strong>libaTest.a</strong>，不用担心文件名不同会出现问题，在后续引用中，<strong>lib</strong>自动会被丢弃</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ar <span class="token parameter variable">-r</span> libaTest.a aTest.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将<strong>aTest.o</strong>加入到<strong>libaTest.a</strong>中。默认的加入方式为append，即<strong>加在库的末尾</strong>。</li></ul><h4 id="项目发布：-1"><a href="#项目发布：-1" class="headerlink" title="项目发布："></a>项目发布：</h4><h5 id="aTest-h-1"><a href="#aTest-h-1" class="headerlink" title="aTest.h"></a>aTest.h</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class aTest{public:    void func1();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="main-cpp-1"><a href="#main-cpp-1" class="headerlink" title="main.cpp"></a>main.cpp</h5><pre class="line-numbers language-none"><code class="language-none">`#include &lt;iostream&gt;#include "soTest.h"#include "aTest.h"class MainTest:public soTest{public:    void func2(){        printf("MainTest-func2\n");    }    void func3(){        printf("MainTest-func3\n");    }};int main(){    MainTest t1;    t1.func1();    t1.func2();    t1.func3();        printf("\n\n");        aTest t2;    t2.func1();        return 0;}` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21*   22*   23*   24*   25*   26*   27<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-lsoTest</span> -L./001 <span class="token parameter variable">-laTest</span> -L./002 main.cpp <span class="token parameter variable">-o</span> main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>指定动态库文件<strong>soTest</strong>和静态库文件<strong>aTest</strong>，编译后由<strong>main.cpp</strong>文件产生<strong>main.o</strong>文件</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">objdump <span class="token parameter variable">-DC</span> main<span class="token operator">&gt;</span>main.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>会生成一个类似于反汇编的文本文档，进入搜索可以找到<strong>aTest::func1()</strong> 的定义，但只能找到<strong>soTest::func1()<strong>、</strong>soTest::func2()<strong>、</strong>soTest::func3()</strong> 的引用</li></ul><h5 id="002-x2F-Makefile"><a href="#002-x2F-Makefile" class="headerlink" title="002/Makefile"></a>002/Makefile</h5><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">libaTest</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> -c aTest.cpp -o aTest.o<span class="token variable">$</span><span class="token punctuation">(</span>AR<span class="token punctuation">)</span> -r libaTest.a aTest.o<span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> *.o *.a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h5><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> mainLDFLAGS <span class="token operator">=</span> -L./001 -L./002LIBS <span class="token operator">=</span> -lsoTest -laTest<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LIBS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> main.cpp -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="八、Makefile-中通用部分做公共文件头"><a href="#八、Makefile-中通用部分做公共文件头" class="headerlink" title="八、Makefile 中通用部分做公共文件头"></a>八、Makefile 中通用部分做公共文件头</h2><h3 id="例：-2"><a href="#例：-2" class="headerlink" title="例："></a>例：</h3><h4 id="003-x2F-a-cpp"><a href="#003-x2F-a-cpp" class="headerlink" title="003/a.cpp"></a>003/a.cpp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;void func_a(){printf("func-a.cpp");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="003-x2F-b-cpp"><a href="#003-x2F-b-cpp" class="headerlink" title="003/b.cpp"></a>003/b.cpp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;void func_b(){printf("func-b.cpp");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="003-x2F-c-cpp"><a href="#003-x2F-c-cpp" class="headerlink" title="003/c.cpp"></a>003/c.cpp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">extern void func_a();extern void func_b();int main(){func_a();    func_b();        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="003-x2F-Makefile"><a href="#003-x2F-Makefile" class="headerlink" title="003/Makefile"></a>003/Makefile</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> c<span class="token keyword">include</span> ../makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h4 id="004-x2F-x-c"><a href="#004-x2F-x-c" class="headerlink" title="004/x.c"></a>004/x.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">func_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func-x.c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="004-x2F-y-c"><a href="#004-x2F-y-c" class="headerlink" title="004/y.c"></a>004/y.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">func_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func-y.c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="004-x2F-z-c"><a href="#004-x2F-z-c" class="headerlink" title="004/z.c"></a>004/z.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">func_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">func_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">func_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="004-x2F-Makefile"><a href="#004-x2F-Makefile" class="headerlink" title="004/Makefile"></a>004/Makefile</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> z<span class="token keyword">include</span> ../makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">SOURCE <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ./*.cpp ./*.C<span class="token punctuation">)</span>OBJ <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.cpp, %.o, <span class="token variable">$</span><span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span><span class="token punctuation">)</span>OBJ <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c, %.o, <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>clean<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Makefile</strong> 中，都是先展开所有变量，再调用指令</p><ul><li><strong>=</strong> 赋值，但是用终值，就是不管变量调用写在赋值前还是赋值后，调用时都是取终值</li><li>**:= ** 也是赋值，但是只受当前行及之前的代码影响，而不会受后面的赋值影响</li></ul><hr><h2 id="九、Makefile-中调用-shell-命令"><a href="#九、Makefile-中调用-shell-命令" class="headerlink" title="九、Makefile 中调用 shell 命令"></a>九、Makefile 中调用 shell 命令</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">FILE <span class="token operator">=</span> abcA <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> ls ../<span class="token punctuation">)</span>B <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>C <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> if [ ! -f <span class="token variable">$</span><span class="token punctuation">(</span>FILE<span class="token punctuation">)</span> ]<span class="token punctuation">;</span> then touch <span class="token variable">$</span><span class="token punctuation">(</span>FILE<span class="token punctuation">)</span><span class="token punctuation">;</span> fi<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token target symbol">a</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>FILE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>$(shell ls ../)</code> 列出上级目录中的所有目录</li><li><code>$(shell pwd)</code> 显示当前所在工作目录的绝对路径</li><li><code>$(shell if [ ! -f $(FILE) ]; then touch $(FILE); fi;)</code> 判断文件是否存在</li></ul><hr><h2 id="十、Makefile-中的嵌套调用和多项目同时编译"><a href="#十、Makefile-中的嵌套调用和多项目同时编译" class="headerlink" title="十、Makefile 中的嵌套调用和多项目同时编译"></a>十、Makefile 中的嵌套调用和多项目同时编译</h2><h3 id="例：-3"><a href="#例：-3" class="headerlink" title="例："></a>例：</h3><p>源文件为 <strong><code>八、Makefile 中通用部分做公共文件头</code></strong> 中的例子用到的</p><ul><li><strong>makefile</strong> 更名为 <strong>makefile-head</strong></li><li><strong>003/Makefile</strong>、<strong>004/Makefile</strong> 中的 <code>include ../makefile</code> 改为<code>include ../makefile-head</code></li><li>新建的<strong>Makefile</strong> 与 <strong>makefile-head</strong> 在同一级目录下</li></ul><h4 id="Makefile-1"><a href="#Makefile-1" class="headerlink" title="Makefile"></a>Makefile</h4><ul><li><strong>v1</strong></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>make -C ./003make -c ./004<span class="token target symbol">clean</span><span class="token punctuation">:</span>make -C ./003 cleanmake -C ./004 clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>v2</strong></li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>003 004 DIR <span class="token operator">=</span> 003 004<span class="token target symbol">all</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>DIR<span class="token punctuation">)</span><span class="token target symbol"><span class="token variable">$</span>(DIR)</span><span class="token punctuation">:</span>make -C <span class="token variable">$@</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> for dir in <span class="token variable">$</span><span class="token punctuation">(</span>DIR<span class="token punctuation">)</span><span class="token punctuation">;</span> do make -C <span class="token variable">$$dir</span> clean<span class="token punctuation">;</span> done<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="十一、Makefile-中的条件判断"><a href="#十一、Makefile-中的条件判断" class="headerlink" title="十一、Makefile 中的条件判断"></a>十一、Makefile 中的条件判断</h2><ul><li><strong>ifeq</strong> 判断是否相等，相等返回 <strong>true</strong>，不相等返回 <strong>false</strong></li><li><strong>ifneq</strong> 判断是否不相等，不相等返回 <strong>true</strong>，相等返回 <strong>false</strong></li><li><strong>ifdef</strong> 判断变量是否存在，存在返回 <strong>true</strong>，不存在返回 <strong>false</strong></li><li><strong>ifndef</strong> 判断变量是否不存在，不存在返回 <strong>true</strong>，存在返回 <strong>false</strong></li></ul><h3 id="例"><a href="#例" class="headerlink" title="例:"></a>例:</h3><h4 id="Makefile-2"><a href="#Makefile-2" class="headerlink" title="Makefile"></a>Makefile</h4><pre class="line-numbers language-none"><code class="language-none">`A := 123RS1 :=RS2 :=RS3 :=RS4 :=ifeq ($(A), 123)RS1 := RS1-yeselseRS1 := RS1-noendififneq ($(A), 123)RS2 := RS2-yeselseRS2 := RS2-noendififdef ARS3 := RS3-yeselseRS3 := RS3-noendififndef ARS4 := RS4-yeselseRS4 := RS4-noendififdef FLAGFLAG := defaultendifall:echo $(RS1)echo $(RS2)echo $(RS3)echo $(RS4)echo flag = $(FLAG)` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19*   20*   21*   22*   23*   24*   25*   26*   27*   28*   29*   30*   31*   32*   33*   34*   35*   36*   37*   38*   39*   40*   41<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>ifeq</strong>、<strong>ifneq</strong>、<strong>ifdef</strong>、<strong>ifndef</strong> 与条件之间要有空格，不然会报错</p></li><li><p>可以只有 <strong>if</strong>，没有 <strong>else</strong></p><ul><li><p>```makefile<br>ifdef FLAG<br>FLAG := default<br>endif</p><pre class="line-numbers language-none"><code class="language-none">        *   没有 **elseif** 的用法，如果要实现 **elseif**，就要写嵌套        *   ```makefile        ifeq ($(A), 321)        RS1 := 321        else        ifeq ($(A), 123)                RS1 := 123            else                RS1 := 0            endif        endif        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>命令行传参</p><ul><li><p>```shell<br>make -f Makefile FLAG=456</p><pre class="line-numbers language-none"><code class="language-none">    *   ```shell        make FLAG=456    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h2 id="十二、Makefile-中的循环"><a href="#十二、Makefile-中的循环" class="headerlink" title="十二、Makefile 中的循环"></a>十二、Makefile 中的循环</h2><h3 id="例：-4"><a href="#例：-4" class="headerlink" title="例："></a>例：</h3><h4 id="Makefile-3"><a href="#Makefile-3" class="headerlink" title="Makefile"></a>Makefile</h4><ul><li><strong>makefile</strong> 中只有一个循环 <strong>foreach</strong>，只支持 <strong>GNU Make</strong>，其他平台的 <strong>make</strong> 需要使用 <strong>shell</strong> 中的循环来实现</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> a b c d<span class="token target symbol">all</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> v, <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>, <span class="token variable">$v</span><span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> v, <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>, <span class="token variable">$v.txt</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>foreach</strong> 可以在循环中逐个的修改值</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">TARGET <span class="token operator">=</span> a b c d<span class="token target symbol">all</span><span class="token punctuation">:</span>touch <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>touch <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> v, <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>, <span class="token variable">$v</span><span class="token punctuation">)</span>touch <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> v, <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>, <span class="token variable">$v.txt</span><span class="token punctuation">)</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> *.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="十三、Makefile-中自定义函数的实现和调用"><a href="#十三、Makefile-中自定义函数的实现和调用" class="headerlink" title="十三、Makefile 中自定义函数的实现和调用"></a>十三、Makefile 中自定义函数的实现和调用</h2><h3 id="例：-5"><a href="#例：-5" class="headerlink" title="例："></a>例：</h3><h4 id="Makefile-4"><a href="#Makefile-4" class="headerlink" title="Makefile"></a>Makefile</h4><ul><li>自定义函数不是真正的函数，本质上是多行命令放在了目标外</li><li>可以传递参数<ul><li><strong>$(0)</strong> 为本身文件名</li><li><strong>( 1 ) ∗ ∗ 为要接受的参数 ∗ ∗ (1)</strong> 为要接受的参数 ** (1)∗∗为要接受的参数∗∗(A)**</li><li><strong>$(2)</strong> 为要接受的参数 <strong>asd</strong></li></ul></li><li>没有返回值<ul><li><strong>( c a l l F U N C 2 ) ∗ ∗ 会报错，可以在 ∗ ∗ (call FUNC2)</strong> 会报错，可以在 ** (callFUNC2)∗∗会报错，可以在∗∗(call FUNC2)** 前加 <strong><code>echo</code></strong> 命令，将 <strong>return</strong> 当作一个字符串，和 <strong>123</strong> 一起输出</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">`A := 123define FUNC1echo funcecho $(0) $(1) $(2)endefdefine FUNC2return 123endefdefine FUNC3echo $(shell ls)endefall:$(call FUNC1, $(A), asd)$(call FUNC2)$(call FUNC3)` ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)*   1*   2*   3*   4*   5*   6*   7*   8*   9*   10*   11*   12*   13*   14*   15*   16*   17*   18*   19<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="十四、make-install-的实现"><a href="#十四、make-install-的实现" class="headerlink" title="十四、make install 的实现"></a>十四、make install 的实现</h2><ul><li><p><strong>make</strong></p><ul><li>将源文件编译成二进制可执行文件（包括各种库文件）</li></ul></li><li><p><strong>make install</strong></p><ul><li><p>创建目录，将可执行文件拷贝到指定目录（安装目录）</p></li><li><p>加全局可执行的路径</p></li><li><p>加全局的启停脚本</p></li></ul></li><li><p><strong>make clean</strong></p><ul><li>重置编辑环境，删除无关文件</li></ul></li></ul><h3 id="例：-6"><a href="#例：-6" class="headerlink" title="例："></a>例：</h3><h4 id="main-cpp-2"><a href="#main-cpp-2" class="headerlink" title="main.cpp"></a>main.cpp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unistd.h&gt;using namespace std;int main(){    int i = 0;    while (true){i++;        cout&lt;&lt;"main-running-"&lt;&lt;i&lt;&lt;endl;        sleep(1);    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Makefile-5"><a href="#Makefile-5" class="headerlink" title="Makefile"></a>Makefile</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">MYPATH <span class="token operator">:=</span> /test/main/BIN <span class="token operator">:=</span> /usr/local/bin/START_S <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>_startSTOP_S <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>_stopLOG <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.logTARGET <span class="token operator">:=</span> mainOBJ <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.oCC <span class="token operator">=</span> g++<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span class="token target symbol">install</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>if [ -d <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span> ]<span class="token punctuation">;</span>\then echo <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span> exist<span class="token punctuation">;</span>\<span class="token keyword">else</span>\    mkdir <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>\cp <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>\ln -sv <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token punctuation">;</span>\touch <span class="token variable">$</span><span class="token punctuation">(</span>LOG<span class="token punctuation">)</span><span class="token punctuation">;</span>\chmod a+rwx <span class="token variable">$</span><span class="token punctuation">(</span>LOG<span class="token punctuation">)</span><span class="token punctuation">;</span>\echo <span class="token string">"$(TARGET)&gt;$(LOG) &amp; echo $(TARGET) running..."</span>&gt;<span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>START_S<span class="token punctuation">)</span><span class="token punctuation">;</span>\echo <span class="token string">"killall $(TARGET)"</span>&gt;<span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>STOP_S<span class="token punctuation">)</span><span class="token punctuation">;</span>\chmod a+x <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>START_S<span class="token punctuation">)</span><span class="token punctuation">;</span>\chmod a+x <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>STOP_S<span class="token punctuation">)</span><span class="token punctuation">;</span>\ln -sv <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>START_S<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token punctuation">;</span>\ln -sv <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>STOP_S<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token punctuation">;</span>\fi<span class="token punctuation">;</span><span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>START_S<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>STOP_S<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> -rf <span class="token variable">$</span><span class="token punctuation">(</span>MYPATH<span class="token punctuation">)</span><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>clean install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>判断对应路径下是否存在<ul><li>存在<ul><li>输出路径存在</li></ul></li><li>不存在<ul><li>创建一个与路径相同的目录</li><li>把可执行文件复制到对应目录下</li><li>为该文件在某一位置创建一个同步的软链接，即全局可执行路径</li><li>在目录下创建一个日志文件并增加权限</li><li>在目录下创建启停脚本，增加权限，并创建一个同步的软链接</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、相关概念&quot;&gt;&lt;a href=&quot;#一、相关概念&quot; class=&quot;headerlink&quot; title=&quot;一、相关概念&quot;&gt;&lt;/a&gt;一、相关概念&lt;/h2&gt;&lt;h3 id=&quot;1、Makefile-是什么&quot;&gt;&lt;a href=&quot;#1、Makefile-是什么&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Shell脚本学习02--运算符</title>
    <link href="http://luxihua.space/blog/c67b5973.html"/>
    <id>http://luxihua.space/blog/c67b5973.html</id>
    <published>2024-02-03T04:59:48.966Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell运算符"><a href="#Shell运算符" class="headerlink" title="Shell运算符"></a>Shell运算符</h2><p>Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><p><code>expr</code> 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 命令行直接计算</span><span class="token function">expr</span> <span class="token number">2</span> + <span class="token number">2</span>   <span class="token comment">#4</span><span class="token function">expr</span> <span class="token number">3</span> - <span class="token number">2</span>   <span class="token comment">#1</span><span class="token function">expr</span> <span class="token number">3</span> / <span class="token number">2</span>   <span class="token comment">#1</span><span class="token function">expr</span> <span class="token number">3</span> <span class="token punctuation">\</span>* <span class="token number">2</span>   <span class="token comment">#6</span><span class="token comment"># 使用表达式</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a + $b<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token string">"a + b : <span class="token variable">$val</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li><strong>表达式和运算符之间要有空格</strong>，例如 <code>2+2</code> 是不对的，必须写成 <code>2 + 2</code>，这与我们熟悉的大多数编程语言不一样。</li><li>乘号(*)前边必须加反斜杠()才能实现乘法运算</li><li>完整的表达式要被 <code> </code> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li></ul><p><strong>算术运算符列表</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">运算符说明    举例+    加法<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a + $b<span class="token variable">`</span></span> 结果为 <span class="token number">30</span>。-   减法<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a - $b<span class="token variable">`</span></span> 结果为 <span class="token number">10</span>。*    乘法<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a <span class="token punctuation">\</span>* $b<span class="token variable">`</span></span> 结果为  <span class="token number">200</span>。/    除法<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $b / $a<span class="token variable">`</span></span> 结果为 <span class="token number">2</span>。%    取余<span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $b % $a<span class="token variable">`</span></span> 结果为 <span class="token number">0</span>。<span class="token operator">=</span>    赋值<span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token variable">$b</span> 将把变量 b 的值赋给 a。<span class="token operator">==</span>    相等。用于比较两个数字，相同则返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$b</span> <span class="token punctuation">]</span> 返回 false。<span class="token operator">!=</span>    不相等。用于比较两个数字，不相同则返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token variable">$b</span> <span class="token punctuation">]</span> 返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-eq</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span> -eq <span class="token variable">$b</span> : a is equal to b"</span><span class="token keyword">else</span>   <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span> -eq <span class="token variable">$b</span>: a is not equal to b"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缩成一行可以这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-eq</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span> -eq <span class="token variable">$b</span> : a is equal to b"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span> -eq <span class="token variable">$b</span>: a is not equal to b"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里缩写，主要是为了让大家注意：</p><ul><li>if后面直到then前面的分号结束，都是有空格的: <code>if [ $a -eq $b ]</code></li></ul><p><strong>关系运算符列表</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">运算符说明<span class="token parameter variable">-eq</span>检测两个数是否相等，相等返回 true。同算数运算符<span class="token variable"><span class="token variable">`</span><span class="token operator">==</span><span class="token variable">`</span></span><span class="token parameter variable">-ne</span>检测两个数是否相等，不相等返回 <span class="token boolean">true</span><span class="token parameter variable">-gt</span>检测左边的数是否大于右边的，如果是，则返回 true。<span class="token parameter variable">-lt</span>检测左边的数是否小于右边的，如果是，则返回 true。<span class="token parameter variable">-ge</span>检测左边的数是否大等于右边的，如果是，则返回 true。<span class="token parameter variable">-le</span>检测左边的数是否小于等于右边的，如果是，则返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p><strong>布尔运算符列表</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">运算符说明<span class="token operator">!</span>非运算，表达式为 <span class="token boolean">true</span> 则返回 false，否则返回 true。<span class="token parameter variable">-o</span>或运算<span class="token punctuation">(</span>or<span class="token punctuation">)</span>，有一个表达式为 <span class="token boolean">true</span> 则返回 true。<span class="token parameter variable">-a</span>与运算<span class="token punctuation">(</span>and<span class="token punctuation">)</span>，两个表达式都为 <span class="token boolean">true</span> 才返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token number">3</span> <span class="token parameter variable">-eq</span> <span class="token number">3</span> <span class="token parameter variable">-a</span> <span class="token number">3</span> <span class="token parameter variable">-lt</span> <span class="token number">5</span> <span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">'ok'</span><span class="token keyword">fi</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p><strong>字符串运算符列表</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">运算符说明举例<span class="token operator">=</span>检测两个字符串是否相等，相等返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token variable">$b</span> <span class="token punctuation">]</span> 返回 false。<span class="token operator">!=</span>检测两个字符串是否相等，不相等返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token variable">$b</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-z</span>检测字符串长度是否为0，为0返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token variable">$a</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-n</span>检测字符串长度是否为0，不为0返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token variable">$a</span> <span class="token punctuation">]</span> 返回 true。str检测字符串是否为空，不为空返回 true。<span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token punctuation">]</span> 返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token assign-left variable">file</span><span class="token operator">=</span><span class="token string">"/tmp/test.sh"</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-e</span> <span class="token variable">$file</span> <span class="token punctuation">]</span><span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"File exists"</span><span class="token keyword">else</span>   <span class="token builtin class-name">echo</span> <span class="token string">"File does not exist"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件测试运算符列表</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">操作符说明举例<span class="token parameter variable">-b</span> <span class="token function">file</span>检测文件是否是块设备文件，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-b</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-c</span> <span class="token function">file</span>检测文件是否是字符设备文件，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-c</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-d</span> <span class="token function">file</span>检测文件是否是目录，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-d</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-f</span> <span class="token function">file</span>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-g</span> <span class="token function">file</span>检测文件是否设置了 SGID 位，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-g</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-k</span> <span class="token function">file</span>检测文件是否设置了粘着位<span class="token punctuation">(</span>Sticky Bit<span class="token punctuation">)</span>，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-k</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-p</span> <span class="token function">file</span>检测文件是否是具名管道，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-p</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-u</span> <span class="token function">file</span>检测文件是否设置了 SUID 位，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-u</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 false。<span class="token parameter variable">-r</span> <span class="token function">file</span>检测文件是否可读，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-r</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-w</span> <span class="token function">file</span>检测文件是否可写，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-w</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-x</span> <span class="token function">file</span>检测文件是否可执行，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-x</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-s</span> <span class="token function">file</span>检测文件是否为空（文件大小是否大于0），不为空返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-s</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span class="token parameter variable">-e</span> <span class="token function">file</span>检测文件（包括目录）是否存在，如果是，则返回 true。<span class="token punctuation">[</span> <span class="token parameter variable">-e</span> <span class="token variable">$file</span> <span class="token punctuation">]</span> 返回 true。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shell运算符&quot;&gt;&lt;a href=&quot;#Shell运算符&quot; class=&quot;headerlink&quot; title=&quot;Shell运算符&quot;&gt;&lt;/a&gt;Shell运算符&lt;/h2&gt;&lt;p&gt;Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算</summary>
      
    
    
    
    <category term="shell" scheme="http://luxihua.space/categories/shell/"/>
    
    
    <category term="shell脚本基础使用" scheme="http://luxihua.space/tags/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本学习03--字符串和数组</title>
    <link href="http://luxihua.space/blog/b5726c19.html"/>
    <id>http://luxihua.space/blog/b5726c19.html</id>
    <published>2024-02-03T04:59:48.966Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似：</p><p>单双引号的区别：</p><ul><li>双引号里可以有变量，单引号则原样输出；</li><li>双引号里可以出现转义字符，单引号则原样输出；</li><li>单引号字串中不能出现单引号。</li></ul><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">str1</span><span class="token operator">=</span><span class="token string">'i'</span><span class="token assign-left variable">str2</span><span class="token operator">=</span><span class="token string">'love'</span><span class="token assign-left variable">str3</span><span class="token operator">=</span><span class="token string">'you'</span><span class="token builtin class-name">echo</span> <span class="token variable">$str1</span> <span class="token variable">$str2</span> <span class="token variable">$str3</span><span class="token builtin class-name">echo</span> <span class="token variable">$str1</span><span class="token variable">$str2</span><span class="token variable">$str3</span><span class="token builtin class-name">echo</span> <span class="token variable">$str1</span>,<span class="token variable">$str2</span>,<span class="token variable">$str3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">i love youiloveyoui,love,you<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">'i love you'</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>str}</span><span class="token comment"># 输出：10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">'i love you'</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:</span>1}</span> <span class="token comment"># 从第1个截取到末尾。注意从0开始。</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:</span>2<span class="token operator">:</span>2}</span> <span class="token comment"># 从第2个截取2个。</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:</span>0}</span> <span class="token comment"># 全部截取。</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:-</span>3}</span> <span class="token comment"># 负数无效，视为0。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">love youloi love youi love you<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">"i love you"</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> index <span class="token string">"<span class="token variable">$str</span>"</span> l<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> index <span class="token string">"<span class="token variable">$str</span>"</span> you<span class="token variable">`</span></span> <span class="token comment">#最后一个参数是字符，会对后面字符串每一个单独查找，返回最靠前的index</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> index <span class="token string">"<span class="token variable">$str</span>"</span> o<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> length <span class="token string">"<span class="token variable">$str</span>"</span><span class="token variable">`</span></span> <span class="token comment">#字符串长度</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> substr <span class="token string">"<span class="token variable">$str</span>"</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">`</span></span> <span class="token comment">#从字符串中位置1开始截取6个字符。索引是从0开始的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出:</p><pre class="line-numbers language-none"><code class="language-none">34410i love<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意字符串变量需要加双引号。第2个例子里<code>you</code>虽然<code>y</code>的index是8,但是<code>o</code>在前面已经出现过,index是4，最终取所有字符里最靠前的index。</p><p>拓展：<code>expr</code>更多关于字符串用法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">STRING <span class="token builtin class-name">:</span> REGEXP   anchored pattern match of REGEXP <span class="token keyword">in</span> STRINGmatch STRING REGEXP        same as STRING <span class="token builtin class-name">:</span> REGEXPsubstr STRING POS LENGTH   <span class="token comment">#从STRING中POS位置开始截取LENGTH个字符。POS索引是从1开始的。</span>index STRING CHARS         <span class="token comment">#在STRING中查找字符CHARS首次出现的位置，没有找到返回0</span>length STRING              <span class="token comment">#字符串长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。</p><p>在Shell中，用括号来表示数组，数组元素用<code>空格</code>符号分割开。定义数组的一般形式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">array_name</span><span class="token operator">=</span><span class="token punctuation">(</span>value1 value2 <span class="token punctuation">..</span>. valuen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">array_name</span><span class="token operator">=</span><span class="token punctuation">(</span>value0 value1 value2 value3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">array_name</span><span class="token operator">=</span><span class="token punctuation">(</span>    value0    value1    value2    value3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以单独定义数组的各个分量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">array_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>value0array_name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>value1array_name<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>value2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以不使用连续的下标，而且下标的范围没有限制。</p><p>下面来读取数组：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">${array_name<span class="token punctuation">[</span>2<span class="token punctuation">]</span>}</span> <span class="token comment">#读取下标为2的元素</span><span class="token builtin class-name">echo</span> <span class="token variable">${array_name<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span> <span class="token comment">#读取所有元素</span><span class="token builtin class-name">echo</span> <span class="token variable">${array_name<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> <span class="token comment">#读取所有元素</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>array_name<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span> <span class="token comment">#获取数组长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>array_name<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> <span class="token comment">#获取数组长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>array_name<span class="token punctuation">[</span>1<span class="token punctuation">]</span>}</span> <span class="token comment">#获取数组中单个元素的长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">value2value0 value1 value2 value3value0 value1 value2 value3<span class="token number">4</span><span class="token number">4</span><span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比shell里字符串和数组，我们发现：</p><p>字符串</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">"hello"</span><span class="token variable">${<span class="token operator">#</span>str}</span> <span class="token comment"># 读取字符串长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${str}</span> <span class="token comment"># 读取字符串全部</span><span class="token builtin class-name">echo</span> <span class="token variable">${str<span class="token operator">:</span>1}</span> <span class="token comment"># 截取字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>数组：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">arr</span><span class="token operator">=</span><span class="token punctuation">(</span>a1 a2 a3<span class="token punctuation">)</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>arr<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span> <span class="token comment"># 读取数组长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${<span class="token operator">#</span>arr<span class="token punctuation">[</span>1<span class="token punctuation">]</span>}</span> <span class="token comment"># 读取数组某个元素长度</span><span class="token builtin class-name">echo</span> <span class="token variable">${arr<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span> <span class="token comment"># 读取数组全部</span><span class="token builtin class-name">echo</span> <span class="token variable">${arr<span class="token punctuation">[</span>1<span class="token punctuation">]</span>}</span> <span class="token comment"># 读取数组某个元素</span><span class="token comment"># 总结</span><span class="token comment"># ${#ele*} 用来读取ele元素长度属性</span><span class="token comment"># ${ele*}  用来读取或操作ele元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;p&gt;字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以</summary>
      
    
    
    
    <category term="shell" scheme="http://luxihua.space/categories/shell/"/>
    
    
    <category term="shell脚本基础使用" scheme="http://luxihua.space/tags/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本学习04--条件控制</title>
    <link href="http://luxihua.space/blog/45de763f.html"/>
    <id>http://luxihua.space/blog/45de763f.html</id>
    <published>2024-02-03T04:59:48.966Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件判断：if语句"><a href="#条件判断：if语句" class="headerlink" title="条件判断：if语句"></a>条件判断：if语句</h2><p>语法格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> expression <span class="token punctuation">]</span><span class="token keyword">then</span>   Statement<span class="token punctuation">(</span>s<span class="token punctuation">)</span> to be executed <span class="token keyword">if</span> expression is <span class="token boolean">true</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<code>expression</code> 和方括号([ ])之间必须有空格，否则会有语法错误。</p><p>if 语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种 if … else 语句：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">..</span>. <span class="token keyword">fi</span> 语句<span class="token keyword">if</span> <span class="token punctuation">..</span>. <span class="token keyword">else</span> <span class="token punctuation">..</span>. <span class="token keyword">fi</span> 语句<span class="token keyword">if</span> <span class="token punctuation">..</span>. <span class="token keyword">elif</span> <span class="token punctuation">..</span>. <span class="token keyword">else</span> <span class="token punctuation">..</span>. <span class="token keyword">fi</span> 语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"a is equal to b"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-gt</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token keyword">then</span><span class="token builtin class-name">echo</span> <span class="token string">"a is greater to b"</span><span class="token keyword">else</span><span class="token builtin class-name">echo</span> <span class="token string">"a is less to b"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>if ... else</code> 语句也可以写成一行，以命令的方式来运行:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$b</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"a is equal to b"</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token builtin class-name">echo</span> <span class="token string">"a is not equal to b"</span><span class="token punctuation">;</span><span class="token keyword">fi</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>if ... else</code> 语句也经常与 <code>test</code> 命令结合使用，作用与上面一样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span><span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$b</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"a is equal to b"</span><span class="token keyword">else</span><span class="token builtin class-name">echo</span> <span class="token string">"a is not equal to b"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分支控制：case语句"><a href="#分支控制：case语句" class="headerlink" title="分支控制：case语句"></a>分支控制：case语句</h2><p><code>case ... esac</code> 与其他语言中的 <code>switch ... case</code> 语句类似，是一种多分枝选择结构。</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token assign-left variable">grade</span><span class="token operator">=</span><span class="token string">"B"</span><span class="token keyword">case</span> <span class="token variable">$grade</span> <span class="token keyword">in</span> <span class="token string">"A"</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Very Good!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token string">"B"</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Good!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token string">"C"</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Come On!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>*<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"You Must Try!"</span><span class="token builtin class-name">echo</span> <span class="token string">"Sorry!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换成C语言是：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> grade <span class="token operator">=</span> <span class="token char">'B'</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>grade<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token char">'A'</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Very Good!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'B'</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Very Good!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'C'</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Very Good!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>             <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"You Must Try!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sorry!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对比看就很容易理解了。很相似，只是格式不一样。</p><p>需要注意的是：</p><p><strong>取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 <code>;;</code>。</strong><code>;;</code> 与其他语言中的 <code>break</code> 类似，意思是跳到整个 <code>case</code> 语句的最后。</p><p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 <code>*</code> 捕获该值，再执行后面的命令。</p><p>再举一个例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">option</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${1}</span>"</span><span class="token keyword">case</span> <span class="token variable">${option}</span> <span class="token keyword">in</span>   <span class="token string">"-f"</span><span class="token punctuation">)</span> <span class="token assign-left variable">FILE</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${2}</span>"</span>      <span class="token builtin class-name">echo</span> <span class="token string">"File name is <span class="token variable">$FILE</span>"</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span>   <span class="token string">"-d"</span><span class="token punctuation">)</span> <span class="token assign-left variable">DIR</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${2}</span>"</span>      <span class="token builtin class-name">echo</span> <span class="token string">"Dir name is <span class="token variable">$DIR</span>"</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span>   *<span class="token punctuation">)</span>       <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token variable">`</span></span>:usage: [-f file] | [-d directory]"</span>      <span class="token builtin class-name">exit</span> <span class="token number">1</span> <span class="token comment"># Command to come out of the program with status 1</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$./test.shtest.sh: usage: <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> filename <span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span> <span class="token parameter variable">-d</span> directory <span class="token punctuation">]</span>./test.sh <span class="token parameter variable">-f</span> index.htmlFile name is index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里用到了特殊变量<code>${1}</code>,指的是获取命令行的第一个参数。</p><p>下面结合<code>getopts</code>命令介绍下一个经典的例子：从命令行读取参数。</p><p>run.sh</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token function-name function">usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Usage: <span class="token variable">$0</span> -s [start|stop|reload|restart] -e [online|test]"</span>    <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    usage<span class="token keyword">fi</span><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> <span class="token string">'s:e:h'</span> OPT<span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token keyword">case</span> <span class="token variable">$OPT</span> <span class="token keyword">in</span>        s<span class="token punctuation">)</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OPTARG</span>"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        e<span class="token punctuation">)</span> <span class="token assign-left variable">env</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OPTARG</span>"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        h<span class="token punctuation">)</span> usage<span class="token punctuation">;</span><span class="token punctuation">;</span>        ?<span class="token punctuation">)</span> usage<span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">esac</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token variable">$cmd</span><span class="token builtin class-name">echo</span> <span class="token variable">$env</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们直接运行<code>run.sh</code>的时候，会调用<code>usage</code>显示帮助；如果输入正确的参数，则会进入正确的流程。运行示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> run.sh <span class="token parameter variable">-s</span> start <span class="token parameter variable">-e</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>shell的for循环与c、php等语言不同，同Python很类似。下面是语法格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> 变量 <span class="token keyword">in</span> 列表<span class="token keyword">do</span>    command1    command2    <span class="token punctuation">..</span>.    commandN<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash/</span><span class="token keyword">for</span> <span class="token for-or-select variable">value</span> <span class="token keyword">in</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token string">"The value is <span class="token variable">$value</span>"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The value is <span class="token number">1</span>The value is <span class="token number">2</span>The value is <span class="token number">3</span>The value is <span class="token number">4</span>The value is <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺序输出字符串中的字符：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">str</span> <span class="token keyword">in</span> <span class="token string">'This is a string'</span><span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$str</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">This is a string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>遍历目录下的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">FILE</span> <span class="token keyword">in</span> *<span class="token keyword">do</span>   <span class="token builtin class-name">echo</span> <span class="token variable">$FILE</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码将遍历当前目录下所有的文件。在Linux下，可以改为其他目录试试。</p><p>遍历文件内容：</p><p>city.txt</p><pre class="line-numbers language-none"><code class="language-none">beijingtianjinshanghai<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">citys</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> city.txt<span class="token variable">`</span></span><span class="token keyword">for</span> <span class="token for-or-select variable">city</span> <span class="token keyword">in</span> <span class="token variable">$citys</span><span class="token keyword">do</span>   <span class="token builtin class-name">echo</span> <span class="token variable">$city</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">beijingtianjinshanghai<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>只要while后面的条件满足，就一直执行do里面的代码块。</p><p>其格式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token builtin class-name">command</span><span class="token keyword">do</span>   Statement<span class="token punctuation">(</span>s<span class="token punctuation">)</span> to be executed <span class="token keyword">if</span> <span class="token builtin class-name">command</span> is <span class="token boolean">true</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$c</span> <span class="token parameter variable">-lt</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token keyword">do</span><span class="token builtin class-name">echo</span> <span class="token string">"Value c is <span class="token variable">$c</span>"</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $c + <span class="token number">1</span><span class="token variable">`</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">Value c is 0Value c is 1Value c is 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里由于shell本身不支持算数运算，所以使用<code>expr</code>命令进行自增。</p><h2 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。</p><p>将上面while循环的例子改改，就能达到一样的效果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">until</span> <span class="token punctuation">[</span> <span class="token variable">$c</span> <span class="token parameter variable">-eq</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token keyword">do</span><span class="token builtin class-name">echo</span> <span class="token string">"Value c is <span class="token variable">$c</span>"</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $c + <span class="token number">1</span><span class="token variable">`</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先do里面的语句块一直在运行，直到满足了until的条件就停止。</p><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">Value c is 0Value c is 1Value c is 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-lt</span> <span class="token number">5</span> <span class="token punctuation">]</span><span class="token keyword">do</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $i + <span class="token number">1</span><span class="token variable">`</span></span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token keyword">then</span><span class="token builtin class-name">break</span><span class="token keyword">fi</span><span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token variable">$i</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">break</span> n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示跳出第 n 层循环。</p><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-lt</span> <span class="token number">5</span> <span class="token punctuation">]</span><span class="token keyword">do</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $i + <span class="token number">1</span><span class="token variable">`</span></span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token keyword">then</span><span class="token builtin class-name">continue</span><span class="token keyword">fi</span><span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token variable">$i</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">1245<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;条件判断：if语句&quot;&gt;&lt;a href=&quot;#条件判断：if语句&quot; class=&quot;headerlink&quot; title=&quot;条件判断：if语句&quot;&gt;&lt;/a&gt;条件判断：if语句&lt;/h2&gt;&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre class=&quot;line-numbers languag</summary>
      
    
    
    
    <category term="shell" scheme="http://luxihua.space/categories/shell/"/>
    
    
    <category term="shell脚本基础使用" scheme="http://luxihua.space/tags/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本学习05--函数</title>
    <link href="http://luxihua.space/blog/26f46cdf.html"/>
    <id>http://luxihua.space/blog/26f46cdf.html</id>
    <published>2024-02-03T04:59:48.966Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<p>函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Shell 函数的定义格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">function_name</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list of commands    <span class="token punctuation">[</span> <span class="token builtin class-name">return</span> value <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>function</code>关键字是可选的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function-name function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token builtin class-name">echo</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用函数只需要给出函数名，不需要加括号。</p><p>函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。</p><p>Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：<code>numeric argument required</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token builtin class-name">return</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">line <span class="token number">4</span>: return: hello: numeric argument required<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token builtin class-name">return</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token assign-left variable">str</span><span class="token operator">=</span>hello<span class="token builtin class-name">echo</span> <span class="token variable">$str</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>像删除变量一样，删除函数也可以使用 <code>unset</code> 命令，不过要加上 <code>.f</code> 选项，如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$unset</span> .f function_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。</p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数…这就是前面讲的特殊变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token variable">$#</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"no param"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token variable">$1</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $1 + $2<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $1 + $2 + $3<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token punctuation">;</span>*<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$#</span> params! It's too much!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token punctuation">}</span><span class="token function">sum</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">4 params! It's too much!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，<code>$10</code> 不能获取第十个参数，获取第十个参数需要<code>${10}</code>。当<code>n&gt;=10</code>时，需要使用<code>${n}</code>来获取参数。</p><p>另外，还有几个特殊变量用来处理参数，前面已经提到：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">特殊变量说明<span class="token variable">$#</span>传递给函数的参数个数。<span class="token variable">$*</span>显示所有传递给函数的参数。<span class="token variable">$@</span>与<span class="token variable">$*</span>相同，但是略有区别，请查看Shell特殊变量。<span class="token variable">$?</span>函数的返回值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何获取函数返回值"><a href="#如何获取函数返回值" class="headerlink" title="如何获取函数返回值"></a>如何获取函数返回值</h2><p>后面的变量需要使用函数的返回值，怎么实现？</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> <span class="token number">1</span>+2+3<span class="token variable">`</span></span><span class="token punctuation">}</span><span class="token assign-left variable">num</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">sum</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以取到返回值了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。&lt;/p&gt;
&lt;h2 id=&quot;函数定义&quot;&gt;&lt;a href=&quot;#函数定义&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="shell" scheme="http://luxihua.space/categories/shell/"/>
    
    
    <category term="shell脚本基础使用" scheme="http://luxihua.space/tags/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本学习06--其它</title>
    <link href="http://luxihua.space/blog/339cb40c.html"/>
    <id>http://luxihua.space/blog/339cb40c.html</id>
    <published>2024-02-03T04:59:48.966Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell输入输出重定向"><a href="#Shell输入输出重定向" class="headerlink" title="Shell输入输出重定向"></a>Shell输入输出重定向</h2><p>Unix 命令默认从标准输入设备(stdin)获取输入，将结果输出到标准输出设备(stdout)显示。一般情况下，标准输入设备就是键盘，标准输出设备就是终端，即显示器。</p><p>输出重定向</p><p>命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。</p><p>命令输出重定向的语法为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，输出到显示器的内容就可以被重定向到文件。</p><p>例如，下面的命令在显示器上不会看到任何输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">who</span> <span class="token operator">&gt;</span> <span class="token function">users</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 users 文件，可以看到下面的内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token function">users</span>oko         tty01   Sep <span class="token number">12</span> 07:30ai          tty15   Sep <span class="token number">12</span> <span class="token number">13</span>:32ruth        tty21   Sep <span class="token number">12</span> <span class="token number">10</span>:10pat         tty24   Sep <span class="token number">12</span> <span class="token number">13</span>:07steve       tty25   Sep <span class="token number">12</span> <span class="token number">13</span>:03<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出重定向会覆盖文件内容，请看下面的例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> line <span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token function">users</span><span class="token function">cat</span> <span class="token function">users</span>line <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果不希望文件内容被覆盖，可以使用 <code>&gt;&gt;</code> 追加到文件末尾，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> line <span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token function">users</span><span class="token function">cat</span> <span class="token function">users</span>line <span class="token number">1</span>line <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入重定向</p><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&lt;</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p><p>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</p><p>例如，计算 users 文件中的行数，可以使用下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token function">users</span><span class="token number">2</span> <span class="token function">users</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以将输入重定向到 users 文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token operator">&lt;</span> <span class="token function">users</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p><h2 id="重定向深入讲解"><a href="#重定向深入讲解" class="headerlink" title="重定向深入讲解"></a>重定向深入讲解</h2><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li><strong>标准输入文件(stdin)</strong>: stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li><strong>标准输出文件(stdout)</strong>: stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li><strong>标准错误文件(stderr)</strong>: stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>默认情况下，<code>command &gt; file</code> 将 stdout 重定向到 file，<code>command &lt; file</code> 将stdin 重定向到 file。</p><p>如果希望 stderr 重定向到 file，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2 表示标准错误文件(stderr)。</p><p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> <span class="token function">file</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&lt;</span> file1 <span class="token operator">&gt;</span>file2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p><p><strong>全部可用的重定向命令列表：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">命令说明<span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> <span class="token function">file</span>将输出重定向到 file。<span class="token builtin class-name">command</span> <span class="token operator">&lt;</span> <span class="token function">file</span>将输入重定向到 file。<span class="token builtin class-name">command</span> <span class="token operator">&gt;&gt;</span> <span class="token function">file</span>将输出以追加的方式重定向到 file。n <span class="token operator">&gt;</span> <span class="token function">file</span>将文件描述符为 n 的文件重定向到 file。n <span class="token operator">&gt;&gt;</span> <span class="token function">file</span>将文件描述符为 n 的文件以追加的方式重定向到 file。n <span class="token operator">&gt;&amp;</span> m将输出文件 m 和 n 合并。n <span class="token operator">&lt;&amp;</span> m将输入文件 m 和 n 合并。<span class="token operator">&lt;&lt;</span> tag将开始标记 tag 和结束标记 tag 之间的内容作为输入。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h2><p>Here Document 目前没有统一的翻译，这里暂译为<code>嵌入文档</code>。Here Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&lt;&lt;</span> <span class="token string">delimiter    documentdelimiter</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p><p>注意：</p><p><strong>结尾的delimiter 一定要顶格写</strong>，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</p><p>开始的delimiter前后的空格会被忽略掉。</p><p>下面的例子，通过 <code>wc -l</code> 命令计算 document 的行数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF    This is a simple lookup program    for good (and bad) restaurants    in Cape Town.EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出： 3</p><p>也可以 将 Here Document 用在脚本中，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOFThis is a simple lookup programfor good (and bad) restaurantsin Cape Town.EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">This is a simple lookup programfor good (and bad) restaurantsin Cape Town.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="x2F-dev-x2F-null-文件"><a href="#x2F-dev-x2F-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h2><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 <code>/dev/null</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>/dev/null</code> 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 <code>/dev/null</code> 文件非常有用，将命令的输出重定向到它，会起到<code>禁止输出</code>的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样不会在屏幕打印任何信息。</p><h2 id="Shell文件包含"><a href="#Shell文件包含" class="headerlink" title="Shell文件包含"></a>Shell文件包含</h2><p>像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。</p><p>Shell 中包含脚本可以使用 <code>. filename</code> 或 <code>source filename</code> 。</p><p>两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。</p><p>示例：</p><p>被包含文件：sub.sh</p><pre class="line-numbers language-none"><code class="language-none">name="yjc"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主文件：test.sh</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">.</span> ./sub.sh<span class="token builtin class-name">echo</span> <span class="token variable">$name</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">yjc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="获取当前正在执行脚本的绝对路径"><a href="#获取当前正在执行脚本的绝对路径" class="headerlink" title="获取当前正在执行脚本的绝对路径"></a>获取当前正在执行脚本的绝对路径</h2><p>正确的命令是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">basepath</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">cd</span> `dirname $0`<span class="token punctuation">;</span> <span class="token builtin class-name">pwd</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接使用<code>pwd</code>或者<code>dirname $0</code>是不对的。</p><h2 id="按特定字符串截取字符串"><a href="#按特定字符串截取字符串" class="headerlink" title="按特定字符串截取字符串"></a>按特定字符串截取字符串</h2><p>示例：截取<code>/www/html/php/myapp/</code>里的myapp。</p><p>方案：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span>/www/html/php/myapp/<span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $str<span class="token operator">|</span><span class="token function">sed</span> <span class="token string">'s#/# #g'</span><span class="token variable">)</span></span><span class="token punctuation">)</span><span class="token assign-left variable">b_len</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $<span class="token punctuation">{</span>#b<span class="token punctuation">[</span>*<span class="token punctuation">]</span><span class="token punctuation">}</span> - <span class="token number">1</span><span class="token variable">`</span></span><span class="token assign-left variable">app_name</span><span class="token operator">=</span><span class="token variable">${b<span class="token punctuation">[</span>$b_len<span class="token punctuation">]</span>}</span><span class="token builtin class-name">echo</span> <span class="token variable">$app_name</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里利用<code>sed</code>将字符串按指定字符截成数组，然后取最后一个。</p><p>计算数组长度: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">${<span class="token operator">#</span>arr<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>计算则需要使用<code>expr</code>命令</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h3 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h3><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件(或其他方式的输入流, 如重定向输入)逐行的读入（看作一个记录集）, 把每一行看作一条记录，以空格(或\t,或用户自己指定的分隔符)为默认分隔符将每行切片（类似字段），切开的部分再进行各种分析处理。</p><p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p><p>Awk基本语法:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token string">'pattern1 {command1;command 2…; command 3}  pattern2 { command …}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pattern表示用来过滤记录的模式,可是是正则表达式，关系运算表达式，也可以什么也没有(表示选中所有记录)。</p><p>每个pattern选中的行记录会被花括号括起来的命令command操作一遍, command之间用<code>;</code>分割。 花括号里面可以什么也没有, 则默认为print输出整行记录。 Comamnd可以是输出， 可以是算术运算，逻辑运算，循环控制等等。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>s.txt</p><pre class="line-numbers language-none"><code class="language-none">zhangsan 1977 male computer 83lisi 1989 male math 99wanglijiang 1990 female chinese 78xuliang 1977 male economic 89xuxin 1986 female english 99wangxuebing 1978 male math 89lichang 1989 male math 99wanglijiang 1990 female chinese 78zhangsansan 1977 male computer 83 langxuebing 1978 male math 89lisibao 1989 male math 99xiaobao 1990 female chinese 78<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一行中的5个字段分别表示<code>姓名, 出生年, 性别,科目,分数</code>, 是一个很传统很典型的报表文件。</p><p>现在演示awk是如何查找的：</p><p>1)直接输出1990年出生的同学:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'/1990/'</span> s.txtwanglijiang <span class="token number">1990</span> female chinese <span class="token number">78</span>wanglijiang <span class="token number">1990</span> female chinese <span class="token number">78</span>xiaobao <span class="token number">1990</span> female chinese <span class="token number">78</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-none"><code class="language-none">$ awk '/1990/{print $0}' s.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>awk默认把输入的内容以空格拆分出每列。<code>$0</code>表示匹配所有列，<code>print $0</code>将输出所有列，每列分隔符是空格。</p><p>2）对chinese的课程的行输出”语文”：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'/chinese/{print "语文"}'</span> s.txt语文语文语文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）记录的头部和结尾加上一段说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'BEGIN{print "Result of the quiz:\n"}{print $0}END{print "------"}'</span> s.txtResult of the quiz:zhangsan <span class="token number">1977</span> male computer <span class="token number">83</span>lisi <span class="token number">1989</span> male math <span class="token number">99</span>wanglijiang <span class="token number">1990</span> female chinese <span class="token number">78</span>xuliang <span class="token number">1977</span> male economic <span class="token number">89</span>xuxin <span class="token number">1986</span> female english <span class="token number">99</span>wangxuebing <span class="token number">1978</span> male math <span class="token number">89</span>lichang <span class="token number">1989</span> male math <span class="token number">99</span>wanglijiang <span class="token number">1990</span> female chinese <span class="token number">78</span>zhangsansan <span class="token number">1977</span> male computer <span class="token number">83</span>langxuebing <span class="token number">1978</span> male math <span class="token number">89</span>lisibao <span class="token number">1989</span> male math <span class="token number">99</span>xiaobao <span class="token number">1990</span> female chinese <span class="token number">78</span>------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AWK工作流程：<strong>逐行扫描文件，从第一行到最后一行，寻找匹配特定模式的行，并在这些行上进行用户想要到的操作</strong>。</p><p>BEGIN只会在最开始执行；END只会在扫描所有行数之后执行。BEGIN和END之间的花括号的内容每扫描一行都会执行。</p><p>4)查找女生的成绩且只输出姓名、学科、成绩：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'$3=="female"{print $1,$4,$5}'</span> s.txtwanglijiang chinese <span class="token number">78</span>xuxin english <span class="token number">99</span>wanglijiang chinese <span class="token number">78</span>xiaobao chinese <span class="token number">78</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>$1</code>表示第1列，<code>$n</code>类推。这里条件是表达式，而不是正则。print里<code>,</code>表示空格分隔符。</p><p>5)找出1990年出生的学生姓名，并要求匹配正则:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'$2~/1990/{print $1}'</span> s.txtwanglijiangwanglijiangxiaobao<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里<code>~</code>表示匹配正则表达式。<code>!~</code>表示不匹配正则表达式。</p><p>如果需要多选，则改成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'$2~/(1990|1991)/{print $1}'</span> s.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>awk更多内容详见：<a href="https://www.cnblogs.com/52fhy/p/5836429.html#autoid-3-4-0">https://www.cnblogs.com/52fhy/p/5836429.html#autoid-3-4-0</a></p><p>（完结）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shell输入输出重定向&quot;&gt;&lt;a href=&quot;#Shell输入输出重定向&quot; class=&quot;headerlink&quot; title=&quot;Shell输入输出重定向&quot;&gt;&lt;/a&gt;Shell输入输出重定向&lt;/h2&gt;&lt;p&gt;Unix 命令默认从标准输入设备(stdin)获取输入，将结</summary>
      
    
    
    
    <category term="shell" scheme="http://luxihua.space/categories/shell/"/>
    
    
    <category term="shell脚本基础使用" scheme="http://luxihua.space/tags/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luxihua.space/blog/0.html"/>
    <id>http://luxihua.space/blog/0.html</id>
    <published>2024-02-03T04:59:48.962Z</published>
    <updated>2024-02-03T04:59:48.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LTP-构建系统简介"><a href="#LTP-构建系统简介" class="headerlink" title="LTP 构建系统简介"></a>LTP 构建系统简介</h1><p>以下文档简要描述了用于新的和改进的 Makefile 系统的步骤和方法。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>旧的 Makefile 系统的问题是它很难维护并且缺乏正式的结构感，因此为 LTP 开发和包含新目标比它应该的（维护）更困难。此外，正确的基于选项的交叉编译是不可能的，因为 Makefile 不支持前缀系统，并且没有配置适当的隐式/静态规则来编译到树外的多个对象目录中建立支持（易用性/功能）。最后，没有办法设置组件之间的依赖关系，这样如果一个组件需要 libltp.a 才能编译，它会关闭并首先编译 libltp.a（易用性）。</p><p>这些项目需要修复，以减少为 LTP 做出贡献的开发社区和项目维护人员的维护噩梦。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>该系统的设计使得在每个新目录组件中包含一个 GNU Makefile 兼容集是构建系统所必需的。</p><p>假设您有一个如下所示的目录（其中包含直接绑定到应用程序的 .c 文件，例如 baz.c -&gt; baz）：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token operator">...</span><span class="token operator">/</span>foo<span class="token operator">/</span>     <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">&gt;</span> Makefile     <span class="token operator">|</span>      <span class="token operator">--</span><span class="token operator">&gt;</span> bar<span class="token operator">/</span>       <span class="token operator">|</span>        <span class="token operator">--</span><span class="token operator">&gt;</span> Makefile           <span class="token operator">|</span>            <span class="token operator">--</span><span class="token operator">&gt;</span> baz<span class="token punctuation">.</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个如何实现这一目标的示例：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">.../foo/Makefile</span><span class="token punctuation">:</span><span class="token comment">#</span><span class="token comment"># Copyright disclaimer goes here -- please use GPLv2.</span><span class="token comment">#</span>top_srcdir          <span class="token operator">?=</span> ..<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>top_srcdir<span class="token punctuation">)</span>/<span class="token keyword">include</span>/mk/env_pre.mk<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>top_srcdir<span class="token punctuation">)</span>/<span class="token keyword">include</span>/mk/generic_trunk_target.mk<span class="token target symbol">.../foo/bar/Makefile</span><span class="token punctuation">:</span><span class="token comment">#</span><span class="token comment"># Copyright disclaimer goes here -- please use GPLv2.</span><span class="token comment">#</span>top_srcdir          <span class="token operator">?=</span> ../..<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>top_srcdir<span class="token punctuation">)</span>/<span class="token keyword">include</span>/mk/env_pre.mk<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>top_srcdir<span class="token punctuation">)</span>/<span class="token keyword">include</span>/mk/generic_leaf_target.mk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="制定规则并制定变量"><a href="#制定规则并制定变量" class="headerlink" title="制定规则并制定变量"></a>制定规则并制定变量</h2><p>使用 make 规则时，避免编写如下临时规则：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">[prog]</span><span class="token punctuation">:</span> [dependencies]    cc -I../../<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDLIBS<span class="token punctuation">)</span> \        -o [prog] [dependencies]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等等。这使得交叉编译和确定性变得困难，如果不是不可能的话。此外，隐式规则是你的朋友，只要你使用<code>MAKEOPTS=;</code>。在顶级调用者中(or do (substr,(MAKEOPTS)) to remove -r)，编译将成功完成，假设已满足所有其他先决条件（库、标头等）。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol"><span class="token variable">$</span>(AR)</span>                       <span class="token punctuation">:</span> The library archiver.<span class="token target symbol"><span class="token variable">$</span>(CC)</span>                       <span class="token punctuation">:</span> The system C compiler.<span class="token target symbol"><span class="token variable">$</span>(CXX)</span>                      <span class="token punctuation">:</span> The system C++ compiler.<span class="token target symbol"><span class="token variable">$</span>(CPP)</span>                      <span class="token punctuation">:</span> The system C preprocessor.<span class="token target symbol"><span class="token variable">$</span>(CFLAGS)</span>           <span class="token punctuation">:</span> C compiler flags.<span class="token target symbol"><span class="token variable">$</span>(CPPFLAGS)</span>         <span class="token punctuation">:</span> Preprocessor flags, e.g. -I arguments.<span class="token target symbol"><span class="token variable">$</span>(CXXFLAGS)</span>         <span class="token punctuation">:</span> C++ compiler flags, e.g. -I arguments.<span class="token target symbol"><span class="token variable">$</span>(DEBUG_CFLAGS)</span>             <span class="token punctuation">:</span> Debug flags to pass to <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, -g, etc.<span class="token target symbol"><span class="token variable">$</span>(DEBUG_CXXFLAGS)</span>   <span class="token punctuation">:</span> Debug flags to pass to <span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span>.<span class="token target symbol"><span class="token variable">$</span>(LD)</span>                       <span class="token punctuation">:</span> The system linker <span class="token punctuation">(</span>typically <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, but not                          necessarily<span class="token punctuation">)</span>.<span class="token target symbol"><span class="token variable">$</span>(LDFLAGS)</span>          <span class="token punctuation">:</span> What to pass in to the linker, including -L arguments                          and other ld arguments, apart from -l library                          includes <span class="token punctuation">(</span>see <span class="token variable">$</span><span class="token punctuation">(</span>LDLIBS<span class="token punctuation">)</span><span class="token punctuation">)</span>.                          This should be done in the <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> args passing style                          when LD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, e.g. `-Wl,-foo', as opposed to                          `-foo'.<span class="token target symbol"><span class="token variable">$</span>(LDLIBS)</span>           <span class="token punctuation">:</span> Libraries to pass to the linker <span class="token punctuation">(</span>e.g. -lltp, etc<span class="token punctuation">)</span>.<span class="token target symbol"><span class="token variable">$</span>(OPT_CFLAGS)</span>               <span class="token punctuation">:</span> Optimization flags to pass into the C compiler, -O2,                          etc. If you specify -O2 or higher, you should also                          specify -fno-strict-aliasing, because of gcc                          fstrict-aliasing optimization bugs in the tree                          optimizer. Search for `fstrict-aliasing optimization                          bug' with your favorite search engine.<span class="token target symbol">                          Examples of more recent bugs</span><span class="token punctuation">:</span>                          1. tree-optimization/17510                          2. tree-optimization/39100                          Various bugs have occurred in the past due to buggy                          logic in the tree-optimization portion of the gcc                          compiler, from 3.3.x to 4.4.<span class="token target symbol"><span class="token variable">$</span>(OPT_CXXFLAGS)</span>             <span class="token punctuation">:</span> Optimization flags to pass to the C++ compiler.<span class="token target symbol"><span class="token variable">$</span>(RANLIB)</span>           <span class="token punctuation">:</span> What to run after archiving a library.<span class="token target symbol"><span class="token variable">$</span>(WCFLAGS)</span>          <span class="token punctuation">:</span> Warning flags to pass to <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, e.g. -Werror,                          -Wall, etc.<span class="token target symbol"><span class="token variable">$</span>(WCXXFLAGS)</span>                <span class="token punctuation">:</span> Same as <span class="token variable">$</span><span class="token punctuation">(</span>WCFLAGS<span class="token punctuation">)</span>, but for <span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span>AR<span class="token punctuation">)</span> ：库归档器。<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> ：系统 C 编译器。<span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> ：系统 C++ 编译器。<span class="token variable">$</span><span class="token punctuation">(</span>CPP<span class="token punctuation">)</span> ：系统 C 预处理器。<span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> ：C 编译器标志。<span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> ：预处理器标志，例如 -I 参数。<span class="token variable">$</span><span class="token punctuation">(</span>CXXFLAGS<span class="token punctuation">)</span> ：C++ 编译器标志，例如 -I 参数。<span class="token variable">$</span><span class="token punctuation">(</span>DEBUG_CFLAGS<span class="token punctuation">)</span> ：要传递给 <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>、-g 等的调试标志。<span class="token variable">$</span><span class="token punctuation">(</span>DEBUG_CXXFLAGS<span class="token punctuation">)</span> ：要传递给 <span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> 的调试标志。<span class="token variable">$</span><span class="token punctuation">(</span>LD<span class="token punctuation">)</span> ：系统链接器（通常是 <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>，但不是                          一定）。<span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> ：传递给链接器的内容，包括 -L 参数                          和其他 ld 参数，除了 -l 库                          包括（参见 <span class="token variable">$</span><span class="token punctuation">(</span>LDLIBS<span class="token punctuation">)</span>）。                          这应该在 <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> args 传递样式中完成                          当 LD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> 时，例如 `-Wl,-foo'，相对于                          `-foo'。<span class="token variable">$</span><span class="token punctuation">(</span>LDLIBS<span class="token punctuation">)</span> ：要传递给链接器的库（例如 -lltp 等）。<span class="token variable">$</span><span class="token punctuation">(</span>OPT_CFLAGS<span class="token punctuation">)</span> ：传递给 C 编译器的优化标志，-O2，                          等等 如果你指定 -O2 或更高，你也应该                          指定 -fno-strict-aliasing，因为 gcc                          树中的 fstrict 别名优化错误                          优化器。搜索`fstrict-别名优化                          错误'与您最喜欢的搜索引擎。                          最近的错误示例：                          1.树优化/17510                          2.树优化/39100                          由于buggy，过去出现过各种bug                          gcc 树优化部分的逻辑                          编译器，从 3.3.x 到 4.4。<span class="token variable">$</span><span class="token punctuation">(</span>OPT_CXXFLAGS<span class="token punctuation">)</span> ：传递给 C++ 编译器的优化标志。<span class="token variable">$</span><span class="token punctuation">(</span>RANLIB<span class="token punctuation">)</span> ：归档库后要运行的内容。<span class="token variable">$</span><span class="token punctuation">(</span>WCFLAGS<span class="token punctuation">)</span> ：传递给 <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> 的警告标志，例如 -Werror，                          - 墙等<span class="token variable">$</span><span class="token punctuation">(</span>WCXXFLAGS<span class="token punctuation">)</span> ：与 <span class="token variable">$</span><span class="token punctuation">(</span>WCFLAGS<span class="token punctuation">)</span> 相同，但用于 <span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span>。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="制作系统变量"><a href="#制作系统变量" class="headerlink" title="制作系统变量"></a>制作系统变量</h2><p>make 系统中使用了一系列变量来指示需要采取的操作。而不是我在这里列出变量，请使用它们的预期用途，请参阅 <code>../include/mk/env_pre.mk</code> 中包含的注释。</p><h2 id="指南和建议"><a href="#指南和建议" class="headerlink" title="指南和建议"></a>指南和建议</h2><p>当然，GNU Make 手册是理解 Make 系统的关键，但我建议查看以下部分和章节：</p><ul><li><a href="http://www.gnu.org/software/make/manual/make.html#Implicit-Rules">隐式规则</a></li><li><a href="http://www.gnu.org/software/make/manual/make.html#Using-Variables">变量和扩展</a></li><li><a href="http://www.gnu.org/software/make/manual/make.html#Origin-Function">原点函数使用</a></li><li><a href="http://www.gnu.org/software/make/manual/make.html#Directory-Search">VPath 用法</a></li></ul><h2 id="提交之前"><a href="#提交之前" class="headerlink" title="提交之前"></a>提交之前</h2><p>在提交之前应该从头开始重建。有关更多详细信息，请参阅<a href="https://github.com/linux-test-project/ltp/blob/master/INSTALL">安装。</a></p><h2 id="其他勘误表"><a href="#其他勘误表" class="headerlink" title="其他勘误表"></a>其他勘误表</h2><p>请参阅 TODO 以了解与 Makefile 基础结构相关的任何问题，以及一般的构建结构/源代码树。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LTP-构建系统简介&quot;&gt;&lt;a href=&quot;#LTP-构建系统简介&quot; class=&quot;headerlink&quot; title=&quot;LTP 构建系统简介&quot;&gt;&lt;/a&gt;LTP 构建系统简介&lt;/h1&gt;&lt;p&gt;以下文档简要描述了用于新的和改进的 Makefile 系统的步骤和方法。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luxihua.space/blog/0.html"/>
    <id>http://luxihua.space/blog/0.html</id>
    <published>2024-02-03T04:59:48.962Z</published>
    <updated>2024-02-03T04:59:48.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LTP-C-测试-API"><a href="#LTP-C-测试-API" class="headerlink" title="LTP C 测试 API"></a>LTP C 测试 API</h1><p>笔记  另请参阅 <a href="https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines">测试编写指南</a>、 <a href="https://github.com/linux-test-project/ltp/wiki/C-Test-Case-Tutorial">C测试用例教程</a>、 <a href="https://github.com/linux-test-project/ltp/wiki/Shell-Test-API">Shell测试API</a>。</p><table><thead><tr><th>笔记</th><th>另请参阅 <a href="https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines">测试编写指南</a>、 <a href="https://github.com/linux-test-project/ltp/wiki/C-Test-Case-Tutorial">C测试用例教程</a>、 <a href="https://github.com/linux-test-project/ltp/wiki/Shell-Test-API">Shell测试API</a>。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="1-用-C-编写测试"><a href="#1-用-C-编写测试" class="headerlink" title="1 用 C 编写测试"></a>1 用 C 编写测试</h2><h3 id="1-1-基本测试结构"><a href="#1-1-基本测试结构" class="headerlink" title="1.1 基本测试结构"></a>1.1 基本测试结构</h3><p>_让我们从一个例子开始，下面的代码是对getenv()_的简单测试。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*\ * [Description] * Tests basic functionality of getenv(). * *  - create an env variable and verify that getenv() can get get it *  - call getenv() with nonexisting variable name, check that it returns NULL */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENV1</span> <span class="token string">"LTP_TEST_ENV"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENV2</span> <span class="token string">"LTP_TEST_THIS_DOES_NOT_EXIST"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENV_VAL</span> <span class="token string">"val"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setenv</span><span class="token punctuation">(</span>ENV1<span class="token punctuation">,</span> ENV_VAL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TBROK <span class="token operator">|</span> TERRNO<span class="token punctuation">,</span> <span class="token string">"setenv() failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span>ret <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span>ENV1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV1 <span class="token string">") = NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">goto</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> ENV_VAL<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV1 <span class="token string">") = '"</span>ENV_VAL <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV1 <span class="token string">") = '%s', expected '"</span>               ENV_VAL <span class="token string">"'"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>next<span class="token operator">:</span>ret <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span>ENV2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV2 <span class="token string">") = '%s'"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"getenv("</span> ENV2 <span class="token string">") = NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> test<span class="token punctuation">,</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个测试都包含_tst_test.h_标头并且必须定义_struct tst_test test_结构。</p><p>整体测试初始化是在_setup()_函数中完成的。</p><p>整体清理是在_cleanup()_函数中完成的。这里省略了_cleanup()_，因为测试没有任何要清理的东西。如果在测试结构中设置了清理，则会在测试库清理之前的测试退出时调用它。这尤其意味着可以在测试执行中的任何时候调用清理。例如，即使测试设置步骤失败，_cleanup()_函数也必须能够处理未完成的初始化，等等。</p><p>测试本身是在_test()_函数中完成的。如果在循环中调用，测试函数必须正常工作。</p><p>测试结构中有两种类型的测试函数指针。第一个是_.test_all_指针，当测试作为单个函数实现时使用。然后是一个_.test_函数以及允许更详细的结果报告的测试数量_.tcnt 。<em>如果设置了</em>.test_ 指针，则函数将调用_.tcnt次，并使用 [0,_ <em>.tcnt</em> - 1]范围内的整数参数。</p><blockquote><p>重要的 :  一次只能设置 <em>.test_和</em>.test_all_ 之一。</p></blockquote><p>每个测试都有一个运行时长的限制，这个限制由 max_runtime 和 timeout 两部分组成。max_runtime 是 <em>.test_all_或一组</em>.test_函数可以花费多长时间的限制，超时是静态部分，应该涵盖测试设置和清理的持续时间以及一些安全性。</p><p>任何运行超过一两秒的测试都必须确保：</p><ul><li><p>通过在 tst_test 中设置 .max_runtime_或_在测试设置中调用_tst_set_max_runtime()来设置运行时间_</p></li><li><p>通过定期调用_tst_remaining_runtime()_监控剩余运行时间，并在运行时间用完时退出</p></li></ul><p>测试可以在 max_runtime 用完之前自由退出，例如当完成最少的迭代次数时。</p><p>该限制适用于_.test_all_函数的单次调用，这意味着例如当设置_.test_variants_或_.all_filesystems时，整个测试将受到__variants * (max_runtime + timeout)<em>秒的限制，并且测试运行时间可能接近于</em><em>variants * max_runtime</em>_秒。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * Returns number of seconds or zero in case that runtime has been used up. */</span><span class="token keyword">int</span> <span class="token function">tst_remaining_runtime</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="关于-cleanup-回调的一句话"><a href="#关于-cleanup-回调的一句话" class="headerlink" title="关于 cleanup() 回调的一句话"></a>关于 cleanup() 回调的一句话</h5><p>为了编写正确的 cleanup() 回调，需要遵循一些规则。</p><ol><li><p>仅释放已初始化的资源。请记住，回调可以在测试运行的任何时候执行。</p></li><li><p>确保以与初始化相反的顺序释放资源。（有些步骤可能不依赖于其他步骤，如果交换了一切都会正常工作，但让我们保持秩序。）</p></li></ol><p>第一条规则乍一看似乎很复杂，但相反，它非常简单。您所要做的就是跟踪已经初始化的内容。例如，文件描述符只有在分配了有效的文件描述符时才需要关闭。对于大多数事情，您需要创建额外的标志，该标志在成功初始化后立即设置。例如，考虑下面的测试设置。</p><p>我们还更喜欢清理本应在程序退出时释放的资源。做出这个决定有两个主要原因。在测试库为测试临时目录安装文件系统的情况下，文件描述符和映射内存等资源可能会阻止卸载块设备。不释放分配的内存会扰乱静态分析和 valgrind 等工具，并在检查 libc 和其他低级库中的泄漏时产生误报。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> fd0<span class="token punctuation">,</span> fd1<span class="token punctuation">,</span> mount_flag<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MNTPOINT</span> <span class="token string">"mntpoint"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FILE1</span> <span class="token string">"mntpoint/file1"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FILE2</span> <span class="token string">"mntpoint/file2"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">SAFE_MKDIR</span><span class="token punctuation">(</span>MNTPOINT<span class="token punctuation">,</span> <span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_MKFS</span><span class="token punctuation">(</span>tst_device<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> tst_device<span class="token operator">-&gt;</span>fs_type<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_MOUNT</span><span class="token punctuation">(</span>tst_device<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> MNTPOINT<span class="token punctuation">,</span> tst_device<span class="token operator">-&gt;</span>fs_type<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mount_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>fd0 <span class="token operator">=</span> <span class="token function">SAFE_OPEN</span><span class="token punctuation">(</span>cleanup<span class="token punctuation">,</span> FILE1<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fd1 <span class="token operator">=</span> <span class="token function">SAFE_OPEN</span><span class="token punctuation">(</span>cleanup<span class="token punctuation">,</span> FILE2<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，可以在任何_SAFE_*_ 宏失败时调用_cleanup()函数，因此也必须能够处理未完成的初始化。_由于全局变量被初始化为零，我们可以在尝试关闭它之前检查 fd &gt; 0。挂载函数需要在设备成功挂载后设置额外的标志。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd1 <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>fd1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd0 <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>fd0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mount_flag <span class="token operator">&amp;&amp;</span> <span class="token function">tst_umouont</span><span class="token punctuation">(</span>MNTPOINT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TWARN <span class="token operator">|</span> TERRNO<span class="token punctuation">,</span> <span class="token string">"umount(%s)"</span><span class="token punctuation">,</span> MNTPOINT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>重要的 : 清理中使用的_SAFE_MACROS()_<strong>不会</strong>退出测试。失败只会产生警告，而_cleanup()_会继续。这是有意为之的，因为我们希望尽可能 多地执行_cleanup() 。</p></blockquote><blockquote><p>警告 : 在测试cleanup(_ ) 中调用 tst_brk( )也不会退出测试，并且_TBROK_会转换为_TWARN_。 </p></blockquote><blockquote><p>笔记 : 测试临时目录的创建和删除在测试库中处理，目录以递归方式删除。因此我们不必在测试清理中删除文件和目录。</p></blockquote><h3 id="1-2-基本测试interface"><a href="#1-2-基本测试interface" class="headerlink" title="1.2 基本测试interface"></a>1.2 基本测试interface</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tst_res</span><span class="token punctuation">(</span><span class="token keyword">int</span> ttype<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg_fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似 printf 的函数来报告测试结果，它主要与 ttype 一起使用：</p><table><thead><tr><th><em>TPASS</em></th><th>测试已经通过。</th></tr></thead><tbody><tr><td><em>TFAIL</em></td><td>测试失败。</td></tr><tr><td><em>信息</em></td><td>一般消息。</td></tr><tr><td><em>警告</em></td><td>出了点问题，但我们决定继续。主要用于清理功能。</td></tr></tbody></table><p>ttype可以与_TERRNO_或_TTERRNO按位组合以分别打印 errno和TST_ERR 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tst_brk</span><span class="token punctuation">(</span><span class="token keyword">int</span> ttype<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg_fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类printf函数报错退出测试，可与ttype一起使用：</p><table><thead><tr><th><em>TBROK</em></th><th>测试准备阶段出现故障。</th></tr></thead><tbody><tr><td><em>TCONF</em></td><td>测试不适合当之前配置（系统调整未实现，架构不接受支持，……）</td></tr></tbody></table><p>ttype可以与_TERRNO_或_TTERRNO按__位_组合以分别打印 _errno__和_TST_ERR 。</p><p>还有_TST_EXP_*()_宏可以将系统调用单元测试简化为一行，尽可能使用它们。这些宏将函数调用作为第一个参数以及类似 printf 的格式字符串和参数。这些测试宏然后扩展为运行调用、检查返回值和错误号并报告测试结果的代码。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TST_EXP_PASS</span><span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>statbuf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"stat(%s, ...)"</span><span class="token punctuation">,</span> fname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>TST_PASS<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_EXP_PASS _()_可用于失败时返回 -1 和成功时返回 0 的调用。它将检查返回值并在返回值不等于 0 时报告失败。如果调用成功，该调用还将 TST_PASS 变量设置_为_1。</p><p>如上所示，这个和类似的宏采用可选的可变参数。这些以格式字符串开头，然后是要格式化的适当值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TST_EXP_FD</span><span class="token punctuation">(</span><span class="token function">open</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"open(%s, O_RDONLY)"</span><span class="token punctuation">,</span> fname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>TST_RET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_EXP_FD _()与__TST_EXP_PASS()_相同，唯一的区别是返回值应为文件描述符，因此如果返回正整数则调用通过。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TST_EXP_FAIL</span><span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>statbuf<span class="token punctuation">)</span><span class="token punctuation">,</span> ENOENT<span class="token punctuation">,</span> <span class="token string">"stat(%s, ...)"</span><span class="token punctuation">,</span> fname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_EXP_FAIL _()与TST_EXP_PASS()_类似，但如果调用未因 -1 失败且_errno_未设置为作为第二个参数传递的预期值，则测试失败。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TST_EXP_FAIL2</span><span class="token punctuation">(</span><span class="token function">msgget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">,</span> EINVAL<span class="token punctuation">,</span> <span class="token string">"msgget(%i, %i)"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_EXP_FAIL2 _()与__TST_EXP_FAIL()_相同，只是如果调用通过，返回值预计为非负整数。这些宏建立在 <code>TEST()</code>宏和相关变量之上。</p><p>_TST_EXP_FAIL_SILENT()_和_TST_EXP_FAIL2_SILENT()_变体不那么冗长，并且当 SCALL 按预期失败时不打印 TPASS 消息。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TEST</span><span class="token punctuation">(</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>TST_RET <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"Created raw socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>TST_RET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>TST_ERR <span class="token operator">!=</span> EPERM<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span><span class="token string">"Failed to create socket for wrong reason"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span> <span class="token string">"Didn't create raw socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>宏<code>TEST</code>设置<code>TST_RET</code>为其参数的返回值<code>TST_ERR</code>和 <code>errno</code>. 该<code>TTERNO</code>标志可用于打印错误号的符号值。</p><p>_除了tst_test_macros.h_中的那些，没有 LTP 库函数或宏会写入这些变量（规则_LTP-002_）。所以它们的值不会意外改变。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TST_EXP_POSITIVE</span><span class="token punctuation">(</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>TST_PASS<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>_如果wait_的返回值为正数或零，则此宏将打印通过结果并进行<code>TST_PASS</code>适当设置。如果返回值为负数，则打印失败。有许多与此处显示的宏类似的宏，请参阅_tst_test_macros.h_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TST_EXP_EQ_LI</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TST_EXP_EQ_UI</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TST_EXP_EQ_SZ</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TST_EXP_EQ_SSZ</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Use as */</span><span class="token function">TST_EXP_EQ_LI</span><span class="token punctuation">(</span>sig_caught<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用于不同整数类型比较的一组宏。这些宏在通过和失败场景中打印变量名称和值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">tst_strsig</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回给定信号编号的对应字符串。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">tst_strerrno</span><span class="token punctuation">(</span><span class="token keyword">int</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回给定错误号对应的字符串。首选使用此函数将_errno_值转换为字符串。您不应 在测试用例中使用_strerror()函数。_</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">tst_strstatus</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>_返回描述wait()_返回状态的字符串。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tst_set_max_runtime</span><span class="token punctuation">(</span><span class="token keyword">int</span> max_runtime<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>允许在测试设置（）中动态设置每个测试迭代的 max_runtime，超时以秒为单位指定。有一些测试用例的运行时间可以任意变化，这些可以通过将其设置为 TST_UNLIMITED_RUNTIME 来禁用超时。</p><p>刷新输出流，适当地处理错误。</p><p>_当您必须在调用fork()_或_clone()_之前刷新输出流时，很少需要此函数。请注意，_SAFE_FORK()<em>和_SAFE_CLONE()</em> 会自动调用此函数。请参阅 2.4 FILE 缓冲区和 fork() 以了解为什么需要这样做。</p><h3 id="1-3-测试临时目录"><a href="#1-3-测试临时目录" class="headerlink" title="1.3 测试临时目录"></a>1.3 测试临时目录</h3><p>如果_.needs_tmpdir_在_struct tst_test_中设置为_1_，则会创建唯一的测试临时文件并将其设置为测试工作目录。测试<strong>不得</strong>在该目录之外创建临时文件。使用这些标志时不需要设置标志：_.all_filesystems_、_.format_device_、_.mntpoint_、 <em>.mount_device</em> <em>.needs_checkpoints_、</em>.needs_device_、_.resource_file_ （这些标志意味着创建临时目录）。</p><blockquote><p>重要的 : _在test()<em>函数或测试_cleanup()</em> 中关闭所有文件描述符（指向测试临时目录中的文件，甚至是未链接的文件），否则测试可能会破坏 NFS 上的临时目录删除（寻找“NFS silly rename ”）。 |</p></blockquote><h3 id="1-4-安全宏"><a href="#1-4-安全宏" class="headerlink" title="1.4 安全宏"></a>1.4 安全宏</h3><p>安全宏旨在简化测试准备中的错误检查。无需调用系统 API 函数，检查它们的返回值并在操作失败时中止测试，您只需使用相应的安全宏。</p><p>尽可能使用它们。</p><p>而不是写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TBROK <span class="token operator">|</span> TERRNO<span class="token punctuation">,</span> <span class="token string">"opening /dev/null failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你只写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">fd <span class="token operator">=</span> <span class="token function">SAFE_OPEN</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>重要的 : SAFE_CLOSE() 函数还在成功关闭后将传递的文件描述符设置为 -1。 </p></blockquote><p> 它们还可以简化 sysfs 文件的读写，例如，您可以这样做：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SAFE_FILE_SCANF</span><span class="token punctuation">(</span><span class="token string">"/proc/sys/kernel/pid_max"</span><span class="token punctuation">,</span> <span class="token string">"%lu"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pid_max<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有关完整列表，请参阅_include/tst_safe_macros.h_、_include/tst_safe_stdio.h_和 <em>include/tst_safe_file_ops.h_以及_include/tst_safe_net.h 。</em></p><h3 id="1-5-测试特定的命令行选项"><a href="#1-5-测试特定的命令行选项" class="headerlink" title="1.5 测试特定的命令行选项"></a>1.5 测试特定的命令行选项</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tst_option</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>optstr<span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>arg<span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>help<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_可以使用struct tst_option_的_NULL_终止数组传递测试特定的命令行参数。optstr是命令行选项，即“o”或“o:”（如果选项有参数）_。_仅支持短选项。arg 是匹配时存储_optarg__的位置。_如果选项没有参数，则在选项存在时将其设置为非_NULL值。_帮助是_一个_简短的帮助字符串。</p><blockquote><p>笔记 : 测试参数不得与库中定义的常用测试参数冲突，当前使用的是<code>-i</code>、<code>-I</code>、<code>-C</code>和<code>-h</code>。 |</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tst_parse_int</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">,</span> <span class="token keyword">int</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_parse_long</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token keyword">long</span> min<span class="token punctuation">,</span> <span class="token keyword">long</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_parse_float</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token keyword">float</span> min<span class="token punctuation">,</span> <span class="token keyword">float</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_parse_filesize</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> min<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>_用于解析struct tst_option_中返回的字符串的帮助程序。</p><p>帮助程序在成功时返回零，在失败时返回_errno ，主要是__EINVAL_或_ERANGE_。</p><p>_如果str_是_NULL_，辅助函数是无操作的。</p><p>结果的有效范围包括_min_和_max_。</p><p>特别是，_tst_parse_filesize_函数接受前缀乘法，例如“k/K”代表千字节，“m/M”代表兆字节，“g/G”代表千兆字节。例如，10K 转换为 10240 字节。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;limits.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>str_threads<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> threads <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_parse_int</span><span class="token punctuation">(</span>str_threads<span class="token punctuation">,</span> <span class="token operator">&amp;</span>threads<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TBROK<span class="token punctuation">,</span> <span class="token string">"Invalid number of threads '%s'"</span><span class="token punctuation">,</span> str_threads<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test_threads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tst_option</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"t:"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>str_threads<span class="token punctuation">,</span> <span class="token string">"Number of threads (default 10)"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-运行时内核版本检测"><a href="#1-6-运行时内核版本检测" class="headerlink" title="1.6 运行时内核版本检测"></a>1.6 运行时内核版本检测</h3><p>新添加的内核功能的测试用例需要比特定版本更新的内核才能运行。跳过旧内核测试所需要做的就是将_struct tst_test_中的_.min_kver_字符串设置为所需的最低内核版本，例如_.min_kver = “4.10.0”_。</p><p>对于更复杂的操作，例如跳过特定范围内核版本的测试，可以使用以下函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tst_kvercmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> r1<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">,</span> <span class="token keyword">int</span> r3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">tst_kern_exv</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>dist_name<span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>extra_ver<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_kvercmp2</span><span class="token punctuation">(</span><span class="token keyword">int</span> r1<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">,</span> <span class="token keyword">int</span> r3<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">tst_kern_exv</span> <span class="token operator">*</span>vers<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个函数用于运行时内核版本检测。_他们解析uname()_的输出并将其与传递的值进行比较。</p><p>返回值类似于_strcmp()_函数，即零表示相等，负值表示内核比预期值旧，正表示它较新。</p><p>第二个函数_tst_kvercmp2()_允许指定每个供应商的内核版本表，因为供应商通常向后移植修复到他们的内核，即使内核版本不建议，测试也可能相关。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_kvercmp</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TCONF<span class="token punctuation">,</span> <span class="token string">"Test valid only for kernel &lt; 5.19"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_kern_exv</span> kvers<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token string">"UBUNTU"</span><span class="token punctuation">,</span> <span class="token string">"4.4.0-48.69"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_kvercmp2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> kvers<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">/* code for kernel &lt; v4.4.27 or ubuntu kernel &lt; 4.4.0-48.69 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>| </p><p>警告</p><p> | shell _tst_kvercmp_将结果映射为无符号整数——进程退出值。 |</p><h3 id="1-7-Fork-ing"><a href="#1-7-Fork-ing" class="headerlink" title="1.7 Fork()-ing"></a>1.7 Fork()-ing</h3><p><em>请注意，如果测试fork并且tst</em>*()_接口打印了消息 ，则数据可能仍在 libc/内核缓冲区中，并且这些 <strong>不会</strong>自动刷新。</p><p>_当stdout_被重定向到一个文件时会发生这种情况。在这种情况下， _stdout_不是行缓冲的，而是块缓冲的。因此，在分叉之后，缓冲区的内容将由父项和每个子项打印。</p><p>为避免这种情况，您应该使用_SAFE_FORK()_、_SAFE_CLONE()_或_tst_clone()_。</p><blockquote><p>重要的 : <em>如果您的测试用例分叉或调用SAFE_CLONE() ，</em> 则必须在测试结构中设置_.forks_child_标志。 |</p></blockquote><h3 id="1-8-在子进程中做测试"><a href="#1-8-在子进程中做测试" class="headerlink" title="1.8 在子进程中做测试"></a>1.8 在子进程中做测试</h3><p>_tst_res()_报告的结果通过共享内存块传播到父测试进程。</p><p>调用_tst_brk()<em>会导致子进程以非零退出值退出。这意味着在子进程中使用_SAFE</em>*()宏也是安全的。_</p><p>在测试库中等待_test()_函数执行后存活的孩子。不干净的子进程退出（被信号、非零退出值等杀死）将导致主测试进程以_tst_brk()_退出，这尤其意味着从子进程传播的_TBROK_将导致整个测试以_TBROK_退出。</p><p>_如果一个测试需要一个发生段错误或做任何其他导致它不干净地退出的孩子，您需要做的就是从test()<em>函数中等待这样的孩子，以便在主测试退出 test() 函数之前 收割_它</em> 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">void</span> <span class="token function">tst_reap_children</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>tst_reap_children _()<em>函数使进程等待其所有子进程，并在其中任何一个返回非零退出代码时以_tst_brk(TBROK, … )退出。</em></p><p>使用_SAFE_CLONE_或_tst_clone_时，这可能不起作用，具体取决于传递给克隆的参数。以下对_SAFE_CLONE 的调用与__fork()_相同，因此将按预期工作。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tst_clone_args</span> args <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>exit_signal <span class="token operator">=</span> SIGCHLD<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">SAFE_CLONE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果_exit_signal_设置为其他值，那么这将中断 _tst_reap_children_。除非测试代码采取特定操作，否则预计所有要克隆的参数都不会与 LTP 库一起使用。</p><p>从_exec()<em>启动的二进制文件中使用_tst_res()</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* test.c */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_GNU_SOURCE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">do_test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"test_exec_child"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">char</span> path<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_get_path</span><span class="token punctuation">(</span><span class="token string">"test_exec_child"</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TCONF<span class="token punctuation">,</span> <span class="token string">"Couldn't find test_exec_child in $PATH"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">execve</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL <span class="token operator">|</span> TERRNO<span class="token punctuation">,</span> <span class="token string">"EXEC!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> do_test<span class="token punctuation">,</span><span class="token punctuation">.</span>child_needs_reinit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/* test_exec_child.c */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TST_NO_DEFAULT_MAIN</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">tst_reinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"Child passed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tst_res _()_函数也可以从_exec()_启动的二进制文件中使用，父测试进程必须设置 .child_needs_reinit_标志_，以便库为此做好准备，并且必须确保_LTP_IPC_PATH_环境变量被传递下来，然后程序必须在_main()<em>中调用的第一件事 是设置 IPC 的_tst_reinit() 。</em></p><h3 id="1-9-Fork-与父子同步"><a href="#1-9-Fork-与父子同步" class="headerlink" title="1.9 Fork()与父子同步"></a>1.9 Fork()与父子同步</h3><p>由于 LTP 测试是为 Linux 编写的，因此大多数测试都涉及 fork()-ing 和父子进程同步。LTP 包括一个检查点库，它提供基于等待/唤醒 futex 的功能。</p><p>为了使用检查点，<em>结构 tst_test_中的</em>.needs_checkpoints_标志必须设置为_1_ ，这会导致测试库在调用_test()_函数之前初始化检查点。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token function">TST_CHECKPOINT_WAIT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">TST_CHECKPOINT_WAIT2</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> msec_timeout<span class="token punctuation">)</span><span class="token function">TST_CHECKPOINT_WAKE</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token function">TST_CHECKPOINT_WAKE2</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> nr_wake<span class="token punctuation">)</span><span class="token function">TST_CHECKPOINT_WAKE_AND_WAIT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查点接口提供一对唤醒和等待功能。id是无符号整数，它指定要唤醒_/_等待的检查点。事实上，它是存储在共享内存中的数组的索引，因此它从 _0_开始，并且应该有足够的空间容纳至少数百个数组。</p><p>TST_CHECKPOINT_WAIT _()_和_TST_CHECKPOINT_WAIT2()_暂停进程执行，直到它被唤醒或达到超时。</p><p>TST_CHECKPOINT_WAKE _()_唤醒一个等待检查点的进程。如果没有进程在等待，该函数将重试直到成功或达到超时。</p><p>如果达到超时，进程退出并显示适当的错误消息（使用 _tst_brk()_）。</p><p>TST_CHECKPOINT_WAKE2 _()与__TST_CHECKPOINT_WAKE()_的作用相同，但可用于精确唤醒_nr_wake_进程。</p><p>TST_CHECKPOINT_WAKE_AND_WAIT _()_是执行唤醒然后立即等待同一检查点的简写。</p><p>通过_SAFE_FORK()_创建的子进程已准备好使用检查点同步功能，因为它们自动继承了映射页面。</p><p>通过_exec()_启动的子进程或任何其他未从测试进程派生的进程必须通过调用_tst_reinit()_来初始化检查点。</p><p>有关接口的详细信息，请查看_include/tst_checkpoint.h_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token comment">/* * Waits for process state change. * * The state is one of the following: * * R - process is running * S - process is sleeping * D - process sleeping uninterruptibly * Z - zombie process * T - process is traced */</span><span class="token function">TST_PROCESS_STATE_WAIT</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> state<span class="token punctuation">,</span> msec_timeout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TST_PROCESS_STATE_WAIT _()_等待直到进程_pid_处于请求 _状态_或达到超时。调用轮询<code>/proc/pid/stat</code>以获取此信息。超时为 0 将无限等待。</p><p>超时时返回 -1 并将 errno 设置为 ETIMEDOUT。</p><p>它主要与状态_S_一起使用，这意味着进程正在内核中休眠，例如在_pause()_或任何其他阻塞系统调用中。</p><h3 id="1-10-信号和信号处理器"><a href="#1-10-信号和信号处理器" class="headerlink" title="1.10 信号和信号处理器"></a>1.10 信号和信号处理器</h3><p>如果您需要使用信号处理程序，请保持代码简短。不要忘记信号处理程序是异步调用的，可以在任何地方中断代码执行。</p><p>这意味着当全局状态从测试代码和信号处理程序发生变化时会出现问题，这偶尔会导致：</p><ul><li><p>数据损坏（数据进入不一致状态），例如，对_FILE_对象的任何操作都可能发生这种情况。</p></li><li><p>死锁，例如，如果您同时从测试代码和信号处理程序 调用_malloc(2)_、_free(2)等，因为__malloc_对其内部数据结构具有全局锁定，就会发生这种情况。（注意 _malloc(2)_也在内部被 libc 函数使用。）</p></li><li><p>任何其他不可重现和意外的行为。</p></li></ul><p>很常见的错误是从信号处理程序调用_exit(3) 。_请注意，此函数不是信号异步安全的，因为它会刷新缓冲区等。如果您需要立即从信号处理程序退出测试，请改用__exit(2)_。</p><blockquote><p>提示 : 有关信号异步安全功能的列表， 请参见_man 7 signal </p></blockquote><p>如果信号处理程序设置了一个变量，它的声明必须是_volatile_，否则编译器可能会错误地优化代码。这是因为在编译器代码流分析中可能不会更改该变量。C99 中定义了_sig_atomic_t_ 类型，但这个类型<strong>并不</strong>意味着_volatile_（它只是 _int_的_typedef_）。因此，从信号处理程序更改的标志的正确类型是_volatile int_或_volatile sig_atomic_t_。</p><p>如果在测试中预期会发生崩溃（例如，由信号 SIGSEGV 触发），您可以通过调用 tst_no_corefile() 函数来避免创建核心文件。这对调用它的进程（及其子进程）生效，除非它们随后修改了 RLIMIT_CORE。</p><p>请注意，LTP 库将获取任何测试未获取自身的进程，并将任何非零退出代码报告为失败。</p><h3 id="1-11-内核模块"><a href="#1-11-内核模块" class="headerlink" title="1.11 内核模块"></a>1.11 内核模块</h3><p>在某些情况下，测试需要内核部分和用户空间部分，幸运的是，LTP 可以构建内核模块，然后在测试开始时为您将其插入内核。有关详细信息，请参阅_测试用例/内核/设备驱动程序/块_。</p><h3 id="1-12-有用的宏"><a href="#1-12-有用的宏" class="headerlink" title="1.12 有用的宏"></a>1.12 有用的宏</h3><p>_这些宏在include/tst_common.h_中定义。</p><p>返回静态定义数组的大小，即 <em>(sizeof(arr) / sizeof(*arr))</em></p><p>将 x 对齐为 a 的下一个倍数。a 必须是 2 的幂。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TST_TO_STR</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>  <span class="token comment">/* stringification */</span><span class="token function">TST_TO_STR_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">/* macro expansion */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字符串化宏。</p><h3 id="1-13-文件系统类型检测和skiplist"><a href="#1-13-文件系统类型检测和skiplist" class="headerlink" title="1.13 文件系统类型检测和skiplist"></a>1.13 文件系统类型检测和skiplist</h3><p>已知某些测试在某些文件系统上会失败（您不能在 TMPFS 上交换，有未实现的_fcntl()_等）。</p><p>如果您的测试需要在某些文件系统上跳过，请使用 tst_test 结构中的_.skip_filesystems_字段，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">.</span>skip_filesystems <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token string">"tmpfs"</span><span class="token punctuation">,</span>                <span class="token string">"ramfs"</span><span class="token punctuation">,</span>                <span class="token string">"nfs"</span><span class="token punctuation">,</span>                <span class="token constant">NULL</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当设置_.all_filesystems标志时，_ _.skip_filesystems_列表将传递给检测支持文件系统的函数，任何列出的文件系统都不包含在支持文件系统的结果列表中。</p><p>如果测试需要根据文件系统类型调整预期，也可以在运行时检测文件系统类型。当只有测试的子集不适用于给定的文件系统时，最好使用此方法。</p><p>| </p><p>笔记</p><p> | <strong>在不</strong>使用 <em>.all_filesystems 的_测试中，</em>.skip_filesystems_ 中的 ext2、ext3 或 ext4需要定义为_ext2/ext3/ext4_。原因是由于功能重叠，很难检测到使用过的文件系统。使用_.skip_filesystems_<strong>和</strong><em>.all_filesystems_的 OTOH 测试只能跳过</em>.all_filesystems_中实际使用的文件系统：ext2、ext3、ext4、xfs、btrfs、vfat、exfat、ntfs、tmpfs（在_fs_type_whitelist[]_中定义）。列出其他文件系统没有意义。 |</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token function">tst_fs_type</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> TST_NFS_MAGIC<span class="token operator">:</span><span class="token keyword">case</span> TST_TMPFS_MAGIC<span class="token operator">:</span><span class="token keyword">case</span> TST_RAMFS_MAGIC<span class="token operator">:</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TCONF<span class="token punctuation">,</span> <span class="token string">"Subtest not supported on %s"</span><span class="token punctuation">,</span>        <span class="token function">tst_fs_type_name</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-14-LTP-库中的线程安全"><a href="#1-14-LTP-库中的线程安全" class="headerlink" title="1.14 LTP 库中的线程安全"></a>1.14 LTP 库中的线程安全</h3><p>在多线程测试中使用库_tst_res()函数是安全的。_</p><p>只有主线程必须从_test()_函数返回到测试库，并且只有在可能调用任何库函数的所有线程都已终止后才能完成。这尤其意味着可能调用 _tst_brk()的线程必须在__test()_函数的执行返回到库之前终止。_这通常由主线程在test()_函数末尾加入所有工作线程来完成。请注意，在从其中一个线程调用_tst_brk()_的情况下，主线程永远不会访问库代码，因为它至少会在调用_tst_brk()_的线程上的_pthread_join()_中休眠，直到_exit()__由tst_brk()_调用。</p><p>_在从tst_brk()_输入清除的情况下，测试提供的清除函数与其余线程<strong>同时</strong>运行。后续进入_tst_brk()_的线程必须在用户提供的清理函数开始时暂停或终止。在测试清理之前，可能需要停止或退出其余线程。例如，创建新文件的线程应该在删除临时目录之前停止。</p><p>以下代码示例显示了使用原子增量作为保护的线程安全清理函数示例。该库在执行从用户提供的清理返回后调用其清理，并期望只有一个线程从用户提供的清理返回到测试库。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">int</span> flag<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flag<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* if needed stop the rest of the threads here */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* then do cleanup work */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* only one thread returns to the library */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-15-用块设备测试"><a href="#1-15-用块设备测试" class="headerlink" title="1.15 用块设备测试"></a>1.15 用块设备测试</h3><p>某些测试需要块设备（inotify 测试、系统调用_EROFS_失败等）。LTP 库包含准备测试设备的代码。</p><p>如果设置了_struct tst_test中的__.needs_device_标志，则_tst_device_ 结构将使用测试设备的路径和要使用的默认文件系统进行初始化。</p><p>_您还可以通过设置.dev_min_size_来请求以兆字节为单位的最小设备大小， 然后保证设备至少具有请求的大小。</p><p>如果设置了_.format_device_标志，设备也会使用文件系统进行格式化。如果需要，您可以使用_.dev_fs_type_覆盖默认文件系统类型，并通过_.dev_fs_opts_和 <em>.dev_extra_opts_指针将其他选项传递给 mkfs。请注意，</em>.format_device_暗示_.needs_device_ 没有必要同时设置两者。</p><p>如果设置了_.mount_device_，则设备将安装在_.mntpoint_处，该文件用于传递将创建并用作安装目标的目录名称。<em>您可以通过.mnt_flags</em> 和_.mnt_data_指针将附加标志和数据传递给挂载命令。请注意，_.mount_device_意味着_.needs_device_ 和_.format_device_，因此无需设置后两者。</p><p>如果设置了_.needs_rofs_，则只读文件系统将挂载在_.mntpoint_上，该文件系统应该用于_EROFS_测试。</p><p>如果设置了_.all_filesystems，<em>测试函数将针对所有支持的文件系统执行。支持的文件系统是根据 <em>mkfs.$fs_助手的存在和内核支持来检测的。对于每个支持的文件系统， <em>tst_device.fs_type_设置为当前测试的 fs 类型，如果 设置了</em>.format_device_，则设备也被格式化，如果设置了</em>.mount_device_，则它挂载在</em>.mntpoint_。此外，每次执行测试功能都会重置测试超时。此标志预期用于文件系统相关的系统调用，这些系统调用至少部分在文件系统特定代码中实现，例如_fallocate()_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">struct</span> <span class="token class-name">tst_device</span> <span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fs_type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">tst_device</span> <span class="token operator">*</span>tst_device<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_umount</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在环境中将_LTP_DEV_传递给测试，库会检查该文件是否存在以及它是否为块设备，如果 设置了_.device_min_size_，还会检查设备大小。如果未设置_LTP_DEV_ 或未满足大小要求，则会创建一个临时文件并将其附加到自由循环设备。</p><p>如果没有可用的设备并且循环设备无法初始化，则测试以_TCONF_退出。</p><p>tst_umount _()函数的工作原理与__umount(2)_完全相同，但在_EBUSY_上重试几次。这是因为各种桌面守护进程（以 gvfsd-trash 闻名）可能会愚蠢到探测所有新安装的文件系统，这会导致_umount(2)_失败并返回_EBUSY_。</p><p>| </p><p>重要的</p><p> | 所有测试用例都应该使用_tst_umount()_而不是_umount(2)_来卸载文件系统。 |</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_find_free_loopdev</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token class-name">size_t</span> path_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此函数找到空闲的 loopdev 并返回空闲的 loopdev minor（-1 表示没有空闲的 loopdev）。如果 path 为非 NULL，它将填充空闲的 loopdev 路径。如果你想使用自定义的循环设备，我们可以在测试中调用_tst_find_free_loopdev(NULL, 0)_ 来获得一个空闲的次设备号，然后 mknod。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">tst_dev_bytes_written</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此函数读取测试块设备统计文件 ( <em>/sys/block/<device>/stat</device></em> ) 并返回自上次调用此函数以来写入的字节。为避免 FS 延迟 IO 元数据/缓存干扰，我们建议在第一次调用 tst_dev_bytes_written 之前执行“syncfs”。 为此目的创建了一个名为_tst_dev_sync()_的内联函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">void</span> <span class="token function">tst_find_backing_dev</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token class-name">size_t</span> dev_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个函数找到这个路径所属的block dev，使用sysfs中的uevent。对于 Btrfs，它使用_/sys/fs/btrfs/UUID/devices/DEV_NAME/uevent_；对于其他文件系统，它使用_/sys/dev/block/MAJOR:MINOR/uevent_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token class-name">uint64_t</span> <span class="token function">tst_get_device_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev_path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此函数获取给定块设备的大小，它首先检查 dev_path_是否_有效，如果是，则返回以 MB 为单位的大小，否则返回 -1。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_dev_block_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此函数返回特定的物理设备块大小<code>path</code>。它找到所在的设备<code>path</code>，然后使用<code>ioctl</code>(BLKSSZGET) 获取物理设备块大小。</p><h3 id="1-16-用文件系统格式化设备"><a href="#1-16-用文件系统格式化设备" class="headerlink" title="1.16 用文件系统格式化设备"></a>1.16 用文件系统格式化设备</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">SAFE_MKFS</span><span class="token punctuation">(</span>tst_device<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> tst_device<span class="token operator">-&gt;</span>fs_type<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此函数采用设备路径、文件系统类型和传递给 mkfs 的额外选项数组。</p><p>fs 选项_fs_opts_应该是_NULL_（如果没有），或者是 _NULL_终止的字符串数组，例如： <code>const char *const opts[] = {"-b", "1024", NULL}</code>。</p><p>额外的选项_extra_opts_应该是_NULL_（如果没有的话），或者是一个 以_NULL_结尾的字符串数组，例如<code>{"102400", NULL}</code>; <em>extra_opts</em> 将在设备名称之后传递。例如：<code>mkfs -t ext4 -b 1024 /dev/sda1 102400</code> 在这种情况下。</p><p>_请注意，最好存储可以通过fs_opts_数组在设备名称之前或之后传递的选项。</p><h3 id="1-17-验证文件系统的空闲空间"><a href="#1-17-验证文件系统的空闲空间" class="headerlink" title="1.17 验证文件系统的空闲空间"></a>1.17 验证文件系统的空闲空间</h3><p>一些测试对文件系统的可用空间有大小要求。如果不满足这些要求，则应跳过测试。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fs_has_free</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mult<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>_如果有足够的空间， tst_fs_has_free()_函数返回 1，否则返回 0。</p><p>路径是文件系统中_任何_目录/文件的路径名。</p><p>mult是乘数，是_TST_BYTES_、<em>TST_KB_、_TST_MB_或_TST_GB_之一_。</em></p><p>_所需的可用空间由size * mult_计算，例如 _tst_fs_has_free(“/tmp/testfile”, 64, TST_MB)<em>如果文件系统（</em>“/tmp/testfile”_所在）至少有 64MB 可用空间，则返回 1，并且0 如果不是。</p><h3 id="1-18-文件、目录和-fs-限制"><a href="#1-18-文件、目录和-fs-限制" class="headerlink" title="1.18 文件、目录和 fs 限制"></a>1.18 文件、目录和 fs 限制</h3><p>一些测试需要知道指向常规文件或目录的最大链接数，例如_rename(2)_或_linkat(2)_来测试_EMLINK_错误。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fs_fill_hardlinks</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>_尝试获取dir_内常规文件的最大硬链接数。</p><p>此函数使用_link(2)_创建单个文件的硬链接，直到它获得_EMLINK_或创建 65535 个链接。如果达到限制，则返回最大硬链接数，_目录_中将填充格式为“testfile%i”的硬链接，其中 i 属于 [0, limit) 区间。如果没有达到限制，或者如果 _link(2)因__ENOSPC_或_EDQUOT_失败，则返回零并删除以前创建的文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fs_fill_subdirs</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>尝试获取目录中子目录的最大数量。</p><p>| </p><p>笔记</p><p> | 这个数字取决于文件系统_dir_所在的位置。对于当前内核，子目录限制不适用于所有文件系统（适用于 ext2、ext3、minix、sysv 等）。如果测试在其他一些文件系统上运行，如 ramfs、tmpfs，它甚至不会尝试达到限制并返回 0。 |</p><p>此函数使用_mkdir(2)在__dir_中创建目录，直到它获得 _EMLINK_或创建 65535 个目录。如果达到限制，则返回子目录的最大数量，并且_目录_中填充格式为“testdir%i”的子目录，其中 i 属于 [0, limit - 2) 区间（因为每个新创建的目录已经有两个链接- _._和来自父目录的链接）。如果没有达到限制或者如果_mkdir(2)因__ENOSPC_或_EDQUOT_失败，则返回零并删除以前创建的目录。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_dir_is_empty</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">int</span> verbose<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果目录为空则返回非零，否则返回零。</p><p>如果目录仅包含_._ 和_…_ _</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">void</span> <span class="token function">tst_purge_dir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>删除给定目录的内容但保留目录本身。用于清理测试用例或测试迭代之间的临时目录和挂载点。出错时用_TBROK_终止程序。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fill_fd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">char</span> pattern<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bs<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bcount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用文件描述符以指定模式填充文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_prealloc_size_fd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bs<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bcount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>_使用fallocate()_预分配指定的空间量。如果_fallocate()_失败，则回退到 _tst_fill_fd()_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_fill_file</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> pattern<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bs<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bcount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用文件路径创建/覆盖具有指定模式的文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_prealloc_file</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bs<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bcount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建/覆盖文件并为其预分配指定的空间量。分配的空间不会被初始化为任何特定的内容。</p><h3 id="1-19-获取未使用的-PID-号"><a href="#1-19-获取未使用的-PID-号" class="headerlink" title="1.19 获取未使用的 PID 号"></a>1.19 获取未使用的 PID 号</h3><p>一些测试需要一个_PID_，操作系统不使用它（不属于其中的任何进程）。例如，如果 kill(2) 传递了这样的_PID ，它应该将 errno 设置为__ESRCH_。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token class-name">pid_t</span> <span class="token function">tst_get_unused_pid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>返回操作系统或其中的任何进程未使用的_PID值。_</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_get_free_pids</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>返回系统中未使用的 pid 数。请注意，一旦调用返回，此数字可能会有所不同，并且应该仅用于粗略估计。</p><h3 id="1-20-运行可执行文件"><a href="#1-20-运行可执行文件" class="headerlink" title="1.20 运行可执行文件"></a>1.20 运行可执行文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">int</span> <span class="token function">tst_cmd</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>stdout_path<span class="token punctuation">,</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>stderr_path<span class="token punctuation">,</span>        <span class="token keyword">enum</span> <span class="token class-name">tst_cmd_flags</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_tst_cmd()是__vfork() + execvp()_的包装器，它提供了一种执行外部程序的方法。</p><p>_argv[]_是一个_以 NULL_结尾的字符串数组，以程序名称开头，后跟可选参数。</p><p>_TST_CMD_PASS_RETVAL_枚举_tst_cmd_flags_使_tst_cmd()_将 程序退出代码返回给调用者，否则_tst_cmd()<em>在失败时退出测试。_TST_CMD_TCONF_ON_MISSING_检查</em>$PATH中的程序，如果没有找到则以__TCONF_退出。</p><p>如果_execvp()_失败并且设置了枚举_TST_CMD_PASS_RETVAL_标志，则如果_execvp()因__ENOENT_而失败则返回值为_255_，否则_返回值为 254_。</p><p>_stdout_path_和_stderr_path_确定重定向程序 stdout 和 stderr I/O 流的位置。</p><p>SAFE_CMD _()_宏可用于自动处理非零退出（以_TBROK_退出）和_ENOENT （以__TCONF_退出）。</p><p>例子</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> cmd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* Store output of 'ls -l' into log.txt */</span><span class="token function">tst_cmd</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> <span class="token string">"log.txt"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-21-测量运行时间和辅助函数"><a href="#1-21-测量运行时间和辅助函数" class="headerlink" title="1.21 测量运行时间和辅助函数"></a>1.21 测量运行时间和辅助函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_timer.h"</span></span><span class="token keyword">void</span> <span class="token function">tst_timer_check</span><span class="token punctuation">(</span><span class="token class-name">clockid_t</span> clk_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tst_timer_start</span><span class="token punctuation">(</span><span class="token class-name">clockid_t</span> clk_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tst_timer_stop</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token function">tst_timer_elapsed</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timer_elapsed_ms</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timer_elapsed_us</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_timer_expired_ms</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tst_timer_check _()<em>函数检查是否支持指定的_clk_id ，否则使用__TCONF_退出测试。它应该 在任何需要清理的资源被初始化之前用在测试_setup()中，因此它不包含清理函数参数。</em></p><p>tst_timer_start _()_标记开始时间并存储_clk_id_以供进一步使用。</p><p>tst_timer_stop _()_使用与上次调用_tst_timer_start()相同的__clk_id_标记停止时间。</p><p>tst_timer_elapsed _*()_以多种格式和单位返回定时器启动和上次定时器停止之间的时间差。</p><p>tst_timer_expired_ms _()函数检查由__tst_timer_start()_启动的定时器是否 运行时间超过 ms 毫秒。如果计时器已过期，则该函数返回非零值，否则返回零值。</p><p>| </p><p>重要的</p><p> | 计时器函数在内部使用_clock_gettime()_ ，它需要与旧 glibc 上的_-lrt_链接。请不要忘记在 Makefile 中添加 _LDLIBS+=-lrt_。 |</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_timer.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">tst_timer_check</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">tst_timer_start</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tst_timer_expired_ms</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到期计时器示例用法。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_to_us</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_to_ms</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token function">tst_us_to_timeval</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> us<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token function">tst_ms_to_timeval</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tst_timespec_lt</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token function">tst_timespec_add_us</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> us<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token function">tst_timespec_diff</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_diff_us</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_diff_ms</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token function">tst_timespec_abs_diff</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_abs_diff_us</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">tst_timespec_abs_diff_ms</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> t1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前四个函数是简单的内联转换函数。</p><p>_如果t1_早于 <em>t2</em> ，则tst_timespec_lt _()_函数返回非零值。</p><p>tst_timespec_add_us _()_函数将_us_微秒添加到 timespec <em>t_中。预计美国将是积极的_。</em></p><p>tst_timespec_diff _*()_函数返回两次之间的差异， 预计_t1_晚于_t2_。</p><p>tst_timespec_abs_diff _*()_函数返回两个时间之差的绝对值。</p><p>| </p><p>笔记</p><p> | 所有转换为 ms 和 us 的值都四舍五入。 |</p><h3 id="1-22-数据文件"><a href="#1-22-数据文件" class="headerlink" title="1.22 数据文件"></a>1.22 数据文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> res_files<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token string">"bar"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>resource_files <span class="token operator">=</span> res_files<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果测试需要将其他文件复制到测试临时目录，您需要做的就是在 tst_test 结构的_NULL_终止数组_.resource_files中列出它们的文件名。_</p><p>设置资源文件时自动创建测试临时目录，还需要设置_.needs_tmpdir 。_</p><p><code>datafiles</code>测试库首先查找数据文件，这些文件要么存储在<code>$PWD</code>测试开始时 调用的目录中，要么存储在<code>$LTPROOT/testcases/data/${test_binary_name}</code>. 如果未找到该文件，则库会在测试开始时<code>$LTPROOT/testcases/bin/</code>进行调查。<code>$PWD</code>这确保了测试用例可以毫不费力地复制文件，无论是从编译目录开始测试还是安装 LTP 时。</p><p>文件被复制到新创建的测试临时目录，该目录在执行_test()_函数时设置为测试工作目录。</p><h3 id="1-23-代码路径追踪"><a href="#1-23-代码路径追踪" class="headerlink" title="1.23 代码路径追踪"></a>1.23 代码路径追踪</h3><p>_tst_res_是一个宏，所以当你在一个文件中定义一个函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">do_action</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"check passed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"check failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_并从另一个文件调用它，此函数中tst_res_报告的文件和行将来自前一个文件。</p><p>_TST_TRACE_可以使此类情况的分析更加容易。这是一个宏，它插入对_tst_res(TINFO, … ) 的_调用，以防其参数计算结果为非零。_在对tst_res(TINFO, … )_的调用中，文件和行将使用_TST_TRACE_的实际位置进行扩展。</p><p>例如，如果另一个文件包含：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TST_TRACE</span><span class="token punctuation">(</span><span class="token function">do_action</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的输出可能类似于：</p><p>common.h:9: FAIL: 检查失败 test.c:8: INFO: do_action(arg) 失败</p><h3 id="1-24-受污染的内核"><a href="#1-24-受污染的内核" class="headerlink" title="1.24 受污染的内核"></a>1.24 受污染的内核</h3><p>如果需要检测一个测试用例是否触发了内核警告、bug 或 oops，可以使用以下方法检测 TAINT_W 或 TAINT_D：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>taint_check <span class="token operator">=</span> TST_TAINT_W <span class="token operator">|</span> TST_TAINT_D<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tst_taint_check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"kernel has issues"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS<span class="token punctuation">,</span> <span class="token string">"kernel seems to be fine"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要初始化污点检查，您必须在tst_test 结构的_taint_check_属性中设置要测试的污点标志。然后，LTP 库将在测试设置期间自动调用_tst_taint_init() 。<em>如果正在运行的内核不完全支持请求的标志，该函数将生成_TCONF</em> ，如果内核在执行测试之前已经被污染，则_生成 TBROK 。_</p><p>LTP 库将在测试结束时自动检查内核污点。如果在 struct tst_test 中设置了_.all_filesystems ，污点检查将在每个文件系统之后执行，并且污点将使用__TFAIL_提前中止测试。您也可以选择在_run()<em>期间调用_tst_taint_check()</em> ，它返回 0 或如前所述在_/proc/sys/kernel/tainted_中设置的污染标志。</p><p>根据您的内核版本，并非所有受污染标志都受支持。</p><h3 id="1-25-校验和"><a href="#1-25-校验和" class="headerlink" title="1.25 校验和"></a>1.25 校验和</h3><p>LTP 支持 CRC32c 校验和生成。为了使用它，测试应该包含_tst_checksum.h_头文件，然后可以调用_tst_crc32c()_。</p><h3 id="1-26-检查内核对驱动程序的支持"><a href="#1-26-检查内核对驱动程序的支持" class="headerlink" title="1.26 检查内核对驱动程序的支持"></a>1.26 检查内核对驱动程序的支持</h3><p>某些测试可能需要特定的内核驱动程序，这些驱动程序可以编译或构建为模块。如果_.needs_drivers_指向一个_以 NULL_结尾的内核模块名称数组，则这些名称都会被检查，并且测试会在第一个丢失的驱动程序上以_TCONF退出。_</p><p>由于它依赖于 modprobe 命令，如果命令本身在系统上不可用，则将跳过检查。</p><h3 id="1-27-保存和恢复-x2F-proc-sys-值"><a href="#1-27-保存和恢复-x2F-proc-sys-值" class="headerlink" title="1.27 保存和恢复 /proc|sys 值"></a>1.27 保存和恢复 /proc|sys 值</h3><p>可以指示 LTP 库保存和恢复指定 (/proc|sys) 文件的值。这是通过初始化的 tst_test 结构字段_save_restore_实现的。它是一个以 NULL 结尾的结构 _tst_path_val_数组，其中每个 tst_path_val.path 代表一个文件，其值在测试开始时保存并在测试结束时恢复。如果在 tst_path_val.val 中传递了非 NULL 字符串，它将在测试开始时写入相应的文件。仅保存和恢复指定文件的第一行。</p><p>默认情况下，如果文件是只读的或不存在，测试将以 TCONF 结束。如果可选的新值写入失败，测试将以_TBROK_结束。可以使用 tst_path_val.flags 更改此行为：</p><ul><li><p><em>TST_SR_TBROK_MISSING</em> –如果文件不存在则使用_TBROK_结束测试</p></li><li><p><em>TST_SR_TCONF_MISSING</em> –如果文件不存在则使用_TCONF_结束测试</p></li><li><p><em>TST_SR_SKIP_MISSING</em> – 如果文件不存在则不保存文件继续</p></li><li><p><em>TST_SR_TBROK_RO</em> –如果文件是只读的，则使用_TBROK_结束测试</p></li><li><p><em>TST_SR_TCONF_RO</em> –如果文件是只读的，则使用_TCONF_结束测试</p></li><li><p><em>TST_SR_SKIP_RO</em> – 如果文件是只读的则不保存文件继续</p></li><li><p><em>TST_SR_IGNORE_ERR</em> – 将新值写入文件时忽略错误</p></li></ul><p>常见的标志组合也有快捷方式：</p><ul><li><p><em>TST_SR_TCONF</em> – 等同于_TST_SR_TCONF_MISSING | TST_SR_TCONF_RO_</p></li><li><p><em>TST_SR_TBROK</em> – 等同于_TST_SR_TBROK_MISSING | TST_SR_TBROK_RO_</p></li><li><p><em>TST_SR_SKIP</em> – 等同于_TST_SR_SKIP_MISSING | TST_SR_SKIP_RO_</p></li></ul><p>_restore_总是严格的，如果遇到任何错误都会发出警告。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>save_restore <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tst_path_val</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"/proc/sys/kernel/core_pattern"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> TST_SR_TCONF<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"/proc/sys/user/max_user_namespaces"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> TST_SR_SKIP<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"/sys/kernel/mm/ksm/run"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> TST_SR_TBROK<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-28-解析内核-config"><a href="#1-28-解析内核-config" class="headerlink" title="1.28 解析内核.config"></a>1.28 解析内核.config</h3><p>通常，测试用例应该尝试根据当前运行的内核自动检测尽可能多的内核特性。我们确实有 tst_check_driver() 来检查系统上是否存在可以编译为内核模块的功能，可以通过检查_ENOSYS_ errno 等来检测禁用的系统调用。</p><p>然而，在极少数情况下，无法根据内核用户空间 API 检测到核心内核功能，我们不得不求助于解析内核 .config。</p><p>对于这种情况，测试应该设置_NULL_终止的_.needs_kconfigs_ 布尔表达式数组，并限制 kconfig 变量。布尔表达式由变量、两个二元运算_&amp;<em>和</em>|组成_ ，否定_！<em>和正确的括号顺序</em>()_。变量应采用“CONFIG_FOO[=bar]”的形式。</p><p><em>如果所有表达式的计算结果为True</em> ，测试将继续运行。缺少的变量映射到_False_以及具有不同于指定值的变量，例如_CONFIG_FOO=bar_如果值不是_bar_，则将评估为_False_。如果配置变量被指定为普通的 _CONFIG_FOO，_它被评估为真，它被设置为任何值（通常是 =y 或 =m）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>kconfigs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"CONFIG_X86_INTEL_UMIP | CONFIG_X86_UMIP"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>needs_kconfigs <span class="token operator">=</span> kconfigs<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-29-在测试执行期间更改挂钟时间"><a href="#1-29-在测试执行期间更改挂钟时间" class="headerlink" title="1.29 在测试执行期间更改挂钟时间"></a>1.29 在测试执行期间更改挂钟时间</h3><p>由于不同的原因，有些测试可能需要更改系统范围的时钟时间。每当发生这种情况时，必须在测试执行结束时恢复时钟，同时考虑该测试期间经过的时间量。</p><p>为了实现这一点，struct tst_test 有一个名为“restore_wallclock”的变量，该变量应设置为“1”，因此 LTP 知道它应该：(1) 在测试设置阶段初始化一个单调时钟，以及 (2) 使用该单调时钟来在测试清理阶段修复系统范围的时钟时间。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>restore_wallclock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-30-在一次测试中测试相似的系统调用"><a href="#1-30-在一次测试中测试相似的系统调用" class="headerlink" title="1.30 在一次测试中测试相似的系统调用"></a>1.30 在一次测试中测试相似的系统调用</h3><p>在某些情况下，内核有几个非常相似的系统调用，它们执行相同或非常相似的工作。这在 i386 上最为明显，我们通常有两个或三个系统调用版本。那是因为 i386 是第一个开发 Linux 的平台，而且大多数 API 错误也发生在那里。然而，这根本不限于 i386，版本 2 系统调用添加缺少的标志参数左右是很常见的。</p><p>在这种情况下，一遍又一遍地复制和粘贴测试代码没有多大意义，而不是让测试库提供对测试变体的支持。测试变体背后的想法很简单，我们每次使用不同的系统调用变体运行多次测试。</p><p>该实现由 test_variants 整数组成，如果设置，则表示测试变体的数量。然后每次使用全局 tst_variant 变量中的不同值分叉并执行 test_variants 次测试。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_foo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>tst_variant<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span><span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span><span class="token keyword">return</span> <span class="token function">syscall</span><span class="token punctuation">(</span>__NR_foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">TEST</span><span class="token punctuation">(</span>do_foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>tst_variant<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TINFO<span class="token punctuation">,</span> <span class="token string">"Testing foo variant 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TINFO<span class="token punctuation">,</span> <span class="token string">"Testing foo variant 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>test_variants <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-31-保护缓冲区"><a href="#1-31-保护缓冲区" class="headerlink" title="1.31 保护缓冲区"></a>1.31 保护缓冲区</h3><p>测试库支持受保护的缓冲区，这些缓冲区是这样分配的：</p><ul><li><p>缓冲区末尾后跟一个 PROT_NONE 页</p></li><li><p>缓冲区之前页面的剩余部分填充了随机金丝雀数据</p></li></ul><p>这意味着缓冲区之后的任何访问将产生分段错误或 EFAULT，具体取决于访问是分别发生在用户空间还是内核中。缓冲区之前的金丝雀也会捕获缓冲区外的任何写访问。</p><p>该补丁的目的是捕获在将缓冲区和结构传递给系统调用时发生的错误。新测试应该为传递给被测试系统调用的所有数据分配受保护的缓冲区，这些数据是由指针传递的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token operator">*</span>foo_ptr<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token operator">*</span>iov<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf_ptr<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>id<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>foo_ptr<span class="token operator">-&gt;</span>bar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>foo_ptr<span class="token operator">-&gt;</span>buf <span class="token operator">=</span> buf_ptr<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token function">tst_strdup</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>bufs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tst_buffers</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">&amp;</span>foo_ptr<span class="token punctuation">,</span> <span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>foo_ptr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token operator">&amp;</span>buf_ptr<span class="token punctuation">,</span> <span class="token punctuation">.</span>size <span class="token operator">=</span> BUF_SIZE<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token operator">&amp;</span>iov<span class="token punctuation">,</span> <span class="token punctuation">.</span>iov_sizes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_受保护的缓冲区可以在运行时通过tst_alloc()_或_tst_strdup()_以及通过填充 tst_test 结构中的 .bufs 数组在测试 setup()中分配 。</p><p>_到目前为止，tst_test 结构支持通过设置大小或 struct iovec 来分配普通缓冲区，它是递归分配的，包括由-1_终止的缓冲区大小数组描述的各个缓冲区。</p><h3 id="1-32-添加和删除功能"><a href="#1-32-添加和删除功能" class="headerlink" title="1.32 添加和删除功能"></a>1.32 添加和删除功能</h3><p>某些测试可能需要特定功能的存在或不存在。_使用tst_capability.h_提供的 API，测试作者可以尝试确保某些功能在测试期间存在或不存在。</p><p>例如; 下面我们尝试创建一个原始套接字，这需要 CAP_NET_ADMIN。在设置期间我们应该能够做到这一点，然后在运行期间它应该是不可能的。LTP 能力库将在设置之前检查我们是否具有此能力，然后在设置之后将其删除。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_capability.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_safe_net.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lapi/socket.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">TEST</span><span class="token punctuation">(</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>TST_RET <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL<span class="token punctuation">,</span> <span class="token string">"Created raw socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>TST_ERR <span class="token operator">!=</span> EPERM<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TFAIL <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span><span class="token string">"Failed to create socket for wrong reason"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">tst_res</span><span class="token punctuation">(</span>TPASS <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span> <span class="token string">"Didn't create raw socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">TEST</span><span class="token punctuation">(</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>TST_RET <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TCONF <span class="token operator">|</span> TTERRNO<span class="token punctuation">,</span> <span class="token string">"We don't have CAP_NET_RAW to begin with"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CLOSE</span><span class="token punctuation">(</span>TST_RET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>caps <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tst_cap</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">TST_CAP</span><span class="token punctuation">(</span>TST_CAP_REQ<span class="token punctuation">,</span> CAP_NET_RAW<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">TST_CAP</span><span class="token punctuation">(</span>TST_CAP_DROP<span class="token punctuation">,</span> CAP_NET_RAW<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看底部的测试结构。<em>我们用包含两个tst_cap结构的__NULL_终止数组填充了_caps_字段。_TST_CAP_REQ</em> 动作在设置前执行，_TST_CAP_DROP_在设置后执行。这意味着可以请求和删除功能。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>caps <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tst_cap</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">TST_CAP</span><span class="token punctuation">(</span>TST_CAP_REQ<span class="token punctuation">,</span> CAP_NET_RAW<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">TST_CAP</span><span class="token punctuation">(</span>TST_CAP_DROP<span class="token punctuation">,</span> CAP_SYS_ADMIN<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们请求_CAP_NET_RAW_，但删除_CAP_SYS_ADMIN_。如果该功能在允许集中，但不在有效集中，库将尝试允许它。如果它不在允许的集合中，那么它将失败并显示_TCONF_。</p><p>此 API 不需要安装_libcap 。__但是，它相对于libcap 的_功能有限。它只尝试在有效集中添加或删除功能。这意味着需要生成子进程的测试可能难以确保子进程可以使用正确的功能（请参阅功能 (7) 手册页）。</p><p>但是直接使用随时调用的_tst_cap_action(struct tst_cap *cap)_可以解决很多问题。如果您希望在设置开始时删除功能，这也会有所帮助。</p><h3 id="1-33-重现竞争条件"><a href="#1-33-重现竞争条件" class="headerlink" title="1.33 重现竞争条件"></a>1.33 重现竞争条件</h3><p>如果错误是由内核竞赛中的两个任务引起的，并且您希望创建回归测试（或错误修复验证测试），则应 使用_tst_fuzzy_sync.h库。_</p><p>它允许您在代码中指定两个比赛窗口。每个线程循环中的一个窗口（触发竞争通常需要多次迭代）。这些窗口显示可能发生竞争的模糊同步。它们不需要精确，因此是_模糊的_部分。如果竞争条件没有立即触发，那么库将开始尝试不同的时间。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_fuzzy_sync.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_fzsync_pair</span> fzsync_pair<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">tst_fzsync_pair_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">tst_fzsync_pair_cleanup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">tst_fzsync_run_b</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_fzsync_start_race_b</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/* This is the race window for thread B */</span>                <span class="token function">tst_fzsync_end_race_b</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> arg<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">tst_fzsync_pair_reset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">,</span> thread_b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">tst_fzsync_run_a</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">tst_fzsync_start_race_a</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* This is the race window for thread A */</span>                <span class="token function">tst_fzsync_end_race_a</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fzsync_pair<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> thread_a<span class="token punctuation">,</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>cleanup <span class="token operator">=</span> cleanup<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是使用模糊同步进行测试的最小模板。在一个简单的例子中，你只需要将你想要比赛的位放在_start_race_和 _end_race_之间。同时，每次迭代需要进行的任何设置都在窗口之外。</p><p>模糊同步同步_run_a_和_run_b_，它们充当障碍，因此在另一个线程赶上它之前，任何一个线程都不能前进。还有_pair_wait_函数，可用于在其他位置添加障碍。当然_start/end_race_a/b_也是一个障碍。</p><p>该库根据用户指定的超时以及一些其他启发式方法来决定测试应该运行多长时间。</p><p>_有关完整文档，请参阅include/tst_fuzzy_sync.h_中的注释。</p><h3 id="1-34-保留大页"><a href="#1-34-保留大页" class="headerlink" title="1.34 保留大页"></a>1.34 保留大页</h3><p>许多 LTP 测试需要在他们的测试中使用大页面，这允许测试可以通过_.hugepages = {xx, TST_REQUEST}_从系统中保留大页面。</p><p>我们实现了两个保留大页面的策略：</p><p>TST_REQUEST：会尽量预留可用的hugepages，返回tst_hugepages中可用的hugepages的个数，如果完全不支持hugepages可能为0。</p><p>TST_NEEDS：这是一个强制性要求，LTP应该严格执行hpages applying并保证HugePages_Free_不少于_pages使得测试可以正确使用这些指定的数字。否则，如果尝试保留大页面失败或保留少于请求，则测试以 TCONF 退出。</p><p>成功测试将保留的大页面编号存储在_tst_hugepages_中。对于不支持 hugetlb 的系统，变量_tst_hugepages_将设置为 0。如果在支持的 hugetlb 系统上需要将 hugepage 编号设置为 0，请使用_.hugepages = {TST_NO_HUGEPAGES}_。</p><p>此外，我们还为自动重置的 hpages 做清理和恢复工作。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tst_hugepages <span class="token operator">==</span> test<span class="token punctuation">.</span>hugepages<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token function">TEST</span><span class="token punctuation">(</span>do_hpage_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>hugepages <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> TST_REQUEST<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">/* TST_NEEDS achieved this automatically in the library */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tst_hugepages <span class="token operator">!=</span> test<span class="token punctuation">.</span>hugepages<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token function">tst_brk</span><span class="token punctuation">(</span>TCONF<span class="token punctuation">,</span> <span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>hugepages <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> TST_NEEDS<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-35-检查所需命令"><a href="#1-35-检查所需命令" class="headerlink" title="1.35 检查所需命令"></a>1.35 检查所需命令</h3><p><em>可以使用.needs_cmds_检查所需的命令，它指向以_NULL</em> 结尾的字符串数组，例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>needs_cmds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token string">"useradd"</span><span class="token punctuation">,</span><span class="token string">"userdel"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_也可以使用needs_cmds_检查所需的命令版本是否满足， 例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>needs_cmds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token string">"mkfs.ext4 &gt;= 1.43.0"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>目前，我们仅支持 mkfs.ext4 命令版本检查。如果你想支持更多的命令，请在lib/tst_cmd.c的version_parsers结构中填写你自己的.parser和.table_get方法。</p><h3 id="1-36-断言-sys-或-proc-文件值"><a href="#1-36-断言-sys-或-proc-文件值" class="headerlink" title="1.36 断言 sys 或 proc 文件值"></a>1.36 断言 sys 或 proc 文件值</h3><p>使用 TST_ASSERT_INT/STR(path, val) 断言存储在路径指向的文件的前缀字段中的整数值或字符串等于传递给此函数的值。</p><p>还有一个类似的 api 对 TST_ASSERT_FILE_INT/STR(path, prefix, val) 来断言文件的字段值。</p><h3 id="1-36-使用控制组"><a href="#1-36-使用控制组" class="headerlink" title="1.36 使用控制组"></a>1.36 使用控制组</h3><p>一些 LTP 测试需要特定的控制组配置。 <em>tst_cgroup.h</em> 提供 API 来发现和使用 CGroup。CGroups API V1 和 V2 之间存在许多差异。我们将配置 CGroups 的细节封装在尽可能遵循 V2 内核 API 的高级函数中。允许编写适用于 V1 或 V2 的代码。无论如何，至少在某些时候；通常 V1 和 V2 之间的行为差异太大。在这种情况下，我们恢复到 CGroup 版本上的分支。</p><p>此外，如果需要，LTP 库将自动挂载/卸载和配置 CGroup 层次结构（例如，如果您在没有系统管理器的情况下从 init 运行测试）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// do test under cgroup</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.max"</span><span class="token punctuation">,</span> <span class="token string">"%lu"</span><span class="token punctuation">,</span> MEMSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SAFE_CG_HAS</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.swap.max"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.swap.max"</span><span class="token punctuation">,</span> <span class="token string">"%zu"</span><span class="token punctuation">,</span> memsw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>cleanup <span class="token operator">=</span> cleanup<span class="token punctuation">,</span><span class="token punctuation">.</span>needs_cgroup_ctrls <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token string">"memory"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_在上面，我们首先使用.needs_cgroup_ctrls_确保内存控制器在测试的 CGroup 上可用。这会填充结构 _tst_cg_，它表示测试的 CGroup。</p><p>然后我们将当前进程的 PID 写入_cgroup.procs_，这会将当前进程移动到测试的 CGroup 中。之后我们通过写入_memory.max_来设置最大内存大小。如果内存控制器安装在 CGroups V1 上，那么库实际上将写入_memory.limit_in_bytes_。作为一般规则，如果一个文件存在于两个 CGroup 版本中，那么我们使用 V2 命名。</p><p>可以禁用某些控制器功能，例如_memory.swap 。_因此我们需要在访问它们之前检查它们是否存在。_这可以通过SAFE_CG_HAS_来完成，它可以在任何控制文件或功能上调用。</p><p>大多数测试只需要设置一些与上述类似的限制。在这种情况下，隐藏了 V1 和 V2 之间的差异。安装和清理也大多是隐藏的。然而，事情可能会变得更糟。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_cg_group</span> <span class="token operator">*</span>cg_child<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFSIZ<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> mem <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cg_child <span class="token operator">=</span> <span class="token function">tst_cg_group_mk</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TST_CG_VER_IS_V1</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">SAFE_CG_PRINT</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"cgroup.subtree_control"</span><span class="token punctuation">,</span> <span class="token string">"+memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TST_CG_VER_IS_V1</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"cpuset"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">SAFE_CG_PRINT</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"cgroup.subtree_control"</span><span class="token punctuation">,</span> <span class="token string">"+cpuset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">SAFE_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SAFE_CG_HAS</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span> <span class="token string">"memory.swap"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">SAFE_CG_SCANF</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span>  <span class="token string">"memory.swap.current"</span><span class="token punctuation">,</span> <span class="token string">"%zu"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">SAFE_CG_READ</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">,</span> <span class="token string">"cpuset.mems"</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Do something with cpuset.mems and memory.current values</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">tst_reap_children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg_drain<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cg_child <span class="token operator">=</span> <span class="token function">tst_cg_group_rm</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cg_child<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg_drain<span class="token punctuation">,</span> <span class="token string">"cgroup.procs"</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cg_child <span class="token operator">=</span> <span class="token function">tst_cg_group_rm</span><span class="token punctuation">(</span>cg_child<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span><span class="token punctuation">.</span>test_all <span class="token operator">=</span> run<span class="token punctuation">,</span><span class="token punctuation">.</span>needs_cgroup_ctrls <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">"cpuset"</span><span class="token punctuation">,</span><span class="token string">"memory"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从设置开始；我们可以在这里看到我们获取了_drain_ CGroup。这是一个共享组（在并行测试之间），可能包含来自其他测试的进程。它应该有默认设置并且这些设置不应该被测试改变。它可用于从其他 CGroups 中删除进程，以防层次结构根无法访问。</p><p>请注意，不应多次调用_tst_cg_get_drain_group ，因为它分配在受保护的缓冲区中（请参阅第 2.2.31 节）。<em>因此最好在_设置_中调用一次而不是_运行_，因为_运行_可能会用</em>-i_选项重复。</p><p>在_运行中，我们首先使用__tst_cg_mk_创建一个子 CGroup 。_当我们在运行_中创建这个 CGroup 时，我们也应该在运行结束时将其删除。我们还需要检查它是否存在并在清理中将其删除。因为有_SAFE__函数可能会跳转到清理。</p><p>然后，我们将主要测试进程移至子 CGroup 中。这很重要，因为这意味着在我们销毁子 CGroup 之前，我们必须将主要测试进程移到别处。为此，我们使用_排水_ 组。</p><p>接下来我们在测试 CGroup 的后代（即_cg_child_）上启用内存和 cpuset 控制器配置。这允许每个孩子都有自己的设置。V1 上不存在文件_cgroup.subtree_control 。_因为有可能同时激活 V1 和 V2。我们不能简单地在写入之前检查_subtree_control是否存在。__在尝试将其添加到subtree_control_之前，我们必须检查特定控制器是否在 V2 上。尝试添加 V1 控制器将导致_ENOENT_。</p><p>然后我们 fork 一个子进程并将其添加到子 CGroup。在子进程中，我们尝试读取_memory.swap.current_。内存控制器可能是在不支持交换的情况下编译的，因此有必要检查是否启用了_memory.swap 。<em>也就是说，除非测试永远不会达到在没有交换支持的情况下使用_memory.swap.* 的程度。</em></p><p>父进程在销毁子 CGroup 之前等待子进程被回收。所以不需要转移孩子去引流。但是必须移动父进程，否则我们在尝试删除子 CGroup 时会遇到_EBUSY 。_</p><p>下面显示了版本之间行为差异的另一个示例。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TST_CG_VER_IS_V1</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">SAFE_CG_PRINTF</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.swap.max"</span><span class="token punctuation">,</span> <span class="token string">"%lu"</span><span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0UL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">SAFE_CG_PRINT</span><span class="token punctuation">(</span>tst_cg<span class="token punctuation">,</span> <span class="token string">"memory.swap.max"</span><span class="token punctuation">,</span> <span class="token string">"max"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>CGroups V2 引入了一项功能，可以将_memory[.swap].max_设置为“max”。然而，这似乎不适用于 V1 _limit_in_bytes_。对于大多数测试，简单地使用大数就足够了，没有必要使用“max”。但重要的是，应该仔细阅读 V1 和 V2 内核文档。目前 LTP 库不尝试处理语义上的大多数差异。它做了最少的工作，使 V1 和 V2 的测试都可行。</p><h3 id="1-37-测试用例需要最少数量的-CPU"><a href="#1-37-测试用例需要最少数量的-CPU" class="headerlink" title="1.37 测试用例需要最少数量的 CPU"></a>1.37 测试用例需要最少数量的 CPU</h3><p>一些测试需要超过特定数量的 CPU。它可以用 来定义 <code>.min_cpus = N</code>。</p><h3 id="1-38-测试标签"><a href="#1-38-测试标签" class="headerlink" title="1.38 测试标签"></a>1.38 测试标签</h3><p>测试标签是可以保存任何测试元数据的名称-值对。</p><p>我们对 CVE 条目、主线内核中的 git 提交、稳定内核或 glibc git 存储库提供了额外的支持。如果测试是回归测试，它应该包含这些标签。它们在测试失败时打印出来并导出到文档中。</p><p>CVE、主线和稳定内核 git 在内核错误的回归测试中提交：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>tags <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tst_tag</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"linux-git"</span><span class="token punctuation">,</span> <span class="token string">"9392a27d88b9"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"linux-git"</span><span class="token punctuation">,</span> <span class="token string">"ff002b30181d"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"known-fail"</span><span class="token punctuation">,</span> <span class="token string">"ustat() is known to fail with EINVAL on Btrfs"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"linux-stable-git"</span><span class="token punctuation">,</span> <span class="token string">"c4a23c852e80"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"CVE"</span><span class="token punctuation">,</span> <span class="token string">"2020-29373"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>| </p><p>笔记</p><p> | 我们不会跟踪所有向稳定内核的反向移植，而只跟踪那些特定于稳定分支（唯一）的向后移植，即没有在主线中提交。提交示例：c4a23c852e80、cac68d12c531。 |</p><p>Glibc git commit 在 glibc 错误的回归测试中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>tags <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tst_tag</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"glibc-git"</span><span class="token punctuation">,</span> <span class="token string">"574500a108be"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-39-测试具体架构"><a href="#1-39-测试具体架构" class="headerlink" title="1.39 测试具体架构"></a>1.39 测试具体架构</h3><p>特定架构的测试用例应仅限于仅支持的平台运行，我们现在在 LTP 库中引入一个 .supported_archs 来实现此功能。在预期的 arch 上运行测试所需要做的就是在_struct tst_test中设置__.supported_archs_数组以选择所需的 arch 列表。例如</p><p>.supported_archs = (const char *const []){“x86_64”, “ppc64”, NULL}</p><p>这也有助于将 TCONF 信息从代码移动到 tst_test 元数据。</p><p>并且，我们还导出了一个 struct tst_arch 来保存系统架构，以便在整个测试用例中使用。</p><p>外部常量结构 tst_arch { 字符名称[16]； 枚举 tst_arch_type 类型； } tst_arch；</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tst_test.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tst_test</span> test <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>       <span class="token punctuation">.</span>setup <span class="token operator">=</span> setup<span class="token punctuation">,</span>       <span class="token punctuation">.</span>supported_archs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token string">"x86_64"</span><span class="token punctuation">,</span>                 <span class="token string">"ppc64"</span><span class="token punctuation">,</span>                 <span class="token string">"s390x"</span><span class="token punctuation">,</span>                 <span class="token constant">NULL</span>       <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-40-要求测试用例的最小-MemAvailable-大小"><a href="#1-40-要求测试用例的最小-MemAvailable-大小" class="headerlink" title="1.40 要求测试用例的最小 MemAvailable 大小"></a>1.40 要求测试用例的最小 MemAvailable 大小</h3><p>一些测试需要超过特定大小 (MB) 的 MemAvailable。它可以用 来定义<code>.min_mem_avail = N</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LTP-C-测试-API&quot;&gt;&lt;a href=&quot;#LTP-C-测试-API&quot; class=&quot;headerlink&quot; title=&quot;LTP C 测试 API&quot;&gt;&lt;/a&gt;LTP C 测试 API&lt;/h1&gt;&lt;p&gt;笔记  另请参阅 &lt;a href=&quot;https://gith</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luxihua.space/blog/0.html"/>
    <id>http://luxihua.space/blog/0.html</id>
    <published>2024-02-03T04:59:48.962Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LTP——Linux-测试项目"><a href="#LTP——Linux-测试项目" class="headerlink" title="LTP——Linux 测试项目"></a>LTP——Linux 测试项目</h2><p>Linux 测试项目是由 SGI 发起的联合项目，由 IBM、Cisco、Fujitsu、SUSE、Red Hat 等开发和维护，其目标是向开源社区提供测试套件，以验证可靠性、健壮性和Linux 的稳定性。LTP 测试套件包含一组用于测试 Linux 内核和相关功能的工具。</p><ul><li><a href="https://github.com/linux-test-project/ltp/wiki/Contact-Info">联系信息</a></li></ul><h2 id="开发者角"><a href="#开发者角" class="headerlink" title="开发者角"></a>开发者角</h2><ul><li><a href="https://github.com/linux-test-project/ltp/wiki/Test-Writing-Guidelines">测试写作指南</a></li><li><a href="https://github.com/linux-test-project/ltp/wiki/LTP-Library-API-Writing-Guidelines">LTP 库 API 编写指南</a></li><li><a href="https://github.com/linux-test-project/ltp/wiki/C-Test-Case-Tutorial">C 测试用例教程</a></li><li><a href="https://github.com/linux-test-project/ltp/wiki/Build-System">构建系统</a></li></ul><p>如果有什么没有涵盖，请不要犹豫，在<a href="https://lists.linux.it/listinfo/ltp">LTP 邮件列表</a>上询问。</p><p>尽管我们接受 GitHub 拉取请求，但首选方式是将补丁发送到我们的邮件列表。</p><p>在发布到邮件列表之前，最好先在 GitHub Actions 上测试补丁。我们的 GitHub Actions 设置涵盖各种架构和分布，以确保 LTP 在最常见的配置上干净地编译。对于测试，您只需将更改推送到 GitHub 上您自己的 LTP 分支。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LTP——Linux-测试项目&quot;&gt;&lt;a href=&quot;#LTP——Linux-测试项目&quot; class=&quot;headerlink&quot; title=&quot;LTP——Linux 测试项目&quot;&gt;&lt;/a&gt;LTP——Linux 测试项目&lt;/h2&gt;&lt;p&gt;Linux 测试项目是由 SGI 发</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第01课：初识Python</title>
    <link href="http://luxihua.space/blog/jwnfwvbg.html"/>
    <id>http://luxihua.space/blog/jwnfwvbg.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第01课：初识Python"><a href="#第01课：初识Python" class="headerlink" title="第01课：初识Python"></a>第01课：初识Python</h2><h3 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h3><p>Python是由荷兰人吉多·范罗苏姆（Guido von Rossum）发明的一种编程语言，是目前世界上最受欢迎和拥有最多用户群体的编程语言。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210816232538.png" width="85%"><h4 id="Python的历史"><a href="#Python的历史" class="headerlink" title="Python的历史"></a>Python的历史</h4><ol><li>1989年圣诞节：Guido开始写Python语言的编译器。</li><li>1991年2月：第一个Python解释器诞生，它是用C语言实现的，可以调用C语言的库函数。</li><li>1994年1月：Python 1.0正式发布。</li><li>2000年10月：Python 2.0发布，Python的整个开发过程更加透明，生态圈开始慢慢形成。</li><li>2008年12月：Python 3.0发布，引入了诸多现代编程语言的新特性，但并不完全兼容之前的Python代码。</li><li>2020年1月：在Python 2和Python 3共存了11年之后，官方停止了对Python 2的更新和维护，希望用户尽快过渡到Python 3。</li></ol><blockquote><p><strong>说明</strong>：大多数软件的版本号一般分为三段，形如A.B.C，其中A表示大版本号，当软件整体重写升级或出现不向后兼容的改变时，才会增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。</p></blockquote><h4 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h4><p>Python的优点很多，简单为大家列出几点。</p><ol><li>简单明确，跟其他很多语言相比，Python更容易上手。</li><li>能用更少的代码做更多的事情，提升开发效率。</li><li>开放源代码，拥有强大的社区和生态圈。</li><li>能够做的事情非常多，有极强的适应性。</li><li>能够在Windows、macOS、Linux等各种系统上运行。</li></ol><p>Python最主要的缺点是执行效率低，但是当我们更看重产品的开发效率而不是执行效率的时候，Python就是很好的选择。</p><h4 id="Python的应用领域"><a href="#Python的应用领域" class="headerlink" title="Python的应用领域"></a>Python的应用领域</h4><p>目前Python在Web服务器应用开发、云基础设施开发、<strong>网络数据采集</strong>（爬虫）、<strong>数据分析</strong>、量化交易、<strong>机器学习</strong>、<strong>深度学习</strong>、自动化测试、自动化运维等领域都有用武之地。</p><h3 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h3><p>想要开始你的Python编程之旅，首先得在计算机上安装Python环境，简单的说就是得安装运行Python程序的工具，通常也称之为Python解释器。我们强烈建议大家安装Python 3的环境，很明显它是目前更好的选择。</p><h4 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h4><p>可以在<a href="https://www.python.org/downloads/">Python官方网站</a>找到下载链接并下载Python 3的安装程序。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719222940.png"></p><p>对于Windows操作系统，可以下载“executable installer”。需要注意的是，如果在Windows 7环境下安装Python 3，需要先安装Service Pack 1补丁包，大家可以在Windows的“运行”中输入<code>winver</code>命令，从弹出的窗口上可以看到你的系统是否安装了该补丁包。如果没有该补丁包，一定要先通过“Windows Update”或者类似“CCleaner”这样的工具自动安装该补丁包，安装完成后通常需要重启你的Windows系统，然后再开始安装Python环境。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719222956.png"></p><p>双击运行刚才下载的安装程序，会打开Python环境的安装向导。在执行安装向导的时候，记得勾选“Add Python 3.x to PATH”选项，这个选项会帮助我们将Python的解释器添加到PATH环境变量中（不理解没关系，照做就行），具体的步骤如下图所示。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223007.png"></p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223021.png"></p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223317.png"></p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223332.png"></p><p>安装完成后可以打开Windows的“命令行提示符”工具（或“PowerShell”）并输入<code>python --version</code>或<code>python -V</code>来检查安装是否成功，命令行提示符可以在“运行”中输入<code>cmd</code>来打开或者在“开始菜单”的附件中找到它。如果看了Python解释器对应的版本号（如：Python 3.7.8），说明你的安装已经成功了，如下图所示。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210719223350.png"></p><blockquote><p><strong>说明</strong>：如果安装过程显示安装失败或执行上面的命令报错，很有可能是因为你的Windows系统缺失了一些动态链接库文件或C构建工具导致的问题。可以在<a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=48145">微软官网</a>下载Visual C++ Redistributable for Visual Studio 2015文件进行修复，64位的系统需要下载有x64标记的安装文件。也可以通过下面的百度云盘地址获取修复工具，运行修复工具，按照如下图所示的方式进行修复，链接: <a href="https://pan.baidu.com/s/1iNDnU5UVdDX5sKFqsiDg5Q">https://pan.baidu.com/s/1iNDnU5UVdDX5sKFqsiDg5Q</a> 提取码: cjs3。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210816234614.png" alt="QQ20210711-0"></p></blockquote><p>除此之外，你还应该检查一下Python的包管理工具是否已经可用，对应的命令是<code>pip --version</code>。</p><h4 id="macOS环境"><a href="#macOS环境" class="headerlink" title="macOS环境"></a>macOS环境</h4><p>macOS自带了Python 2，但是我们需要安装和使用的是Python 3。可以通过Python官方网站提供的<a href="https://www.python.org/downloads/release/python-376/">下载链接</a>找到适合macOS的“macOS installer”来安装Python 3，安装过程基本不需要做任何勾选，直接点击“下一步”即可。安装完成后，可以在macOS的“终端”工具中输入<code>python3</code>命令来调用Python 3解释器，因为如果直接输入<code>python</code>，将会调用Python 2的解释器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Python语言可以做很多的事情，也值得我们去学习。要使用Python语言，首先需要在自己的计算机上安装Python环境，也就是运行Python程序的Python解释器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第01课：初识Python&quot;&gt;&lt;a href=&quot;#第01课：初识Python&quot; class=&quot;headerlink&quot; title=&quot;第01课：初识Python&quot;&gt;&lt;/a&gt;第01课：初识Python&lt;/h2&gt;&lt;h3 id=&quot;Python简介&quot;&gt;&lt;a href=&quot;#P</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
  <entry>
    <title>第02课：第一个Python程序</title>
    <link href="http://luxihua.space/blog/8somx7oj.html"/>
    <id>http://luxihua.space/blog/8somx7oj.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第02课：第一个Python程序"><a href="#第02课：第一个Python程序" class="headerlink" title="第02课：第一个Python程序"></a>第02课：第一个Python程序</h2><p>在上一课中，我们已经了解了Python语言并安装了运行Python程序所需的环境，相信大家已经迫不及待的想开始自己的Python编程之旅了。首先我们来看看应该在哪里编写我们的Python程序。</p><h3 id="编写代码的工具"><a href="#编写代码的工具" class="headerlink" title="编写代码的工具"></a>编写代码的工具</h3><h4 id="交互式环境"><a href="#交互式环境" class="headerlink" title="交互式环境"></a>交互式环境</h4><p>我们打开Windows的“命令提示符”工具，输入命令<code>python</code>然后回车就可以进入到Python的交互式环境中。所谓交互式环境，就是我们输入一行代码回车，代码马上会被执行，如果代码有产出结果，那么结果会被显示在窗口中。例如：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">Python 3.7.6Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 2 * 36&gt;&gt;&gt; 2 + 35<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：使用macOS系统的用户需要打开“终端”工具，输入<code>python3</code>进入交互式环境。</p></blockquote><p>如果希望退出交互式环境，可以在交互式环境中输入<code>quit()</code>，如下所示。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">&gt;&gt;&gt; quit()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="更好的交互式环境-IPython"><a href="#更好的交互式环境-IPython" class="headerlink" title="更好的交互式环境 - IPython"></a>更好的交互式环境 - IPython</h4><p>Python默认的交互式环境用户体验并不怎么好，我们可以用IPython来替换掉它，因为IPython提供了更为强大的编辑和交互功能。我们可以使用Python的包管理工具<code>pip</code>来安装IPython，如下所示。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> ipython<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>温馨提示</strong>：在使用上面的命令安装IPython之前，可以先通过<code>pip config set global.index-url https://pypi.doubanio.com/simple</code>命令将<code>pip</code>的下载源修改为国内的豆瓣网，否则下载安装的过程可能会非常的缓慢。</p></blockquote><p>可以使用下面的命令启动IPython，进入交互式环境。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipython<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="文本编辑器-Visual-Studio-Code"><a href="#文本编辑器-Visual-Studio-Code" class="headerlink" title="文本编辑器 - Visual Studio Code"></a>文本编辑器 - Visual Studio Code</h4><p>Visual Studio Code（通常简称为VSCode）是一个由微软开发能够在Windows、 Linux和macOS等操作系统上运行的代码编辑神器。它支持语法高亮、自动补全、多点编辑、运行调试等一系列便捷功能，而且能够支持多种编程语言。如果大家要选择一款高级文本编辑工具，强烈建议使用VSCode。关于VSCode的<a href="https://code.visualstudio.com/">下载</a>、安装和使用，推荐大家阅读一篇名为<a href="https://zhuanlan.zhihu.com/p/106357123">《VScode安装使用》</a>的文章。</p><h4 id="集成开发环境-PyCharm"><a href="#集成开发环境-PyCharm" class="headerlink" title="集成开发环境 - PyCharm"></a>集成开发环境 - PyCharm</h4><p>如果用Python开发商业项目，我们推荐大家使用更为专业的工具PyCharm。PyCharm是由捷克一家名为<a href="https://www.jetbrains.com/">JetBrains</a>的公司开发的用于Python项目开发的集成开发环境（IDE)。所谓集成开发环境，通常是指工具中提供了编写代码、运行代码、调试代码、分析代码、版本控制等一系列功能，因此特别适合商业项目的开发。在JetBrains的官方网站上提供了PyCharm的<a href="https://www.jetbrains.com/pycharm/download">下载链接</a>，其中社区版（Community）是免费的但功能相对弱小（其实已经足够强大了），专业版（Professional）功能非常强大，但需要按年或月付费使用，新用户可以试用30天时间。</p><p>运行PyCharm，可以看到如下图所示的欢迎界面，可以选择“New Project”来创建一个新的项目。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210720102203.png" width="80%"><p>创建项目的时候需要指定项目的路径并创建运行项目的”虚拟环境“，如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210720102822.png" width="80%"><p>项目创建好以后会出现如下图所示的画面，我们可以通过在项目文件夹上点击鼠标右键，选择“New”菜单下的“Python File”来创建一个Python文件，创建好的Python文件会自动打开进入可编辑的状态。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210720133621.png" alt="image-20210720133621079"></p><p>写好代码后，可以在编辑代码的窗口点击鼠标右键，选择“Run”菜单项来运行代码，下面的“Run”窗口会显示代码的执行结果，如下图所示。</p><p><img src="https://github.com/jackfrued/mypic/raw/master/20210720134039.png" alt="image-20210720134039848"></p><p>PyCharm常用的快捷键如下表所示，我们也可以在“File”菜单的“Settings”中定制PyCharm的快捷键（macOS系统是在“PyCharm”菜单的“Preferences”中对快捷键进行设置）。</p><p>表1. PyCharm常用快捷键。</p><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td><code>ctrl + j</code></td><td>显示可用的代码模板</td></tr><tr><td><code>ctrl + b</code></td><td>查看函数、类、方法的定义</td></tr><tr><td><code>ctrl + alt + l</code></td><td>格式化代码</td></tr><tr><td><code>alt + enter</code></td><td>万能代码修复快捷键</td></tr><tr><td><code>ctrl + /</code></td><td>注释/反注释代码</td></tr><tr><td><code>shift + shift</code></td><td>万能搜索快捷键</td></tr><tr><td><code>ctrl + d</code> / <code>ctrl + y</code></td><td>复制/删除一行代码</td></tr><tr><td><code>ctrl + shift + -</code> / <code>ctrl + shift + +</code></td><td>折叠/展开所有代码</td></tr><tr><td><code>F2</code></td><td>快速定位到错误代码</td></tr><tr><td><code>ctrl + alt + F7</code></td><td>查看哪些地方用到了指定的函数、类、方法</td></tr></tbody></table><blockquote><p><strong>说明</strong>：使用macOS系统，可以将上面的<code>ctrl</code>键换成<code>command</code>键，在macOS系统上，可以使用<code>ctrl + space</code>组合键来获得万能提示，在Windows系统上不能使用该快捷键，因为它跟Windows默认的切换输入法的快捷键是冲突的，需要重新设置。</p></blockquote><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello, world"></a>hello, world</h3><p>按照行业惯例，我们学习任何一门编程语言写的第一个程序都是输出<code>hello, world</code>，因为这段代码是伟大的丹尼斯·里奇（C语言之父，和肯·汤普森一起开发了Unix操作系统）和布莱恩·柯尼汉（awk语言的发明者）在他们的不朽著作<em>The C Programming Language</em>中写的第一段代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">print('hello, world')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>如果不使用PyCharm这样的集成开发环境，我们可以将上面的代码命名为<code>hello.py</code>，对于Windows操作系统，可以在你保存代码的目录下先按住键盘上的<code>shift</code>键再点击鼠标右键，这时候鼠标右键菜单中会出现“命令提示符”选项，点击该选项就可以打开“命令提示符”工具，我们输入下面的命令。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">python hello.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>提醒</strong>：我们也可以在任意位置打开“命令提示符”，然后将需要执行的Python代码通过拖拽的方式拖入到“命令提示符”中，这样相当于指定了文件的绝对路径来运行该文件中的Python代码。再次提醒，macOS系统要通过<code>python3</code>命令来运行该程序。</p></blockquote><p>你可以尝试将上面程序单引号中的<code>hello, world</code>换成其他内容；你也可以尝试着多写几个这样的语句，看看会运行出怎样的结果。需要提醒大家，上面代码中的<code>print('hello, world')</code>就是一条完整的语句，我们用Python写程序，最好每一行代码中只有一条语句。虽然使用<code>;</code>分隔符可以将多个语句写在一行代码中，但是最好不要这样做，因为代码会变得非常难看。</p><h3 id="注释你的代码"><a href="#注释你的代码" class="headerlink" title="注释你的代码"></a>注释你的代码</h3><p>注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性。当然，我们也可以将源代码中暂时不需要运行的代码段通过注释来去掉，这样当你需要重新使用这些代码的时候，去掉注释符号就可以了。简单的说，<strong>注释会让代码更容易看懂但不会影响程序的执行结果</strong>。</p><p>Python中有两种形式的注释：</p><ol><li>单行注释：以<code>#</code>和空格开头，可以注释掉从<code>#</code>开始后面一整行的内容。</li><li>多行注释：三个引号开头，三个引号结尾，通常用于添加多行说明性内容。</li></ol><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""第一个Python程序 - hello, worldVersion: 0.1Author: 骆昊"""# print('hello, world')print("你好，世界！")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，我们已经把第一个Python程序运行起来了，是不是很有成就感？只要你坚持学习下去，再过一段时间，我们就可以用Python制作小游戏、编写爬虫程序、完成办公自动化操作等。<strong>写程序本身就是一件很酷的事情</strong>，在未来编程就像英语一样，<strong>对很多人来说或都是必须要掌握的技能</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第02课：第一个Python程序&quot;&gt;&lt;a href=&quot;#第02课：第一个Python程序&quot; class=&quot;headerlink&quot; title=&quot;第02课：第一个Python程序&quot;&gt;&lt;/a&gt;第02课：第一个Python程序&lt;/h2&gt;&lt;p&gt;在上一课中，我们已经了解了P</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
  <entry>
    <title>第03课：Python语言元素之变量</title>
    <link href="http://luxihua.space/blog/xpb0qasg.html"/>
    <id>http://luxihua.space/blog/xpb0qasg.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第03课：Python语言元素之变量"><a href="#第03课：Python语言元素之变量" class="headerlink" title="第03课：Python语言元素之变量"></a>第03课：Python语言元素之变量</h2><p>作为一个程序员，可能经常会被外行问到两个问题，其一是“什么是（计算机）程序”，其二是“写（计算机）程序能做什么”，这里我先对这两个问题做一个回答。<strong>程序是指令的集合</strong>，<strong>写程序就是用指令控制计算机做我们想让它做的事情</strong>。那么，为什么要用Python语言来写程序呢？因为<strong>Python语言简单优雅</strong>，相比C、C++、Java这样的编程语言，<strong>Python对初学者更加友好</strong>，当然这并不是说Python不像其他语言那样强大，<strong>Python几乎是无所不能的</strong>，在第一节课的时候，我们就说到了Python可以用于服务器程序开发、云平台开发、数据分析、机器学习等各个领域。当然，Python语言还可以用来粘合其他语言开发的系统，所以也经常被戏称为“<strong>胶水语言</strong>”。</p><h3 id="一些计算机常识"><a href="#一些计算机常识" class="headerlink" title="一些计算机常识"></a>一些计算机常识</h3><p>在开始系统的学习编程之前，我们先来科普一些计算机的基础知识。计算机的硬件系统通常由五大部件构成，包括：<strong>运算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入设备</strong>和<strong>输出设备</strong>。其中，运算器和控制器放在一起就是我们常说的<strong>中央处理器</strong>，它的功能是执行各种运算和控制指令。刚才我们提到过程序是指令的集合，写程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。目前，我们使用的计算机基本都是“冯·诺依曼体系结构”的计算机，这种计算机有两个关键点：一是要将<strong>存储设备与中央处理器分开</strong>；二是将<strong>数据以二进制方式编码</strong>。</p><p>二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法本质是一样的。人类因为有十根手指所以使用了十进制，因为在计数时十根手指用完之后就只能用进位的方式来表示更大的数值。当然凡事都有例外，玛雅人可能是因为长年光着脚的原因，把脚趾头也都用上了，于是他们使用了二十进制的计数法。在这种计数法的指导下，玛雅人的历法就与我们平常使用的历法并不相同。按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“的荒诞说法。今天很多人都在猜测，玛雅文明之所以发展缓慢跟使用了二十进制是有关系的。对于计算机来说，二进制在物理器件上最容易实现的，因为可以用高电压表示1，用低电压表示0。不是所有写程序的人都需要知道十进制与二进制如何转换，大多数时候我们即便不了解这些知识也能写出程序，但是我们必须要知道<strong>计算机是使用二进制计数的</strong>，不管什么<strong>数据到了计算机内存中都是以二进制形式存在的</strong>。</p><h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><p>要想在计算机内存中保存数据，首先就得说一说变量这个概念。在编程语言中，<strong>变量是数据的载体</strong>，简单的说就是一块用来保存数据的内存空间，<strong>变量的值可以被读取和修改</strong>，这是所有计算和控制的基础。计算机能处理的数据有很多种类型，最常见的就是数值，除了数值之外还有文本、图形、音频、视频等各种各样的数据。虽然数据在计算机中都是以二进制形态存在的，但是我们可以用不同类型的变量来表示数据类型的差异。<strong>Python中的数据类型很多</strong>，而且也<strong>允许我们自定义新的数据类型</strong>（这一点在后面会讲到），这里我们需要先了解几种常用的数据类型。</p><ul><li>整型（<code>int</code>）：Python中可以处理任意大小的整数，而且支持二进制（如<code>0b100</code>，换算成十进制是4）、八进制（如<code>0o100</code>，换算成十进制是64）、十进制（<code>100</code>）和十六进制（<code>0x100</code>，换算成十进制是256）的表示法。</li><li>浮点型（<code>float</code>）：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如<code>123.456</code>）之外还支持科学计数法（如<code>1.23456e2</code>）。</li><li>字符串型（<code>str</code>）：字符串是以单引号或双引号括起来的任意文本，比如<code>'hello'</code>和<code>"hello"</code>。</li><li>布尔型（<code>bool</code>）：布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>。</li></ul><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>对于每个变量我们需要给它取一个名字，就如同我们每个人都有自己的名字一样。在Python中，变量命名需要遵循以下这些规则，这些规则又分为必须遵守的硬性规则和建议遵守的非硬性规则。</p><ul><li>硬性规则：<ul><li>规则1：变量名由<strong>字母</strong>、数字和<strong>下划线</strong>构成，数字不能开头。需要说明的是，这里说的字母指的是Unicode字符，Unicode称为万国码，囊括了世界上大部分的文字系统，这也就意味着中文、日文、希腊字母等都可以作为变量名中的字符，但是像<code>!</code>、<code>@</code>、<code>#</code>这些特殊字符是不能出现在变量名中的，而且我们强烈建议大家<strong>尽可能使用英文字母</strong>。</li><li>规则2：<strong>大小写敏感</strong>，简单的说就是大写的<code>A</code>和小写的<code>a</code>是两个不同的变量。</li><li>规则3：变量名<strong>不要跟Python语言的关键字</strong>（有特殊含义的单词，后面会讲到）和<strong>保留字</strong>（如已有的函数、模块等的名字）<strong>发生重名的冲突</strong>。</li></ul></li><li>非硬性规则：<ul><li>规则1：变量名通常使用小写英文字母，多个单词用下划线进行连接。</li><li>规则2：受保护的变量用单个下划线开头。</li><li>规则3：私有的变量用两个下划线开头。</li></ul></li></ul><p>规则2和规则3大家暂时不用理解，后面自然会明白的。当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到<strong>见名知意</strong>也非常重要。</p><h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p>下面通过例子来说明变量的类型和变量的使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""使用变量保存数据并进行加减乘除运算Version: 0.1Author: 骆昊"""a = 45          # 变量a保存了45b = 12          # 变量b保存了12print(a + b)    # 57print(a - b)    # 33print(a * b)    # 540print(a / b)    # 3.75<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Python中可以使用<code>type</code>函数对变量的类型进行检查。程序设计中函数的概念跟数学上函数的概念基本一致，数学上的函数相信大家并不陌生，它包括了函数名、自变量和因变量。如果暂时不理解函数这个概念也不要紧，我们会在后续的内容中专门讲解函数的定义和使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""使用type()检查变量的类型Version: 0.1Author: 骆昊"""a = 100b = 12.345c = 'hello, world'd = Trueprint(type(a))    # &lt;class 'int'&gt;print(type(b))    # &lt;class 'float'&gt;print(type(c))    # &lt;class 'str'&gt;print(type(d))    # &lt;class 'bool'&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同类型的变量可以相互转换，这一点可以通过Python的内置函数来实现。</p><ul><li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li><li><code>float()</code>：将一个字符串转换成浮点数。</li><li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li><li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li><li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。</li></ul><p>下面的例子为大家演示了Python中类型转换的操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""Python中的类型转换操作Version: 0.1Author: 骆昊"""a = 100b = 12.345c = 'hello, world'd = True# 整数转成浮点数print(float(a))    # 100.0# 浮点型转成字符串 (输出字符串时不会看到引号哟)print(str(b))      # 12.345# 字符串转成布尔型 (有内容的字符串都会变成True)print(bool(c))     # True# 布尔型转成整数 (True会转成1，False会转成0)print(int(d))      # 1# 将整数变成对应的字符 (97刚好对应字符表中的字母a)print(chr(97))     # a# 将字符转成整数 (Python中字符和字符串表示法相同)print(ord('a'))    # 97<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Python程序中，我们可以<strong>使用变量来保存数据</strong>，<strong>变量有不同的类型</strong>，<strong>变量可以做运算</strong>（下一课会有详细的讲解），<strong>也可以通过内置函数来转换变量类型</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第03课：Python语言元素之变量&quot;&gt;&lt;a href=&quot;#第03课：Python语言元素之变量&quot; class=&quot;headerlink&quot; title=&quot;第03课：Python语言元素之变量&quot;&gt;&lt;/a&gt;第03课：Python语言元素之变量&lt;/h2&gt;&lt;p&gt;作为一个程序</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
  <entry>
    <title>第04课：Python语言元素之运算符</title>
    <link href="http://luxihua.space/blog/3jfmvjyt.html"/>
    <id>http://luxihua.space/blog/3jfmvjyt.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第04课：Python语言元素之运算符"><a href="#第04课：Python语言元素之运算符" class="headerlink" title="第04课：Python语言元素之运算符"></a>第04课：Python语言元素之运算符</h2><p>Python语言支持很多种运算符，我们先用一个表格为大家列出这些运算符，然后选择一些马上就会用到的运算符为大家进行讲解。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>[]</code> <code>[:]</code></td><td>下标，切片</td></tr><tr><td><code>**</code></td><td>指数</td></tr><tr><td><code>~</code> <code>+</code> <code>-</code></td><td>按位取反, 正负号</td></tr><tr><td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td>乘，除，模，整除</td></tr><tr><td><code>+</code> <code>-</code></td><td>加，减</td></tr><tr><td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td><td>右移，左移</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code> <code>|</code></td><td>按位异或，按位或</td></tr><tr><td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr><tr><td><code>==</code> <code>!=</code></td><td>等于，不等于</td></tr><tr><td><code>is</code>  <code>is not</code></td><td>身份运算符</td></tr><tr><td><code>in</code> <code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr><tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code></td><td>（复合）赋值运算符</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 上面这个表格实际上是按照运算符的优先级从上到下列出了各种运算符。所谓优先级就是在一个运算的表达式中，如果出现了多个运算符，应该先执行哪个运算再执行哪个运算的顺序。在实际开发中，如果搞不清楚运算符的优先级，可以使用圆括号来确保运算的执行顺序。</p></blockquote><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>Python中的算术运算符非常丰富，除了大家最为熟悉的加减乘除之外，还有整除运算符、求模（求余数）运算符和求幂运算符。下面的例子为大家展示了算术运算符的使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""算术运算符Version: 0.1Author: 骆昊"""print(321 + 123)     # 加法运算print(321 - 123)     # 减法运算print(321 * 123)     # 乘法运算print(321 / 123)     # 除法运算print(321 % 123)     # 求模运算print(321 // 123)    # 整除运算print(321 ** 123)    # 求幂运算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。下面的例子演示了赋值运算符和复合赋值运算符的使用。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""赋值运算符和复合赋值运算符Version: 0.1Author: 骆昊"""a = 10b = 3a += b        # 相当于：a = a + ba *= a + 2    # 相当于：a = a * (a + 2)print(a)      # 算一下这里会输出什么<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>###比较运算符和逻辑运算符</p><p>比较运算符有的地方也称为关系运算符，包括<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>，我相信没有什么好解释的，大家一看就能懂，需要提醒的是比较相等用的是<code>==</code>，请注意这里是两个等号，因为<code>=</code>是赋值运算符，我们在上面刚刚讲到过，<code>==</code>才是比较相等的运算符；比较不相等用的是<code>!=</code>，这不同于数学上的不等号，Python 2中曾经使用过<code>&lt;&gt;</code>来表示不等关系，大家知道就可以了。比较运算符会产生布尔值，要么是<code>True</code>要么是<code>False</code>。</p><p>逻辑运算符有三个，分别是<code>and</code>、<code>or</code>和<code>not</code>。<code>and</code>字面意思是“而且”，所以<code>and</code>运算符会连接两个布尔值，如果两个布尔值都是<code>True</code>，那么运算的结果就是<code>True</code>；左右两边的布尔值有一个是<code>False</code>，最终的运算结果就是<code>False</code>。相信大家已经想到了，如果<code>and</code>左边的布尔值是<code>False</code>，不管右边的布尔值是什么，最终的结果都是<code>False</code>，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在<code>and</code>运算符左边为<code>False</code>的情况下，右边的表达式根本不会执行。<code>or</code>字面意思是“或者”，所以<code>or</code>运算符也会连接两个布尔值，如果两个布尔值有任意一个是<code>True</code>，那么最终的结果就是<code>True</code>。当然，<code>or</code>运算符也是有短路功能的，在它左边的布尔值为<code>True</code>的情况下，右边的表达式根本不会执行。<code>not</code>运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，<code>not</code>后面的布尔值如果是<code>True</code>，运算结果就是<code>False</code>；而<code>not</code>后面的布尔值如果是<code>False</code>，运算结果就是<code>True</code>。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""比较运算符和逻辑运算符的使用Version: 0.1Author: 骆昊"""flag0 = 1 == 1flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not (1 != 2)print('flag0 =', flag0)    # flag0 = Trueprint('flag1 =', flag1)    # flag1 = Trueprint('flag2 =', flag2)    # flag2 = Falseprint('flag3 =', flag3)    # flag3 = Falseprint('flag4 =', flag4)    # flag4 = Trueprint('flag5 =', flag5)    # flag5 = False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：比较运算符的优先级高于赋值运算符，所以<code>flag0 = 1 == 1</code>先做<code>1 == 1</code>产生布尔值<code>True</code>，再将这个值赋值给变量<code>flag0</code>。<code>print</code>函数可以输出多个值，多个值之间可以用<code>,</code>进行分隔，输出的内容之间默认以空格分开。</p></blockquote><h3 id="运算符的例子"><a href="#运算符的例子" class="headerlink" title="运算符的例子"></a>运算符的例子</h3><h4 id="例子1：华氏温度转换为摄氏温度。"><a href="#例子1：华氏温度转换为摄氏温度。" class="headerlink" title="例子1：华氏温度转换为摄氏温度。"></a>例子1：华氏温度转换为摄氏温度。</h4><blockquote><p><strong>提示</strong>：华氏温度到摄氏温度的转换公式为：<code>C = (F - 32) / 1.8</code>。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""将华氏温度转换为摄氏温度Version: 0.1Author: 骆昊"""f = float(input('请输入华氏温度: '))c = (f - 32) / 1.8print('%.1f华氏度 = %.1f摄氏度' % (f, c))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：在使用<code>print</code>函数输出时，也可以对字符串内容进行格式化处理，上面<code>print</code>函数中的字符串<code>%.1f</code>是一个占位符，稍后会由一个<code>float</code>类型的变量值替换掉它。同理，如果字符串中有<code>%d</code>，后面可以用一个<code>int</code>类型的变量值替换掉它，而<code>%s</code>会被字符串的值替换掉。除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中<code>{f:.1f}</code>和<code>{c:.1f}</code>可以先看成是<code>{f}</code>和<code>{c}</code>，表示输出时会用变量<code>f</code>和变量<code>c</code>的值替换掉这两个占位符，后面的<code>:.1f</code>表示这是一个浮点数，小数点后保留1位有效数字。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">print(f'{f:.1f}华氏度 = {c:.1f}摄氏度')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h4 id="例子2：输入圆的半径计算计算周长和面积。"><a href="#例子2：输入圆的半径计算计算周长和面积。" class="headerlink" title="例子2：输入圆的半径计算计算周长和面积。"></a>例子2：输入圆的半径计算计算周长和面积。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入半径计算圆的周长和面积Version: 0.1Author: 骆昊"""radius = float(input('请输入圆的半径: '))perimeter = 2 * 3.1416 * radiusarea = 3.1416 * radius * radiusprint('周长: %.2f' % perimeter)print('面积: %.2f' % area)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子3：输入年份判断是不是闰年。"><a href="#例子3：输入年份判断是不是闰年。" class="headerlink" title="例子3：输入年份判断是不是闰年。"></a>例子3：输入年份判断是不是闰年。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入年份 如果是闰年输出True 否则输出FalseVersion: 0.1Author: 骆昊"""year = int(input('请输入年份: '))is_leap = year % 4 == 0 and year % 100 != 0 or year % 400 == 0print(is_leap)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明</strong>：比较运算符会产生布尔值，而逻辑运算符<code>and</code>和<code>or</code>会对这些布尔值进行组合，最终也是得到一个布尔值，闰年输出<code>True</code>，平年输出<code>False</code>。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的例子相信大家感受到了，学会使用运算符以及由运算符构成的表达式，就可以帮助我们解决很多实际的问题，<strong>运算符和表达式对于任何一门编程语言都是非常重要的</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第04课：Python语言元素之运算符&quot;&gt;&lt;a href=&quot;#第04课：Python语言元素之运算符&quot; class=&quot;headerlink&quot; title=&quot;第04课：Python语言元素之运算符&quot;&gt;&lt;/a&gt;第04课：Python语言元素之运算符&lt;/h2&gt;&lt;p&gt;Py</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
  <entry>
    <title>第05课：分支结构</title>
    <link href="http://luxihua.space/blog/yrv4htq8.html"/>
    <id>http://luxihua.space/blog/yrv4htq8.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第05课：分支结构"><a href="#第05课：分支结构" class="headerlink" title="第05课：分支结构"></a>第05课：分支结构</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种代码结构通常称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后，我们要根据玩家得到分数来决定究竟是进入第二关，还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行。类似的场景还有很多，我们将这种结构称之为“分支结构”或“选择结构”。给大家一分钟的时间，你应该可以想到至少5个以上这样的例子，赶紧试一试。</p><h3 id="if语句的使用"><a href="#if语句的使用" class="headerlink" title="if语句的使用"></a>if语句的使用</h3><p>在Python中，要构造分支结构可以使用<code>if</code>、<code>elif</code>和<code>else</code>关键字。所谓<strong>关键字</strong>就是有特殊含义的单词，像<code>if</code>和<code>else</code>就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名。下面的例子中演示了如何构造一个分支结构。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""用户身份验证Version: 0.1Author: 骆昊"""username = input('请输入用户名: ')password = input('请输入口令: ')# 用户名是admin且密码是123456则身份验证成功否则身份验证失败if username == 'admin' and password == '123456':    print('身份验证成功!')else:    print('身份验证失败!')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的是，不同于C++、Java等编程语言，Python中没有用花括号来构造代码块而是<strong>使用了缩进的方式来表示代码的层次结构</strong>，如果<code>if</code>条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了。换句话说<strong>连续的代码如果又保持了相同的缩进那么它们属于同一个代码块</strong>，相当于是一个执行的整体。<strong>缩进</strong>可以使用任意数量的空格，但<strong>通常使用4个空格</strong>，强烈建议大家<strong>不要使用制表键来缩进代码</strong>，如果你已经习惯了这么做，可以<strong>设置代码编辑工具将1个制表键自动变成4个空格</strong>，很多的代码编辑工具都支持这项功能。</p><blockquote><p><strong>提示</strong>：<code>if</code>和<code>else</code> 的最后面有一个<code>:</code>，它是用英文输入法输入的冒号；程序中输入的<code>'</code>、<code>"</code>、<code>=</code>、<code>(</code>、<code>)</code>等特殊字符，都是在英文输入法状态下输入的。有很多初学者经常不注意这一点，结果运行代码的时候就会遇到很多莫名其妙的错误提示。<strong>强烈建议</strong>大家在写代码的时候都<strong>打开英文输入法</strong>（注意是英文输入法而不是中文输入法的英文输入模式），这样可以避免很多不必要的麻烦。</p></blockquote><p>如果要构造出更多的分支，可以使用<code>if...elif...else...</code>结构或者嵌套的<code>if...else...</code>结构，下面的代码演示了如何利用多分支结构实现分段函数求值。</p><p>$$<br>f(x) = \begin{cases} 3x - 5, &amp; (x \gt 1) \ x + 2, &amp; (-1 \le x \le 1) \ 5x + 3, &amp; (x \lt -1) \end{cases}<br>$$</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""分段函数求值Version: 0.1Author: 骆昊"""x = float(input('x = '))if x &gt; 1:    y = 3 * x - 5elif x &gt;= -1:    y = x + 2else:    y = 5 * x + 3print(f'f({x}) = {y}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在<code>if</code>的内部构造出一个新的分支结构，同理<code>elif</code>和<code>else</code>中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""分段函数求值Version: 0.1Author: 骆昊"""x = float(input('x = '))if x &gt; 1:    y = 3 * x - 5else:    if x &gt;= -1:        y = x + 2    else:        y = 5 * x + 3print(f'f({x}) = {y}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明：</strong> 大家可以自己感受和评判一下这两种写法到底是哪一种更好。在<a href="https://zhuanlan.zhihu.com/p/111843067"><strong>Python之禅</strong></a>中有这么一句话：“<strong>Flat is better than nested</strong>”，之所以提倡代码“扁平化”，是因为代码嵌套的层次如果很多，会严重的影响代码的可读性，所以使用更为扁平化的结构在很多场景下都是较好的选择。</p></blockquote><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><h4 id="例子1：英制单位英寸与公制单位厘米互换。"><a href="#例子1：英制单位英寸与公制单位厘米互换。" class="headerlink" title="例子1：英制单位英寸与公制单位厘米互换。"></a>例子1：英制单位英寸与公制单位厘米互换。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""英制单位英寸和公制单位厘米互换Version: 0.1Author: 骆昊"""value = float(input('请输入长度: '))unit = input('请输入单位: ')if unit == 'in' or unit == '英寸':    print('%f英寸 = %f厘米' % (value, value * 2.54))elif unit == 'cm' or unit == '厘米':    print('%f厘米 = %f英寸' % (value, value / 2.54))else:    print('请输入有效的单位')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子2：百分制成绩转换为等级制成绩。"><a href="#例子2：百分制成绩转换为等级制成绩。" class="headerlink" title="例子2：百分制成绩转换为等级制成绩。"></a>例子2：百分制成绩转换为等级制成绩。</h4><blockquote><p><strong>要求</strong>：如果输入的成绩在90分以上（含90分）输出A；80分-90分（不含90分）输出B；70分-80分（不含80分）输出C；60分-70分（不含70分）输出D；60分以下输出E。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""百分制成绩转换为等级制成绩Version: 0.1Author: 骆昊"""score = float(input('请输入成绩: '))if score &gt;= 90:    grade = 'A'elif score &gt;= 80:    grade = 'B'elif score &gt;= 70:    grade = 'C'elif score &gt;= 60:    grade = 'D'else:    grade = 'E'print('对应的等级是:', grade)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子3：输入三条边长，如果能构成三角形就计算周长和面积。"><a href="#例子3：输入三条边长，如果能构成三角形就计算周长和面积。" class="headerlink" title="例子3：输入三条边长，如果能构成三角形就计算周长和面积。"></a>例子3：输入三条边长，如果能构成三角形就计算周长和面积。</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""判断输入的边长能否构成三角形，如果能则计算出三角形的周长和面积Version: 0.1Author: 骆昊"""a = float(input('a = '))b = float(input('b = '))c = float(input('c = '))if a + b &gt; c and a + c &gt; b and b + c &gt; a:    peri = a + b + c    print(f'周长: {peri}')    half = peri / 2    area = (half * (half - a) * (half - b) * (half - c)) ** 0.5    print(f'面积: {area}')else:    print('不能构成三角形')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>说明：</strong> 上面通过边长计算三角形面积的公式叫做<a href="https://zh.wikipedia.org/zh-hans/%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F">海伦公式</a>。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>学会了Python中的分支结构和循环结构，我们就可以用Python程序来解决很多实际的问题了。这一节课相信已经帮助大家记住了<code>if</code>、<code>elif</code>、<code>else</code>这几个关键字以及如何使用它们来构造分支结构，下一节课我们为大家介绍循环结构，学完这两次课你一定会发现，你能写出很多很多非常有意思的代码。继续加油！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第05课：分支结构&quot;&gt;&lt;a href=&quot;#第05课：分支结构&quot; class=&quot;headerlink&quot; title=&quot;第05课：分支结构&quot;&gt;&lt;/a&gt;第05课：分支结构&lt;/h2&gt;&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
  <entry>
    <title>第06课：循环结构</title>
    <link href="http://luxihua.space/blog/smrtkrdm.html"/>
    <id>http://luxihua.space/blog/smrtkrdm.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第06课：循环结构"><a href="#第06课：循环结构" class="headerlink" title="第06课：循环结构"></a>第06课：循环结构</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>我们在写程序的时候，一定会遇到需要重复执行某条指令或某些指令的场景。例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向移动的指令。在这个场景中，让机器人向球门方向移动就是一个需要重复的动作，当然这里还会用到上一课讲的分支结构来判断机器人是否持球以及是否进入射门范围。再举一个简单的例子，如果要实现每隔1秒中在屏幕上打印一次“hello, world”并持续打印一个小时，我们肯定不能够直接把<code>print('hello, world')</code>这句代码写3600遍，这里我们需要构造循环结构。</p><p>所谓循环结构，就是程序中控制某条或某些指令重复执行的结构。在Python中构造循环结构有两种做法，一种是<code>for-in</code>循环，另一种是<code>while</code>循环。</p><h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h3><p>如果明确的知道循环执行的次数，我们推荐使用<code>for-in</code>循环，例如输出100行的”hello, world“。 被<code>for-in</code>循环控制的语句块也是通过缩进的方式来构造的，这一点跟分支结构完全相同，大家看看下面的代码就明白了。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""用for循环实现1~100求和Version: 0.1Author: 骆昊"""total = 0for x in range(1, 101):    total += xprint(total)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的是上面代码中的<code>range(1, 101)</code>可以用来构造一个从<code>1</code>到<code>100</code>的范围，当我们把这样一个范围放到<code>for-in</code>循环中，就可以通过前面的循环变量<code>x</code>依次取出从<code>1</code>到<code>100</code>的整数。当然，<code>range</code>的用法非常灵活，下面给出了一个例子：</p><ul><li><code>range(101)</code>：可以用来产生0到100范围的整数，需要注意的是取不到101。</li><li><code>range(1, 101)</code>：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。</li><li><code>range(1, 101, 2)</code>：可以用来产生1到100的奇数，其中2是步长，即每次递增的值。</li><li><code>range(100, 0, -2)</code>：可以用来产生100到1的偶数，其中-2是步长，即每次递减的值。</li></ul><p>知道了这一点，我们可以用下面的代码来实现1~100之间的偶数求和。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""用for循环实现1~100之间的偶数求和Version: 0.1Author: 骆昊"""total = 0for x in range(2, 101, 2):    total += xprint(total)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>如果要构造不知道具体循环次数的循环结构，我们推荐使用<code>while</code>循环。<code>while</code>循环通过一个能够产生<code>bool</code>值的表达式来控制循环，当表达式的值为<code>True</code>时则继续循环，当表达式的值为<code>False</code>时则结束循环。</p><p>下面我们通过一个“猜数字”的小游戏来看看如何使用<code>while</code>循环。猜数字游戏的规则是：计算机出一个<code>1</code>到<code>100</code>之间的随机数，玩家输入自己猜的数字，计算机给出对应的提示信息（大一点、小一点或猜对了），如果玩家猜中了数字，计算机提示用户一共猜了多少次，游戏结束，否则游戏继续。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""猜数字游戏Version: 0.1Author: 骆昊"""import random# 产生一个1-100范围的随机数answer = random.randint(1, 100)counter = 0while True:    counter += 1    number = int(input('请输入: '))    if number &lt; answer:        print('大一点')    elif number &gt; answer:        print('小一点')    else:        print('恭喜你猜对了!')        break# 当退出while循环的时候显示用户一共猜了多少次print(f'你总共猜了{counter}次')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>上面的代码中使用<code>while True</code>构造了一个条件恒成立的循环，也就意味着如果不做特殊处理，循环是不会结束的，这也就是常说的“死循环”。为了在用户猜中数字时能够退出循环结构，我们使用了<code>break</code>关键字，它的作用是提前结束循环。需要注意的是，<code>break</code>只能终止它所在的那个循环，这一点在使用嵌套循环结构时需要引起注意，下面的例子我们会讲到什么是嵌套的循环结构。除了<code>break</code>之外，还有另一个关键字是<code>continue</code>，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。</p><h3 id="嵌套的循环结构"><a href="#嵌套的循环结构" class="headerlink" title="嵌套的循环结构"></a>嵌套的循环结构</h3><p>和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个乘法口诀表（九九表）。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""打印乘法口诀表Version: 0.1Author: 骆昊"""for i in range(1, 10):    for j in range(1, i + 1):        print(f'{i}*{j}={i * j}', end='\t')    print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很显然，在上面的代码中，外层循环用来控制一共会产生<code>9</code>行的输出，而内层循环用来控制每一行会输出多少列。内层循环中的输出就是九九表一行中的所有列，所以在内层循环完成时，有一个<code>print()</code>来实现换行输出的效果。</p><h3 id="循环的例子"><a href="#循环的例子" class="headerlink" title="循环的例子"></a>循环的例子</h3><h4 id="例子1：输入一个正整数判断它是不是素数。"><a href="#例子1：输入一个正整数判断它是不是素数。" class="headerlink" title="例子1：输入一个正整数判断它是不是素数。"></a>例子1：输入一个正整数判断它是不是素数。</h4><blockquote><p><strong>提示</strong>：素数指的是只能被1和自身整除的大于1的整数。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入一个正整数判断它是不是素数Version: 0.1Author: 骆昊"""num = int(input('请输入一个正整数: '))end = int(num ** 0.5)is_prime = Truefor x in range(2, end + 1):    if num % x == 0:        is_prime = False        breakif is_prime and num != 1:    print(f'{num}是素数')else:    print(f'{num}不是素数')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子2：输入两个正整数，计算它们的最大公约数和最小公倍数。"><a href="#例子2：输入两个正整数，计算它们的最大公约数和最小公倍数。" class="headerlink" title="例子2：输入两个正整数，计算它们的最大公约数和最小公倍数。"></a>例子2：输入两个正整数，计算它们的最大公约数和最小公倍数。</h4><blockquote><p><strong>提示</strong>：两个数的最大公约数是两个数的公共因子中最大的那个数；两个数的最小公倍数则是能够同时被两个数整除的最小的那个数。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输入两个正整数计算它们的最大公约数和最小公倍数Version: 0.1Author: 骆昊"""x = int(input('x = '))y = int(input('y = '))for factor in range(x, 0, -1):    if x % factor == 0 and y % factor == 0:        print(f'{x}和{y}的最大公约数是{factor}')        print(f'{x}和{y}的最小公倍数是{x * y // factor}')        break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>学会了Python中的分支结构和循环结构，我们就可以解决很多实际的问题了。通过这节课的学习，大家应该已经知道了可以用<code>for</code>和<code>while</code>关键字来构造循环结构。<strong>如果知道循环的次数，我们通常使用</strong><code>for</code><strong>循环</strong>；如果<strong>循环次数不能确定，可以用</strong><code>while</code><strong>循环</strong>。在循环中还<strong>可以使用</strong><code>break</code><strong>来提前结束循环</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第06课：循环结构&quot;&gt;&lt;a href=&quot;#第06课：循环结构&quot; class=&quot;headerlink&quot; title=&quot;第06课：循环结构&quot;&gt;&lt;/a&gt;第06课：循环结构&lt;/h2&gt;&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
  <entry>
    <title>第07课：分支和循环结构的应用</title>
    <link href="http://luxihua.space/blog/oldlmbpj.html"/>
    <id>http://luxihua.space/blog/oldlmbpj.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第07课：分支和循环结构的应用"><a href="#第07课：分支和循环结构的应用" class="headerlink" title="第07课：分支和循环结构的应用"></a>第07课：分支和循环结构的应用</h2><p>通过上两节课的学习，大家对Python中的分支和循环结构已经有了感性的认识。<strong>分支和循环结构</strong>的重要性不言而喻，它<strong>是构造程序逻辑的基础</strong>，对于初学者来说也是比较困难的部分。大部分初学者在学习了分支和循环结构后都能理解它们的用途和用法，但是遇到实际问题的时候又无法下手；<strong>看懂别人的代码很容易，但是要自己写出同样的代码却又很难</strong>。如果你也有同样的问题和困惑，千万不要沮丧，这只是因为你才刚刚开始编程之旅，<strong>你的练习量还没有达到让你可以随心所欲的写出代码的程度</strong>，只要加强编程练习，这个问题迟早都会解决的。下面我们就为大家讲解一些经典的案例。</p><h3 id="经典小案例"><a href="#经典小案例" class="headerlink" title="经典小案例"></a>经典小案例</h3><h4 id="例子1：寻找水仙花数。"><a href="#例子1：寻找水仙花数。" class="headerlink" title="例子1：寻找水仙花数。"></a>例子1：寻找水仙花数。</h4><blockquote><p><strong>说明</strong>：水仙花数也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个3位数，该数字每个位上数字的立方之和正好等于它本身，例如：$ 153=1^3+5^3+3^3 $。</p></blockquote><p>这个题目的关键是将一个三位数拆分为个位、十位、百位，这一点利用Python中的<code>//</code>（整除）和<code>%</code>（求模）运算符其实很容易做到，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""找出所有水仙花数Version: 0.1Author: 骆昊"""for num in range(100, 1000):    low = num % 10    mid = num // 10 % 10    high = num // 100    if num == low ** 3 + mid ** 3 + high ** 3:        print(num)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面利用<code>//</code>和<code>%</code>拆分一个数的小技巧在写代码的时候还是很常用的。我们要将一个不知道有多少位的正整数进行反转，例如将<code>12345</code>变成<code>54321</code>，也可以利用这两个运算来实现，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""正整数的反转Version: 0.1Author: 骆昊"""num = int(input('num = '))reversed_num = 0while num &gt; 0:    reversed_num = reversed_num * 10 + num % 10    num //= 10print(reversed_num)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子2：百钱百鸡问题。"><a href="#例子2：百钱百鸡问题。" class="headerlink" title="例子2：百钱百鸡问题。"></a>例子2：百钱百鸡问题。</h4><blockquote><p><strong>说明</strong>：百钱百鸡是我国古代数学家<a href="https://baike.baidu.com/item/%E5%BC%A0%E4%B8%98%E5%BB%BA/10246238">张丘建</a>在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现代文是：公鸡5元一只，母鸡3元一只，小鸡1元三只，用100块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""《百钱百鸡》问题Version: 0.1Author: 骆昊"""# 假设公鸡的数量为x，x的取值范围是0到20for x in range(0, 21):    # 假设母鸡的数量为y，y的取值范围是0到33    for y in range(0, 34):        z = 100 - x - y        if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:            print(f'公鸡: {x}只, 母鸡: {y}只, 小鸡: {z}只')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面使用的方法叫做<strong>穷举法</strong>，也称为<strong>暴力搜索法</strong>，这种方法通过一项一项的列举备选解决方案中所有可能的候选项并检查每个候选项是否符合问题的描述，最终得到问题的解。这种方法看起来比较笨拙，但对于运算能力非常强大的计算机来说，通常都是一个可行的甚至是不错的选择，只要问题的解存在就能够找到它。</p><h4 id="例子3：CRAPS赌博游戏。"><a href="#例子3：CRAPS赌博游戏。" class="headerlink" title="例子3：CRAPS赌博游戏。"></a>例子3：CRAPS赌博游戏。</h4><blockquote><p><strong>说明</strong>：CRAPS又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简化后的规则是：玩家第一次摇骰子如果摇出了7点或11点，玩家胜；玩家第一次如果摇出2点、3点或12点，庄家胜；玩家如果摇出其他点数则玩家继续摇骰子，如果玩家摇出了7点，庄家胜；如果玩家摇出了第一次摇的点数，玩家胜；其他点数玩家继续摇骰子，直到分出胜负。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""Craps赌博游戏我们设定游戏开始时玩家有1000元的赌注游戏结束的条件是玩家破产（输光所有的赌注）Version: 0.1Author: 骆昊"""from random import randintmoney = 1000while money &gt; 0:    print(f'你的总资产为: {money}元')    go_on = False    # 下注金额必须大于0小于等于玩家总资产    while True:        debt = int(input('请下注: '))        if 0 &lt; debt &lt;= money:            break    # 第一次摇色子    # 用1到6均匀分布的随机数模拟摇色子得到的点数    first = randint(1, 6) + randint(1, 6)    print(f'\n玩家摇出了{first}点')    if first == 7 or first == 11:        print('玩家胜!\n')        money += debt    elif first == 2 or first == 3 or first == 12:        print('庄家胜!\n')        money -= debt    else:        go_on = True    # 第一次摇色子没有分出胜负游戏继续    while go_on:        go_on = False        current = randint(1, 6) + randint(1, 6)        print(f'玩家摇出了{current}点')        if current == 7:            print('庄家胜!\n')            money -= debt        elif current == first:            print('玩家胜!\n')            money += debt        else:            go_on = Trueprint('你破产了, 游戏结束!')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子4：斐波那契数列。"><a href="#例子4：斐波那契数列。" class="headerlink" title="例子4：斐波那契数列。"></a>例子4：斐波那契数列。</h4><blockquote><p><strong>说明</strong>：斐波那契数列（Fibonacci sequence），通常也被称作黄金分割数列，是意大利数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）在《计算之书》中研究在理想假设条件下兔子成长率问题而引入的数列，因此这个数列也常被戏称为“兔子数列”。斐波那契数列的特点是数列的前两个数都是1，从第三个数开始，每个数都是它前面两个数的和，按照这个规律，斐波那契数列的前10个数是：<code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55</code>。斐波那契数列在现代物理、准晶体结构、化学等领域都有直接的应用。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输出斐波那契数列前20个数Version: 0.1Author: 骆昊"""a, b = 0, 1for _ in range(20):    a, b = b, a + b    print(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子5：打印100以内的素数。"><a href="#例子5：打印100以内的素数。" class="headerlink" title="例子5：打印100以内的素数。"></a>例子5：打印100以内的素数。</h4><blockquote><p><strong>说明</strong>：素数指的是只能被1和自身整除的正整数（不包括1）。</p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">"""输出100以内的素数Version: 0.1Author: 骆昊"""for num in range(2, 100):    # 假设num是素数    is_prime = True    # 在2到num-1之间找num的因子    for factor in range(2, num):        # 如果找到了num的因子，num就不是素数        if num % factor == 0:            is_prime = False            break    # 如果布尔值为True在num是素数    if is_prime:        print(num)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>还是那句话：<strong>分支结构和循环结构非常重要</strong>，是构造程序逻辑的基础，<strong>一定要通过大量的练习来达到融会贯通</strong>。刚才讲到的CRAPS赌博游戏那个例子可以作为一个标准，如果你能很顺利的完成这段代码，那么分支和循环结构的知识你就已经掌握了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第07课：分支和循环结构的应用&quot;&gt;&lt;a href=&quot;#第07课：分支和循环结构的应用&quot; class=&quot;headerlink&quot; title=&quot;第07课：分支和循环结构的应用&quot;&gt;&lt;/a&gt;第07课：分支和循环结构的应用&lt;/h2&gt;&lt;p&gt;通过上两节课的学习，大家对Pytho</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
  <entry>
    <title>第08课：常用数据结构之列表</title>
    <link href="http://luxihua.space/blog/qbvnczsp.html"/>
    <id>http://luxihua.space/blog/qbvnczsp.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第08课：常用数据结构之列表"><a href="#第08课：常用数据结构之列表" class="headerlink" title="第08课：常用数据结构之列表"></a>第08课：常用数据结构之列表</h2><p>在开始本节课的内容之前，我们先给大家一个编程任务，将一颗色子掷<code>6000</code>次，统计每个点数出现的次数。这个任务对大家来说应该是非常简单的，我们可以用<code>1</code>到<code>6</code>均匀分布的随机数来模拟掷色子，然后用<code>6</code>个变量分别记录每个点数出现的次数，相信大家都能写出下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomf1 = 0f2 = 0f3 = 0f4 = 0f5 = 0f6 = 0for _ in range(6000):    face = random.randint(1, 6)    if face == 1:        f1 += 1    elif face == 2:        f2 += 1    elif face == 3:        f3 += 1    elif face == 4:        f4 += 1    elif face == 5:        f5 += 1    else:        f6 += 1print(f'1点出现了{f1}次')print(f'2点出现了{f2}次')print(f'3点出现了{f3}次')print(f'4点出现了{f4}次')print(f'5点出现了{f5}次')print(f'6点出现了{f6}次')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看上面的代码，相信大家一定觉得它非常的“笨重”和“丑陋”，更可怕的是，如果要统计掷两颗或者更多的色子统计每个点数出现的次数，那就需要定义更多的变量，写更多的分支结构。讲到这里，相信大家一定想问：有没有办法用一个变量来保存多个数据，有没有办法用统一的代码对多个数据进行操作？答案是肯定的，在Python中我们可以通过容器类型的变量来保存和操作多个数据，我们首先为大家介绍列表（list）这种新的数据类型。</p><h3 id="定义和使用列表"><a href="#定义和使用列表" class="headerlink" title="定义和使用列表"></a>定义和使用列表</h3><p>在Python中，<strong>列表是由一系元素按特定顺序构成的数据序列</strong>，这样就意味着定义一个列表类型的变量，<strong>可以保存多个数据</strong>，而且<strong>允许有重复的数据</strong>。跟上一课我们讲到的字符串类型一样，列表也是一种结构化的、非标量类型，操作一个列表类型的变量，除了可以使用运算符还可以使用它的方法。</p><p>在Python中，可以使用<code>[]</code>字面量语法来定义列表，列表中的多个元素用逗号进行分隔，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items1 = [35, 12, 99, 68, 55, 87]items2 = ['Python', 'Java', 'Go', 'Kotlin']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>除此以外，还可以通过Python内置的<code>list</code>函数将其他序列变成列表。准确的说，<code>list</code>并不是一个普通的函数，它是创建列表对象的构造器（后面会讲到对象和构造器这两个概念）。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items1 = list(range(1, 10))print(items1)    # [1, 2, 3, 4, 5, 6, 7, 8, 9]items2 = list('hello')print(items2)    # ['h', 'e', 'l', 'l', 'o']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的是，列表是一种可变数据类型，也就是说列表可以添加元素、删除元素、更新元素，这一点跟我们上一课讲到的字符串有着鲜明的差别。字符串是一种不可变数据类型，也就是说对字符串做拼接、重复、转换大小写、修剪空格等操作的时候会产生新的字符串，原来的字符串并没有发生任何改变。</p><h4 id="列表的运算符"><a href="#列表的运算符" class="headerlink" title="列表的运算符"></a>列表的运算符</h4><p>和字符串类型一样，列表也支持拼接、重复、成员运算、索引和切片以及比较运算，对此我们不再进行赘述，请大家参考下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items1 = [35, 12, 99, 68, 55, 87]items2 = [45, 8, 29]# 列表的拼接items3 = items1 + items2print(items3)    # [35, 12, 99, 68, 55, 87, 45, 8, 29]# 列表的重复items4 = ['hello'] * 3print(items4)    # ['hello', 'hello', 'hello']# 列表的成员运算print(100 in items3)        # Falseprint('hello' in items4)    # True# 获取列表的长度(元素个数)size = len(items3)print(size)                 # 9# 列表的索引print(items3[0], items3[-size])        # 35 35items3[-1] = 100print(items3[size - 1], items3[-1])    # 100 100# 列表的切片print(items3[:5])          # [35, 12, 99, 68, 55]print(items3[4:])          # [55, 87, 45, 8, 100]print(items3[-5:-7:-1])    # [55, 68]print(items3[::-2])        # [100, 45, 55, 99, 35]# 列表的比较运算items5 = [1, 2, 3, 4]items6 = list(range(1, 5))# 两个列表比较相等性比的是对应索引位置上的元素是否相等print(items5 == items6)    # Trueitems7 = [3, 2, 1]# 两个列表比较大小比的是对应索引位置上的元素的大小print(items5 &lt;= items7)    # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得一提的是，由于列表是可变类型，所以通过索引操作既可以获取列表中的元素，也可以更新列表中的元素。对列表做索引操作一样要注意索引越界的问题，对于有<code>N</code>个元素的列表，正向索引的范围是<code>0</code>到<code>N-1</code>，负向索引的范围是<code>-1</code>到<code>-N</code>，如果超出这个范围，将引发<code>IndexError</code>异常，错误信息为：<code>list index out of range</code>。</p><h4 id="列表元素的遍历"><a href="#列表元素的遍历" class="headerlink" title="列表元素的遍历"></a>列表元素的遍历</h4><p>如果想逐个取出列表中的元素，可以使用<code>for</code>循环的，有以下两种做法。</p><p>方法一：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin']for index in range(len(items)):    print(items[index])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin']for item in items:    print(item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>讲到这里，我们可以用列表的知识来重构上面“掷色子统计每个点数出现次数”的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import randomcounters = [0] * 6for _ in range(6000):    face = random.randint(1, 6)    counters[face - 1] += 1for face in range(1, 7):    print(f'{face}点出现了{counters[face - 1]}次')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，我们用<code>counters</code>列表中的六个元素分别表示1到6的点数出现的次数，最开始的时候六个元素的值都是<code>0</code>。接下来用随机数模拟掷色子，如果摇出1点<code>counters[0]</code>的值加<code>1</code>，如果摇出2点<code>counters[1]</code>的值加<code>1</code>，以此类推。大家感受一下，这段代码是不是比之前的代码要简单优雅很多。</p><h3 id="列表的方法"><a href="#列表的方法" class="headerlink" title="列表的方法"></a>列表的方法</h3><p>和字符串一样，列表类型的方法也很多，下面为大家讲解比较重要的方法。</p><h4 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin']# 使用append方法在列表尾部添加元素items.append('Swift')print(items)    # ['Python', 'Java', 'Go', 'Kotlin', 'Swift']# 使用insert方法在列表指定索引位置插入元素items.insert(2, 'SQL')print(items)    # ['Python', 'Java', 'SQL', 'Go', 'Kotlin', 'Swift']# 删除指定的元素items.remove('Java')print(items)    # ['Python', 'SQL', 'Go', 'Kotlin', 'Swift']# 删除指定索引位置的元素items.pop(0)items.pop(len(items) - 1)print(items)    # ['SQL', 'Go', 'Kotlin']# 清空列表中的元素items.clear()print(items)    # []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要提醒大家，在使用<code>remove</code>方法删除元素时，如果要删除的元素并不在列表中，会引发<code>ValueError</code>异常，错误消息是：<code>list.remove(x): x not in list</code>。在使用<code>pop</code>方法删除元素时，如果索引的值超出了范围，会引发<code>IndexError</code>异常，错误消息是：<code>pop index out of range</code>。</p><p>从列表中删除元素其实还有一种方式，就是使用Python中的<code>del</code>关键字后面跟要删除的元素，这种做法跟使用<code>pop</code>方法指定索引删除元素没有实质性的区别，但后者会返回删除的元素，前者在性能上略优（<code>del</code>对应字节码指令是<code>DELETE_SUBSCR</code>，而<code>pop</code>对应的字节码指令是<code>CALL_METHOD</code>和<code>POP_TOP</code>，不理解就跳过，不用管它！！！）。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin']del items[1]print(items)    # ['Python', 'Go', 'Kotlin']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="元素位置和次数"><a href="#元素位置和次数" class="headerlink" title="元素位置和次数"></a>元素位置和次数</h4><p>列表类型的<code>index</code>方法可以查找某个元素在列表中的索引位置；因为列表中允许有重复的元素，所以列表类型提供了<code>count</code>方法来统计一个元素在列表中出现的次数。请看下面的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Java', 'Go', 'Kotlin', 'Python']# 查找元素的索引位置print(items.index('Python'))       # 0print(items.index('Python', 2))    # 5# 注意：虽然列表中有'Java'，但是从索引为3这个位置开始后面是没有'Java'的print(items.index('Java', 3))      # ValueError: 'Java' is not in list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看看下面这段代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Java', 'Go', 'Kotlin', 'Python']# 查找元素出现的次数print(items.count('Python'))    # 2print(items.count('Go'))        # 1print(items.count('Swfit'))     # 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="元素排序和反转"><a href="#元素排序和反转" class="headerlink" title="元素排序和反转"></a>元素排序和反转</h4><p>列表的<code>sort</code>操作可以实现列表元素的排序，而<code>reverse</code>操作可以实现元素的反转，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">items = ['Python', 'Java', 'Go', 'Kotlin', 'Python']# 排序items.sort()print(items)    # ['Go', 'Java', 'Kotlin', 'Python', 'Python']# 反转items.reverse()print(items)    # ['Python', 'Python', 'Kotlin', 'Java', 'Go']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列表的生成式"><a href="#列表的生成式" class="headerlink" title="列表的生成式"></a>列表的生成式</h3><p>在Python中，列表还可以通过一种特殊的字面量语法来创建，这种语法叫做生成式。我们给出两段代码，大家可以做一个对比，看看哪一种方式更加简单优雅。</p><p>通过<code>for</code>循环为空列表添加元素。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 创建一个由1到9的数字构成的列表items1 = []for x in range(1, 10):    items1.append(x)print(items1)# 创建一个由'hello world'中除空格和元音字母外的字符构成的列表items2 = []for x in 'hello world':    if x not in ' aeiou':        items2.append(x)print(items2)# 创建一个由个两个字符串中字符的笛卡尔积构成的列表items3 = []for x in 'ABC':    for y in '12':        items3.append(x + y)print(items3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过生成式创建列表。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 创建一个由1到9的数字构成的列表items1 = [x for x in range(1, 10)]print(items1)    # [1, 2, 3, 4, 5, 6, 7, 8, 9]# 创建一个由'hello world'中除空格和元音字母外的字符构成的列表items2 = [x for x in 'hello world' if x not in ' aeiou']print(items2)    # ['h', 'l', 'l', 'w', 'r', 'l', 'd']# 创建一个由个两个字符串中字符的笛卡尔积构成的列表items3 = [x + y for x in 'ABC' for y in '12']print(items3)    # ['A1', 'A2', 'B1', 'B2', 'C1', 'C2']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面这种方式不仅代码简单优雅，而且性能也优于上面使用<code>for</code>循环和<code>append</code>方法向空列表中追加元素的方式。可以简单跟大家交待下为什么生成式拥有更好的性能，那是因为Python解释器的字节码指令中有专门针对生成式的指令（<code>LIST_APPEND</code>指令）；而<code>for</code>循环是通过方法调用（<code>LOAD_METHOD</code>和<code>CALL_METHOD</code>指令）的方式为列表添加元素，方法调用本身就是一个相对耗时的操作。对这一点不理解也没有关系，记住“<strong>强烈建议用生成式语法来创建列表</strong>”这个结论就可以了。</p><h3 id="嵌套的列表"><a href="#嵌套的列表" class="headerlink" title="嵌套的列表"></a>嵌套的列表</h3><p>Python语言没有限定列表中的元素必须是相同的数据类型，也就是说一个列表中的元素可以任意的数据类型，当然也包括列表。如果列表中的元素又是列表，那么我们可以称之为嵌套的列表。嵌套的列表可以用来表示表格或数学上的矩阵，例如：我们想保存5个学生3门课程的成绩，可以定义一个保存5个元素的列表保存5个学生的信息，而每个列表元素又是3个元素构成的列表，分别代表3门课程的成绩。但是，一定要注意下面的代码是有问题的。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">scores = [[0] * 3] * 5print(scores)    # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看上去我们好像创建了一个<code>5 * 3</code>的嵌套列表，但实际上当我们录入第一个学生的第一门成绩后，你就会发现问题来了，我们看看下面代码的输出。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 嵌套的列表需要多次索引操作才能获取元素scores[0][0] = 95print(scores)# [[95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们不去过多的解释为什么会出现这样的问题，如果想深入研究这个问题，可以通过<a href="http://www.pythontutor.com/visualize.html">Python Tutor</a>网站的可视化代码执行功能，看看创建列表时计算机内存中发生了怎样的变化，下面的图就是在这个网站上生成的。建议大家不去纠结这个问题，现阶段只需要记住不能用<code>[[0] * 3] * 5]</code>这种方式来创建嵌套列表就行了。那么创建嵌套列表的正确做法是什么呢，下面的代码会给你答案。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">scores = [[0] * 3 for _ in range(5)]scores[0][0] = 95print(scores)# [[95, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python中的列表底层是一个可以动态扩容的数组，列表元素在内存中也是连续存储的，所以可以实现随机访问（通过一个有效的索引获取到对应的元素且操作时间与列表元素个数无关）。我们暂时不去触碰这些底层存储细节以及列表每个方法的渐近时间复杂度（执行这个方法耗费的时间跟列表元素个数的关系），等需要的时候再告诉大家。现阶段，大家只需要知道<strong>列表是容器</strong>，可以<strong>保存各种类型的数据</strong>，<strong>可以通过索引操作列表元素</strong>，知道这些就足够了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第08课：常用数据结构之列表&quot;&gt;&lt;a href=&quot;#第08课：常用数据结构之列表&quot; class=&quot;headerlink&quot; title=&quot;第08课：常用数据结构之列表&quot;&gt;&lt;/a&gt;第08课：常用数据结构之列表&lt;/h2&gt;&lt;p&gt;在开始本节课的内容之前，我们先给大家一个编程</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
  <entry>
    <title>第09课：常用数据结构之元组</title>
    <link href="http://luxihua.space/blog/orxyj1jy.html"/>
    <id>http://luxihua.space/blog/orxyj1jy.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第09课：常用数据结构之元组"><a href="#第09课：常用数据结构之元组" class="headerlink" title="第09课：常用数据结构之元组"></a>第09课：常用数据结构之元组</h2><p>上一节课为大家讲解了Python中的列表，它是一种容器型数据类型，我们可以通过定义列表类型的变量来保存和操作多个元素。当然，Python中容器型的数据类型肯定不止列表一种，接下来我们为大家讲解另一种重要的容器型数据类型，它的名字叫元组（tuple）。</p><h3 id="定义和使用元组"><a href="#定义和使用元组" class="headerlink" title="定义和使用元组"></a>定义和使用元组</h3><p>在Python中，元组也是多个元素按照一定的顺序构成的序列。元组和列表的不同之处在于，元组是不可变类型，这就意味着元组类型的变量一旦定义，其中的元素不能再添加或删除，而且元素的值也不能进行修改。定义元组通常使用<code>()</code>字面量语法，也建议大家使用这种方式来创建元组。元组类型支持的运算符跟列表是一样。下面的代码演示了元组的定义和运算。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 定义一个三元组t1 = (30, 10, 55)# 定义一个四元组t2 = ('骆昊', 40, True, '四川成都')# 查看变量的类型print(type(t1), type(t2))    # &lt;class 'tuple'&gt; &lt;class 'tuple'&gt;# 查看元组中元素的数量print(len(t1), len(t2))      # 3 4# 通过索引运算获取元组中的元素print(t1[0], t1[-3])         # 30 30print(t2[3], t2[-1])         # 四川成都 四川成都# 循环遍历元组中的元素for member in t2:    print(member)# 成员运算print(100 in t1)    # Falseprint(40 in t2)     # True# 拼接t3 = t1 + t2print(t3)           # (30, 10, 55, '骆昊', 40, True, '四川成都')# 切片print(t3[::3])      # (30, '骆昊', '四川成都')# 比较运算print(t1 == t3)    # Falseprint(t1 &gt;= t3)    # Falseprint(t1 &lt; (30, 11, 55))    # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个元组中如果有两个元素，我们就称之为二元组；一个元组中如果五个元素，我们就称之为五元组。需要提醒大家注意的是，<code>()</code>表示空元组，但是如果元组中只有一个元素，需要加上一个逗号，否则<code>()</code>就不是代表元组的字面量语法，而是改变运算优先级的圆括号，所以<code>('hello', )</code>和<code>(100, )</code>才是一元组，而<code>('hello')</code>和<code>(100)</code>只是字符串和整数。我们可以通过下面的代码来加以验证。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 空元组a = ()print(type(a))    # &lt;class 'tuple'&gt;# 不是元组b = ('hello')print(type(b))    # &lt;class 'str'&gt;c = (100)print(type(c))    # &lt;class 'int'&gt;# 一元组d = ('hello', )print(type(d))    # &lt;class 'tuple'&gt;e = (100, )print(type(e))    # &lt;class 'tuple'&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="元组的应用场景"><a href="#元组的应用场景" class="headerlink" title="元组的应用场景"></a>元组的应用场景</h3><p>讲到这里，相信大家一定迫切的想知道元组有哪些应用场景，我们给大家举几个例子。</p><h4 id="例子1：打包和解包操作。"><a href="#例子1：打包和解包操作。" class="headerlink" title="例子1：打包和解包操作。"></a>例子1：打包和解包操作。</h4><p>当我们把多个用逗号分隔的值赋给一个变量时，多个值会打包成一个元组类型；当我们把一个元组赋值给多个变量时，元组会解包成多个值然后分别赋给对应的变量，如下面的代码所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 打包a = 1, 10, 100print(type(a), a)    # &lt;class 'tuple'&gt; (1, 10, 100)# 解包i, j, k = aprint(i, j, k)       # 1 10 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在解包时，如果解包出来的元素个数和变量个数不对应，会引发<code>ValueError</code>异常，错误信息为：<code>too many values to unpack</code>（解包的值太多）或<code>not enough values to unpack</code>（解包的值不足）。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 1, 10, 100, 1000# i, j, k = a             # ValueError: too many values to unpack (expected 3)# i, j, k, l, m, n = a    # ValueError: not enough values to unpack (expected 6, got 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有一种解决变量个数少于元素的个数方法，就是使用星号表达式，我们之前讲函数的可变参数时使用过星号表达式。有了星号表达式，我们就可以让一个变量接收多个值，代码如下所示。需要注意的是，用星号表达式修饰的变量会变成一个列表，列表中有0个或多个元素。还有在解包语法中，星号表达式只能出现一次。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 1, 10, 100, 1000i, j, *k = aprint(i, j, k)          # 1 10 [100, 1000]i, *j, k = aprint(i, j, k)          # 1 [10, 100] 1000*i, j, k = aprint(i, j, k)          # [1, 10] 100 1000*i, j = aprint(i, j)             # [1, 10, 100] 1000i, *j = aprint(i, j)             # 1 [10, 100, 1000]i, j, k, *l = aprint(i, j, k, l)       # 1 10 100 [1000]i, j, k, l, *m = aprint(i, j, k, l, m)    # 1 10 100 1000 []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明一点，解包语法对所有的序列都成立，这就意味着对列表以及我们之前讲到的<code>range</code>函数返回的范围序列都可以使用解包语法。大家可以尝试运行下面的代码，看看会出现怎样的结果。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a, b, *c = range(1, 10)print(a, b, c)a, b, c = [1, 10, 100]print(a, b, c)a, *b, c = 'hello'print(a, b, c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子2：交换两个变量的值。"><a href="#例子2：交换两个变量的值。" class="headerlink" title="例子2：交换两个变量的值。"></a>例子2：交换两个变量的值。</h4><p>交换两个变量的值是编程语言中的一个经典案例，在很多编程语言中，交换两个变量的值都需要借助一个中间变量才能做到，如果不用中间变量就需要使用比较晦涩的位运算来实现。在Python中，交换两个变量<code>a</code>和<code>b</code>的值只需要使用如下所示的代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a, b = b, a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，如果要将三个变量<code>a</code>、<code>b</code>、<code>c</code>的值互换，即<code>b</code>赋给<code>a</code>，<code>c</code>赋给<code>b</code>，<code>a</code>赋给<code>c</code>，也可以如法炮制。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a, b, c = b, c, a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要说明的是，上面并没有用到打包和解包语法，Python的字节码指令中有<code>ROT_TWO</code>和<code>ROT_THREE</code>这样的指令可以实现这个操作，效率是非常高的。但是如果有多于三个变量的值要依次互换，这个时候没有直接可用的字节码指令，执行的原理就是我们上面讲解的打包和解包操作。</p><h3 id="元组和列表的比较"><a href="#元组和列表的比较" class="headerlink" title="元组和列表的比较"></a>元组和列表的比较</h3><p>这里还有一个非常值得探讨的问题，Python中已经有了列表类型，为什么还需要元组这样的类型呢？这个问题对于初学者来说似乎有点困难，不过没有关系，我们先抛出观点，大家可以一边学习一边慢慢体会。</p><ol><li><p>元组是不可变类型，<strong>不可变类型更适合多线程环境</strong>，因为它降低了并发访问变量的同步化开销。关于这一点，我们会在后面讲解多线程的时候为大家详细论述。</p></li><li><p>元组是不可变类型，通常<strong>不可变类型在创建时间和占用空间上面都优于对应的可变类型</strong>。我们可以使用<code>sys</code>模块的<code>getsizeof</code>函数来检查保存相同元素的元组和列表各自占用了多少内存空间。我们也可以使用<code>timeit</code>模块的<code>timeit</code>函数来看看创建保存相同元素的元组和列表各自花费的时间，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import sysimport timeita = list(range(100000))b = tuple(range(100000))print(sys.getsizeof(a), sys.getsizeof(b))    # 900120 800056print(timeit.timeit('[1, 2, 3, 4, 5, 6, 7, 8, 9]'))print(timeit.timeit('(1, 2, 3, 4, 5, 6, 7, 8, 9)'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Python中的元组和列表是可以相互转换的，我们可以通过下面的代码来做到。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 将元组转换成列表info = ('骆昊', 175, True, '四川成都')print(list(info))       # ['骆昊', 175, True, '四川成都']# 将列表转换成元组fruits = ['apple', 'banana', 'orange']print(tuple(fruits))    # ('apple', 'banana', 'orange')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p><strong>列表和元组都是容器型的数据类型</strong>，即一个变量可以保存多个数据。<strong>列表是可变数据类型</strong>，<strong>元组是不可变数据类型</strong>，所以列表添加元素、删除元素、清空、排序等方法对于元组来说是不成立的。但是列表和元组都可以进行<strong>拼接</strong>、<strong>成员运算</strong>、<strong>索引和切片</strong>这些操作，后面我们要讲到的字符串类型也是这样，因为字符串就是字符按一定顺序构成的序列，在这一点上三者并没有什么区别。我们<strong>推荐大家使用列表的生成式语法来创建列表</strong>，它很好用，也是Python中非常有特色的语法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第09课：常用数据结构之元组&quot;&gt;&lt;a href=&quot;#第09课：常用数据结构之元组&quot; class=&quot;headerlink&quot; title=&quot;第09课：常用数据结构之元组&quot;&gt;&lt;/a&gt;第09课：常用数据结构之元组&lt;/h2&gt;&lt;p&gt;上一节课为大家讲解了Python中的列表，它</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
  <entry>
    <title>第10课：常用数据结构之字符串</title>
    <link href="http://luxihua.space/blog/uhkzcszq.html"/>
    <id>http://luxihua.space/blog/uhkzcszq.html</id>
    <published>2024-02-02T23:14:10.000Z</published>
    <updated>2024-02-03T04:59:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第10课：字符串的使用"><a href="#第10课：字符串的使用" class="headerlink" title="第10课：字符串的使用"></a>第10课：字符串的使用</h2><p>第二次世界大战促使了现代电子计算机的诞生，世界上的第一台通用电子计算机叫ENIAC（电子数值积分计算机），诞生于美国的宾夕法尼亚大学，占地167平米，重量27吨，每秒钟大约能够完成约5000次浮点运算，如下图所示。ENIAC诞生之后被应用于导弹弹道的计算，而数值计算也是现代电子计算机最为重要的一项功能。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210727163610.jpg" width="65%"><p>随着时间的推移，虽然数值运算仍然是计算机日常工作中最为重要的组成部分，但是今天的计算机还要处理大量的以文本形式存在的信息。如果我们希望通过Python程序来操作本这些文本信息，就必须要先了解字符串这种数据类型以及与它相关的知识。</p><h3 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h3><p>所谓<strong>字符串</strong>，就是<strong>由零个或多个字符组成的有限序列</strong>，一般记为：<br>$$<br>s = a_1a_2 \cdots a_n ,,,,, (0 \le n \le \infty)<br>$$<br>在Python程序中，如果我们把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。字符串中的字符可以是特殊符号、英文字母、中文字符、日文的平假名或片假名、希腊字母、<a href="http://www.ruanyifeng.com/blog/2017/04/emoji.html">Emoji字符</a>等。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello, world!'s2 = "你好，世界！"print(s1, s2)# 以三个双引号或单引号开头的字符串可以折行s3 = '''hello, world!'''print(s3, end='')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示</strong>：<code>print</code>函数中的<code>end=''</code>表示输出后不换行，即将默认的结束符<code>\n</code>（换行符）更换为<code>''</code>（空字符）。</p></blockquote><h3 id="转义字符和原始字符串"><a href="#转义字符和原始字符串" class="headerlink" title="转义字符和原始字符串"></a>转义字符和原始字符串</h3><p>可以在字符串中使用<code>\</code>（反斜杠）来表示转义，也就是说<code>\</code>后面的字符不再是它原来的意义，例如：<code>\n</code>不是代表反斜杠和字符<code>n</code>，而是表示换行；<code>\t</code>也不是代表反斜杠和字符<code>t</code>，而是表示制表符。所以如果字符串本身又包含了<code>'</code>、<code>"</code>、<code>\</code>这些特殊的字符，必须要通过<code>\</code>进行转义处理。例如要输出一个带单引号或反斜杠的字符串，需要用如下所示的方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = '\'hello, world!\''print(s1)s2 = '\\hello, world!\\'print(s2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Python中的字符串可以<code>r</code>或<code>R</code>开头，这种字符串被称为原始字符串，意思是字符串中的每个字符都是它本来的含义，没有所谓的转义字符。例如，在字符串<code>'hello\n'</code>中，<code>\n</code>表示换行；而在<code>r'hello\n'</code>中，<code>\n</code>不再表示换行，就是反斜杠和字符<code>n</code>。大家可以运行下面的代码，看看会输出什么。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 字符串s1中\t是制表符，\n是换行符s1 = '\time up \now'print(s1)# 字符串s2中没有转义字符，每个字符都是原始含义s2 = r'\time up \now'print(s2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python中还允许在<code>\</code>后面还可以跟一个八进制或者十六进制数来表示字符，例如<code>\141</code>和<code>\x61</code>都代表小写字母<code>a</code>，前者是八进制的表示法，后者是十六进制的表示法。另外一种表示字符的方式是在<code>\u</code>后面跟Unicode字符编码，例如<code>\u9a86\u660a</code>代表的是中文“骆昊”。运行下面的代码，看看输出了什么。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = '\141\142\143\x61\x62\x63's2 = '\u9a86\u660a'print(s1, s2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="字符串的运算"><a href="#字符串的运算" class="headerlink" title="字符串的运算"></a>字符串的运算</h3><p>Python为字符串类型提供了非常丰富的运算符，我们可以使用<code>+</code>运算符来实现字符串的拼接，可以使用<code>*</code>运算符来重复一个字符串的内容，可以使用<code>in</code>和<code>not in</code>来判断一个字符串是否包含另外一个字符串，我们也可以用<code>[]</code>和<code>[:]</code>运算符从字符串取出某个字符或某些字符。</p><h4 id="拼接和重复"><a href="#拼接和重复" class="headerlink" title="拼接和重复"></a>拼接和重复</h4><p>下面的例子演示了使用<code>+</code>和<code>*</code>运算符来实现字符串的拼接和重复操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello' + ' ' + 'world'print(s1)    # hello worlds2 = '!' * 3print(s2)    # !!!s1 += s2     # s1 = s1 + s2print(s1)    # hello world!!!s1 *= 2      # s1 = s1 * 2print(s1)    # hello world!!!hello world!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用<code>*</code>实现字符串的重复是非常有意思的一个运算符，在很多编程语言中，要表示一个有10个<code>a</code>的字符串，你只能写成<code>"aaaaaaaaaa"</code>，但是在Python中，你可以写成<code>'a' * 10</code>。你可能觉得<code>"aaaaaaaaaa"</code>这种写法也没有什么不方便的，那么想一想，如果字符<code>a</code>要重复100次或者1000次又会如何呢？</p><h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><p>对于两个字符串类型的变量，可以直接使用比较运算符比较两个字符串的相等性或大小。需要说明的是，因为字符串在计算机内存中也是以二进制形式存在的，那么字符串的大小比较比的是每个字符对应的编码的大小。例如<code>A</code>的编码是<code>65</code>， 而<code>a</code>的编码是<code>97</code>，所以<code>'A' &lt; 'a'</code>的结果相当于就是<code>65 &lt; 97</code>的结果，很显然是<code>True</code>；而<code>'boy' &lt; 'bad'</code>，因为第一个字符都是<code>'b'</code>比不出大小，所以实际比较的是第二个字符的大小，显然<code>'o' &lt; 'a'</code>的结果是<code>False</code>，所以<code>'boy' &lt; 'bad'</code>的结果也是<code>False</code>。如果不清楚两个字符对应的编码到底是多少，可以使用<code>ord</code>函数来获得，例如<code>ord('A')</code>的值是<code>65</code>，而<code>ord('昊')</code>的值是<code>26122</code>。下面的代码为大家展示了字符串的比较运算。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'a whole new world's2 = 'hello world'print(s1 == s2, s1 &lt; s2)      # False Trueprint(s2 == 'hello world')    # Trueprint(s2 == 'Hello world')    # Falseprint(s2 != 'Hello world')    # Trues3 = '骆昊'print(ord('骆'), ord('昊'))               # 39558 26122s4 = '王大锤'print(ord('王'), ord('大'), ord('锤'))    # 29579 22823 38180print(s3 &gt; s4, s3 &lt;= s4)      # True False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要强调一下的是，字符串的比较运算比较的是字符串的内容，Python中还有一个<code>is</code>运算符（身份运算符），如果用<code>is</code>来比较两个字符串，它比较的是两个变量对应的字符串对象的内存地址（不理解先跳过），简单的说就是两个变量是否对应内存中的同一个字符串。看看下面的代码就比较清楚<code>is</code>运算符的作用了。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello world's2 = 'hello world's3 = s2# 比较字符串的内容print(s1 == s2, s2 == s3)    # True True# 比较字符串的内存地址print(s1 is s2, s2 is s3)    # False True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成员运算"><a href="#成员运算" class="headerlink" title="成员运算"></a>成员运算</h4><p>Python中可以用<code>in</code>和<code>not in</code>判断一个字符串中是否存在另外一个字符或字符串，<code>in</code>和<code>not in</code>运算通常称为成员运算，会产生布尔值<code>True</code>或<code>False</code>，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello, world'print('wo' in s1)    # Trues2 = 'goodbye'print(s2 in s1)      # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>获取字符串长度没有直接的运算符，而是使用内置函数<code>len</code>，我们在上节课的提到过这个内置函数，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello, world'print(len(s))                   # 12print(len('goodbye, world'))    # 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h4><p>如果希望从字符串中取出某个字符，我们可以对字符串进行索引运算，运算符是<code>[n]</code>，其中<code>n</code>是一个整数，假设字符串的长度为<code>N</code>，那么<code>n</code>可以是从<code>0</code>到<code>N-1</code>的整数，其中<code>0</code>是字符串中第一个字符的索引，而<code>N-1</code>是字符串中最后一个字符的索引，通常称之为正向索引；在Python中，字符串的索引也可以是从<code>-1</code>到<code>-N</code>的整数，其中<code>-1</code>是最后一个字符的索引，而<code>-N</code>则是第一个字符的索引，通常称之为负向索引。注意，因为<strong>字符串是不可变类型</strong>，所以<strong>不能通过索引运算修改字符串中的字符</strong>。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'abc123456'N = len(s)# 获取第一个字符print(s[0], s[-N])    # a a# 获取最后一个字符print(s[N-1], s[-1])  # 6 6# 获取索引为2或-7的字符print(s[2], s[-7])    # c c# 获取索引为5和-4的字符print(s[5], s[-4])    # 3 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要提醒大家注意的是，在进行索引操作时，如果索引越界（正向索引不在<code>0</code>到<code>N-1</code>范围，负向索引不在<code>-1</code>到<code>-N</code>范围），会引发<code>IndexError</code>异常，错误提示信息为：<code>string index out of range</code>（字符串索引超出范围）。</p><p>如果要从字符串中取出多个字符，我们可以对字符串进行切片，运算符是<code>[i:j:k]</code>，其中<code>i</code>是开始索引，索引对应的字符可以取到；<code>j</code>是结束索引，索引对应的字符不能取到；<code>k</code>是步长，默认值为<code>1</code>，表示从前向后获取相邻字符的连续切片，所以<code>:k</code>部分可以省略。假设字符串的长度为<code>N</code>，当<code>k &gt; 0</code>时表示正向切片（从前向后获取字符），如果没有给出<code>i</code>和<code>j</code>的值，则<code>i</code>的默认值是<code>0</code>，<code>j</code>的默认值是<code>N</code>；当<code>k &lt; 0</code>时表示负向切片（从后向前获取字符），如果没有给出<code>i</code>和<code>j</code>的值，则<code>i</code>的默认值是<code>-1</code>，j的默认值是<code>-N - 1</code>。如果不理解，直接看下面的例子，记住第一个字符的索引是<code>0</code>或<code>-N</code>，最后一个字符的索引是<code>N-1</code>或<code>-1</code>就行了。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'abc123456'# i=2, j=5, k=1的正向切片操作print(s[2:5])       # c12# i=-7, j=-4, k=1的正向切片操作print(s[-7:-4])     # c12# i=2, j=9, k=1的正向切片操作print(s[2:])        # c123456# i=-7, j=9, k=1的正向切片操作print(s[-7:])       # c123456# i=2, j=9, k=2的正向切片操作print(s[2::2])      # c246# i=-7, j=9, k=2的正向切片操作print(s[-7::2])     # c246# i=0, j=9, k=2的正向切片操作print(s[::2])       # ac246# i=1, j=-1, k=2的正向切片操作print(s[1:-1:2])    # b135# i=7, j=1, k=-1的负向切片操作print(s[7:1:-1])    # 54321c# i=-2, j=-8, k=-1的负向切片操作print(s[-2:-8:-1])  # 54321c# i=7, j=-10, k=-1的负向切片操作print(s[7::-1])     # 54321cba# i=-1, j=1, k=-1的负向切片操作print(s[:1:-1])     # 654321c# i=0, j=9, k=1的正向切片print(s[:])         # abc123456# i=0, j=9, k=2的正向切片print(s[::2])       # ac246# i=-1, j=-10, k=-1的负向切片print(s[::-1])      # 654321cba# i=-1, j=-10, k=-2的负向切片print(s[::-2])      # 642ca<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环遍历每个字符"><a href="#循环遍历每个字符" class="headerlink" title="循环遍历每个字符"></a>循环遍历每个字符</h4><p>如果希望从字符串中取出每个字符，可以使用<code>for</code>循环对字符串进行遍历，有两种方式。</p><p>方式一：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello'for index in range(len(s1)):    print(s1[index])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>方式二：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello'for ch in s1:    print(ch)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><p>在Python中，我们可以通过字符串类型自带的方法对字符串进行操作和处理，对于一个字符串类型的变量，我们可以用<code>变量名.方法名()</code>的方式来调用它的方法。所谓方法其实就是跟某个类型的变量绑定的函数，后面我们讲面向对象编程的时候还会对这一概念详加说明。</p><h4 id="大小写相关操作"><a href="#大小写相关操作" class="headerlink" title="大小写相关操作"></a>大小写相关操作</h4><p>下面的代码演示了和字符串大小写变换相关的方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello, world!'# 使用capitalize方法获得字符串首字母大写后的字符串print(s1.capitalize())   # Hello, world!# 使用title方法获得字符串每个单词首字母大写后的字符串print(s1.title())        # Hello, World!# 使用upper方法获得字符串大写后的字符串print(s1.upper())        # HELLO, WORLD!s2 = 'GOODBYE'# 使用lower方法获得字符串小写后的字符串print(s2.lower())        # goodbye<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>如果想在一个字符串中从前向后查找有没有另外一个字符串，可以使用字符串的<code>find</code>或<code>index</code>方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello, world!'# find方法从字符串中查找另一个字符串所在的位置# 找到了返回字符串中另一个字符串首字符的索引print(s.find('or'))        # 8# 找不到返回-1print(s.find('shit'))      # -1# index方法与find方法类似# 找到了返回字符串中另一个字符串首字符的索引print(s.index('or'))       # 8# 找不到引发异常print(s.index('shit'))     # ValueError: substring not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用<code>find</code>和<code>index</code>方法时还可以通过方法的参数来指定查找的范围，也就是查找不必从索引为<code>0</code>的位置开始。<code>find</code>和<code>index</code>方法还有逆向查找（从后向前查找）的版本，分别是<code>rfind</code>和<code>rindex</code>，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello good world!'# 从前向后查找字符o出现的位置(相当于第一次出现)print(s.find('o'))       # 4# 从索引为5的位置开始查找字符o出现的位置print(s.find('o', 5))    # 7# 从后向前查找字符o出现的位置(相当于最后一次出现)print(s.rfind('o'))      # 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="性质判断"><a href="#性质判断" class="headerlink" title="性质判断"></a>性质判断</h4><p>可以通过字符串的<code>startswith</code>、<code>endswith</code>来判断字符串是否以某个字符串开头和结尾；还可以用<code>is</code>开头的方法判断字符串的特征，这些方法都返回布尔值，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s1 = 'hello, world!'# startwith方法检查字符串是否以指定的字符串开头返回布尔值print(s1.startswith('He'))    # Falseprint(s1.startswith('hel'))   # True# endswith方法检查字符串是否以指定的字符串结尾返回布尔值print(s1.endswith('!'))       # Trues2 = 'abc123456'# isdigit方法检查字符串是否由数字构成返回布尔值print(s2.isdigit())    # False# isalpha方法检查字符串是否以字母构成返回布尔值print(s2.isalpha())    # False# isalnum方法检查字符串是否以数字和字母构成返回布尔值print(s2.isalnum())    # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>在Python中，字符串类型可以通过<code>center</code>、<code>ljust</code>、<code>rjust</code>方法做居中、左对齐和右对齐的处理。如果要在字符串的左侧补零，也可以使用<code>zfill</code>方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello, world'# center方法以宽度20将字符串居中并在两侧填充*print(s.center(20, '*'))  # ****hello, world****# rjust方法以宽度20将字符串右对齐并在左侧填充空格print(s.rjust(20))        #         hello, world# ljust方法以宽度20将字符串左对齐并在右侧填充~print(s.ljust(20, '~'))   # hello, world~~~~~~~~# 在字符串的左侧补零print('33'.zfill(5))      # 00033print('-33'.zfill(5))     # -0033<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们之前讲过，在用<code>print</code>函数输出字符串时，可以用下面的方式对字符串进行格式化。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 321b = 123print('%d * %d = %d' % (a, b, a * b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，我们也可以用字符串的方法来完成字符串的格式，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 321b = 123print('{0} * {1} = {2}'.format(a, b, a * b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从Python 3.6开始，格式化字符串还有更为简洁的书写方式，就是在字符串前加上<code>f</code>来格式化字符串，在这种以<code>f</code>打头的字符串中，<code>{变量名}</code>是一个占位符，会被变量对应的值将其替换掉，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = 321b = 123print(f'{a} * {b} = {a * b}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果需要进一步控制格式化语法中变量值的形式，可以参照下面的表格来进行字符串格式化操作。</p><table><thead><tr><th>变量值</th><th>占位符</th><th>格式化结果</th><th>说明</th></tr></thead><tbody><tr><td><code>3.1415926</code></td><td><code>{:.2f}</code></td><td><code>'3.14'</code></td><td>保留小数点后两位</td></tr><tr><td><code>3.1415926</code></td><td><code>{:+.2f}</code></td><td><code>'+3.14'</code></td><td>带符号保留小数点后两位</td></tr><tr><td><code>-1</code></td><td><code>{:+.2f}</code></td><td><code>'-1.00'</code></td><td>带符号保留小数点后两位</td></tr><tr><td><code>3.1415926</code></td><td><code>{:.0f}</code></td><td><code>'3'</code></td><td>不带小数</td></tr><tr><td><code>123</code></td><td><code>{:0&gt;10d}</code></td><td><code>'0000000123'</code></td><td>左边补<code>0</code>，补够10位</td></tr><tr><td><code>123</code></td><td><code>{:x&lt;10d}</code></td><td><code>'123xxxxxxx'</code></td><td>右边补<code>x</code> ，补够10位</td></tr><tr><td><code>123</code></td><td><code>{:&gt;10d}</code></td><td><code>'       123'</code></td><td>左边补空格，补够10位</td></tr><tr><td><code>123</code></td><td><code>{:&lt;10d}</code></td><td><code>'123       '</code></td><td>右边补空格，补够10位</td></tr><tr><td><code>123456789</code></td><td><code>{:,}</code></td><td><code>'123,456,789'</code></td><td>逗号分隔格式</td></tr><tr><td><code>0.123</code></td><td><code>{:.2%}</code></td><td><code>'12.30%'</code></td><td>百分比格式</td></tr><tr><td><code>123456789</code></td><td><code>{:.2e}</code></td><td><code>'1.23e+08'</code></td><td>科学计数法格式</td></tr></tbody></table><h4 id="修剪操作"><a href="#修剪操作" class="headerlink" title="修剪操作"></a>修剪操作</h4><p>字符串的<code>strip</code>方法可以帮我们获得将原字符串修剪掉左右两端空格之后的字符串。这个方法非常有实用价值，通常用来将用户输入中因为不小心键入的头尾空格去掉，<code>strip</code>方法还有<code>lstrip</code>和<code>rstrip</code>两个版本，相信从名字大家已经猜出来这两个方法是做什么用的。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = '   jackfrued@126.com  \t\r\n'# strip方法获得字符串修剪左右两侧空格之后的字符串print(s.strip())    # jackfrued@126.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h4><p>如果希望用新的内容替换字符串中指定的内容，可以使用<code>replace</code>方法，代码如下所示。<code>replace</code>方法的第一个参数是被替换的内容，第二个参数是替换后的内容，还可以通过第三个参数指定替换的次数。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'hello, world'print(s.replace('o', '@'))     # hell@, w@rldprint(s.replace('o', '@', 1))  # hell@, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="拆分-x2F-合并操作"><a href="#拆分-x2F-合并操作" class="headerlink" title="拆分/合并操作"></a>拆分/合并操作</h4><p>可以使用字符串的<code>split</code>方法将一个字符串拆分为多个字符串（放在一个列表中），也可以使用字符串的<code>join</code>方法将列表中的多个字符串连接成一个字符串，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'I love you'words = s.split()print(words)            # ['I', 'love', 'you']print('#'.join(words))  # I#love#you<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的是，<code>split</code>方法默认使用空格进行拆分，我们也可以指定其他的字符来拆分字符串，而且还可以指定最大拆分次数来控制拆分的效果，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">s = 'I#love#you#so#much'words = s.split('#')print(words)  # ['I', 'love', 'you', 'so', 'much']words = s.split('#', 3)print(words)  # ['I', 'love', 'you', 'so#much']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="编码-x2F-解码操作"><a href="#编码-x2F-解码操作" class="headerlink" title="编码/解码操作"></a>编码/解码操作</h4><p>Python中除了字符串<code>str</code>类型外，还有一种表示二进制数据的字节串类型（<code>bytes</code>）。所谓字节串，就是<strong>由零个或多个字节组成的有限序列</strong>。通过字符串的<code>encode</code>方法，我们可以按照某种编码方式将字符串编码为字节串，我们也可以使用字节串的<code>decode</code>方法，将字节串解码为字符串，代码如下所示。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = '骆昊'b = a.encode('utf-8')c = a.encode('gbk')print(b, c)  # b'\xe9\xaa\x86\xe6\x98\x8a' b'\xc2\xe6\xea\xbb'print(b.decode('utf-8'))print(c.decode('gbk'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，如果编码和解码的方式不一致，会导致乱码问题（无法再现原始的内容）或引发<code>UnicodeDecodeError</code>错误导致程序崩溃。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>对于字符串类型来说，还有一个常用的操作是对字符串进行匹配检查，即检查字符串是否满足某种特定的模式。例如，一个网站对用户注册信息中用户名和邮箱的检查，就属于模式匹配检查。实现模式匹配检查的工具叫做正则表达式，Python语言通过标准库中的<code>re</code>模块提供了对正则表达式的支持，我们会在后续的课程中为大家讲解这个知识点。</p><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>知道如何表示和操作字符串对程序员来说是非常重要的，因为我们需要处理文本信息，Python中操作字符串可以用拼接、切片等运算符，也可以使用字符串类型的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第10课：字符串的使用&quot;&gt;&lt;a href=&quot;#第10课：字符串的使用&quot; class=&quot;headerlink&quot; title=&quot;第10课：字符串的使用&quot;&gt;&lt;/a&gt;第10课：字符串的使用&lt;/h2&gt;&lt;p&gt;第二次世界大战促使了现代电子计算机的诞生，世界上的第一台通用电子计算</summary>
      
    
    
    
    <category term="Python" scheme="http://luxihua.space/categories/Python/"/>
    
    
    <category term="Python-Core-50-Courses" scheme="http://luxihua.space/tags/Python-Core-50-Courses/"/>
    
  </entry>
  
</feed>
